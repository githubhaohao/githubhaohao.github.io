<html>
  <head>
    <title>RecyclerView 加载与刷新功能实现 - haohao</title>
    <link href='/images/ic_small.png' rel='shortcut icon'>
<link href='/atom.xml' rel='alternate' type='application/rss+xml'>
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/highlight.css">
<link rel="stylesheet" href="/css/responsive.css">
<script src="/js/jquery.js"></script>
<script src="/js/basics.js"></script>
<meta content='width=device-width, initial-scale=1.0, user-scalable=no' name='viewport'>
<meta content='text/html; charset=utf-8' http-equiv='content-type'>


	<script src="/prettify/prettify.js" type="text/javascript"></script>
	<link rel="stylesheet" href="/themes/tomorrow-night-eighties.css" type="text/css">
  </head>
  <body>
    <header>
  <a id='go-back-home' href='/'><img src='/images/ic_middle.png' alt='Home' width='96' height='96'></a>
  <p>haohao</p>
  <p>不忘初心，不惧未来</p>
</header>

    <div id='container'>
      <div class='block'>
  
    <a class='main' href='/'>Home</a>
  
    <a class='main' href='/custom'>About</a>
  
    <a class='main' href='mailto:haohaochang86@gmail.com'>Email</a>
  
    <a class='main' href='https://github.com/githubhaohao'>Github</a>
  
</div>

      <section class='paging'>
  
    <div class='left'>
      <a href='/2017/04/15/Android-Clean-架构浅析/'>
        ‹
      </a>
    </div>
  
  
    <div class='right'>
      <a href='/2017/04/01/Android-jar-与-aar/'>
        ›
      </a>
    </div>
  
</section>

      <div class='content'>
        <section class='post'>
          <h1>
            <div class='date'>2017-04-13</div>
            RecyclerView 加载与刷新功能实现
          </h1>
          <p align="center"><img src="http://i2.muimg.com/588795/9485f3b972f5ed01.jpg" alt="Cover"></p>

<p align="center">坚持就是进步</p>

<blockquote>
<p>最近 Kotlin Android 开发貌似要火起来，Kotlin 具有脚本语言风格，能与 Java 无缝兼容，并且有 Google 有意栽培。</p>
</blockquote>
<h2 id="RecyclerView-加载与刷新功能实现"><a href="#RecyclerView-加载与刷新功能实现" class="headerlink" title="RecyclerView 加载与刷新功能实现"></a>RecyclerView 加载与刷新功能实现</h2><p>RecyclerView 功能及灵活性强大到令人发指。在开发中，完全可以用它代替 ListView 和 GridView ，并且还具有瀑布流展示功能。</p>
<p>本文主要对 RecyclerView 进行简单的封装，来实现加载、刷新以及异常状态展示多种功能，实现及其简单，代码量很少。</p>
<h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p><img src="http://i1.piimg.com/588795/ddbeb1bc164791d2.gif" alt="jc-a"><br><img src="http://i1.piimg.com/588795/a8ccce06b8991393.gif" alt="jc-b"></p>
<p><a href="https://github.com/githubhaohao/JCRecyclerView/blob/master/demo.apk" target="_blank" rel="external">Demo 下载</a></p>
<blockquote><p><a href="https://github.com/githubhaohao/JCRecyclerView" target="_blank" rel="external">源码地址: https://github.com/githubhaohao/JCRecyclerView</a></p>
</blockquote>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>JCRecyclerView 继承 RecyclerView ，保留 RecyclerView 的所有特性。</p>
<p>内部类 JCAdapter 对外部的 RecyclerView Adapter 进行拦截改造，实现根据配置在 position = 0 的位置加载 Ad-Slot View （广告位），加载时在底部显示 Bottom View 表视加载正在进行。</p>
<pre><code class="java">    private class JCAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; {

        private RecyclerView.Adapter adapter;

        private static final int TYPE_ADSLOT = 0x10;
        private static final int TYPE_NORMAL = 0x11;
        private static final int TYPE_BOTTOM = 0x12;

        public JCAdapter(RecyclerView.Adapter adapter) {
            this.adapter = adapter;
        }

        @Override
        public void onViewAttachedToWindow(ViewHolder holder) {
            super.onViewAttachedToWindow(holder);
            ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams();
            if(layoutParams != null){
                if(adSlotView != null) {
                    if(layoutParams instanceof  StaggeredGridLayoutManager.LayoutParams &amp;&amp; holder.getLayoutPosition() == 0){
                        StaggeredGridLayoutManager.LayoutParams p = (StaggeredGridLayoutManager.LayoutParams) layoutParams;
                        p.setFullSpan(true);
                    }
                }
                if (bottomView != null &amp;&amp; isLoading) {
                    if(layoutParams instanceof  StaggeredGridLayoutManager.LayoutParams &amp;&amp; holder.getLayoutPosition() == getItemCount() - 1){
                        StaggeredGridLayoutManager.LayoutParams p = (StaggeredGridLayoutManager.LayoutParams) layoutParams;
                        p.setFullSpan(true);
                    }
                }

            }

            if (layoutManager instanceof GridLayoutManager) {
                final GridLayoutManager gridManager = ((GridLayoutManager)
                        layoutManager);
                gridManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() {
                    @Override
                    public int getSpanSize(int position) {
                        boolean spanResult = false;
                        if(adSlotView != null &amp;&amp; bottomView != null) {
                            if (isLoading) {
                                spanResult = (position == 0 || position == getItemCount() - 1);
                            } else {
                                spanResult = (position == 0);
                            }
                        } else if (adSlotView != null) {
                            spanResult = (position==0);
                        } else if (bottomView != null &amp;&amp; isLoading) {
                            spanResult = (position == getItemCount() - 1);
                        }

                        return spanResult
                                ? gridManager.getSpanCount():1;
                    }
                });
            }
        }

        @Override

        public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
            if (viewType == TYPE_ADSLOT) {
                return new JCViewHolder(adSlotView);
            } else if (viewType == TYPE_BOTTOM) {
                return new JCViewHolder(bottomView);
            }

            return adapter.onCreateViewHolder(parent,viewType);
        }

        @Override
        public void onBindViewHolder(ViewHolder holder, int position) {
            if (getItemViewType(0) == TYPE_ADSLOT) {
                if (position == 0) return;
                int newPosition = --position;
                if (adapter != null) {
                    if (newPosition &lt; adapter.getItemCount()) {
                        adapter.onBindViewHolder(holder, newPosition);
                    }
                }
                return;
            } else if (getItemViewType(position) == TYPE_BOTTOM) {
                return;
            }
            adapter.onBindViewHolder(holder, position);

        }

        @Override
        public int getItemCount() {
            int count = adapter.getItemCount();
            if (adSlotView != null) {
                count ++;
            }

            if (bottomView != null &amp;&amp; isLoading) {
                count ++;
            }
            return count;
        }

        @Override
        public int getItemViewType(int position) {
            if (position == 0) {
                return adSlotView == null ? TYPE_NORMAL : TYPE_ADSLOT;
            } else if (position == getItemCount() - 1 &amp;&amp; isLoading) {
                return bottomView == null ? TYPE_NORMAL : TYPE_BOTTOM;
            } else {
                return TYPE_NORMAL;
            }
        }
    }
</code></pre>
<p>向外暴露一个接口 OnLoadMoreListener ，完成加载时的回调。</p>
<pre><code class="java">    public interface OnLoadMoreListener {
        void onLoadMore();
    }
</code></pre>
<p>整体思路就是这些，完整代码：</p>
<pre><code class="java">public class JCRecyclerView extends RecyclerView {

    private static final String TAG = JCRecyclerView.class.getSimpleName();
    private LayoutManager layoutManager;
    private ViewGroup adSlotView;
    private ViewGroup stateView;
    private ViewGroup bottomView;
    private boolean isLoading = false;
    private JCAdapter jcAdapter;
    private OnLoadMoreListener onLoadMoreListener;

    public void addOnLoadMoreListener(OnLoadMoreListener listener) {
        this.onLoadMoreListener = listener;
        this.addOnScrollListener(new OnScrollListener() {
            @Override
            public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
                if (recyclerView.getLayoutManager() instanceof StaggeredGridLayoutManager) {
                    StaggeredGridLayoutManager layoutManager = (StaggeredGridLayoutManager) recyclerView.getLayoutManager();
                    int totalItemCount = recyclerView.getAdapter().getItemCount();
                    int[] lastVisibleItemPositions = new int[layoutManager.getSpanCount()];
                    layoutManager.findLastVisibleItemPositions(lastVisibleItemPositions);
                    int visibleItemCount = recyclerView.getChildCount();
                    int lastVisibleItemPosition = findMaxPosition(lastVisibleItemPositions);

                    if (newState == RecyclerView.SCROLL_STATE_IDLE
                            &amp;&amp; lastVisibleItemPosition == totalItemCount - 1
                            &amp;&amp; visibleItemCount &gt; 0) {
                        if (bottomView == null || isLoading || stateView != null) return;

                        isLoading = true;
                        jcAdapter.notifyDataSetChanged();
                        onLoadMoreListener.onLoadMore();
                        scrollToPosition(jcAdapter.getItemCount() - 1);
                    }
                } else {
                    LinearLayoutManager lm = (LinearLayoutManager) recyclerView.getLayoutManager();
                    int totalItemCount = recyclerView.getAdapter().getItemCount();
                    int lastVisibleItemPosition = lm.findLastVisibleItemPosition();
                    int visibleItemCount = recyclerView.getChildCount();

                    if (newState == RecyclerView.SCROLL_STATE_IDLE
                            &amp;&amp; lastVisibleItemPosition == totalItemCount - 1
                            &amp;&amp; visibleItemCount &gt; 0) {
                        if (bottomView == null || isLoading || stateView != null) return;

                        isLoading = true;
                        jcAdapter.notifyDataSetChanged();
                        onLoadMoreListener.onLoadMore();
                        scrollToPosition(jcAdapter.getItemCount() - 1);
                    }

                }

            }
        });

    }

    private int findMaxPosition(int[] positions) {
        int max = positions[0];
        for (int index = 1; index &lt; positions.length; index++) {
            if (positions[index] &gt; max) {
                max = positions[index];
            }
        }
        return max;
    }

    public void setBottomView(ViewGroup view) {
        if (bottomView == null) {
            this.bottomView = view;
        }

    }

    public void setLoading(boolean flag) {
        if (!flag) {
            isLoading = false;
            jcAdapter.notifyDataSetChanged();
            scrollToPosition(jcAdapter.getItemCount() - 1);
        }

    }

    public void setAdSlotView(ViewGroup view) {
        if (adSlotView == null) {
            adSlotView = view;
            if (jcAdapter != null) {
                jcAdapter.notifyItemInserted(0);
                scrollToPosition(0);
            }
        }
    }

    public void setStateView(ViewGroup view) {
        if (stateView != null) return;
        if (view == null) return;
        if (adSlotView != null) {
            scrollToPosition(0);
            stateView = view;
            Rect rect = new Rect();
            getGlobalVisibleRect(rect);
            LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, rect.bottom - rect.top - adSlotView.getHeight());
            adSlotView.addView(stateView, layoutParams);
        } else {
            showToast(&quot;You should set the ad-slot view at first.&quot;);
        }
    }

    public void removeAdSlotView() {
        if (adSlotView != null &amp;&amp; jcAdapter != null) {
            adSlotView = null;
            jcAdapter.notifyItemRemoved(0);
        }
    }

    public void removeStateView() {
        if (adSlotView != null &amp;&amp; stateView != null &amp;&amp; jcAdapter != null) {
            adSlotView.removeView(stateView);
            stateView = null;
        }
    }

    @Override
    public void setAdapter(Adapter adapter) {
        this.jcAdapter = new JCAdapter(adapter);
        super.setAdapter(this.jcAdapter);
    }

    public JCRecyclerView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    public void setLayoutManager(LayoutManager layoutManager) {
        this.layoutManager = layoutManager;
        super.setLayoutManager(layoutManager);
    }

    private class JCAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; {

        private RecyclerView.Adapter adapter;

        private static final int TYPE_ADSLOT = 0x10;
        private static final int TYPE_NORMAL = 0x11;
        private static final int TYPE_BOTTOM = 0x12;

        public JCAdapter(RecyclerView.Adapter adapter) {
            this.adapter = adapter;
        }

        @Override
        public void onViewAttachedToWindow(ViewHolder holder) {
            super.onViewAttachedToWindow(holder);
            ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams();
            if(layoutParams != null){
                if(adSlotView != null) {
                    if(layoutParams instanceof  StaggeredGridLayoutManager.LayoutParams &amp;&amp; holder.getLayoutPosition() == 0){
                        StaggeredGridLayoutManager.LayoutParams p = (StaggeredGridLayoutManager.LayoutParams) layoutParams;
                        p.setFullSpan(true);
                    }
                }
                if (bottomView != null &amp;&amp; isLoading) {
                    if(layoutParams instanceof  StaggeredGridLayoutManager.LayoutParams &amp;&amp; holder.getLayoutPosition() == getItemCount() - 1){
                        StaggeredGridLayoutManager.LayoutParams p = (StaggeredGridLayoutManager.LayoutParams) layoutParams;
                        p.setFullSpan(true);
                    }
                }

            }

            if (layoutManager instanceof GridLayoutManager) {
                final GridLayoutManager gridManager = ((GridLayoutManager)
                        layoutManager);
                gridManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() {
                    @Override
                    public int getSpanSize(int position) {
                        boolean spanResult = false;
                        if(adSlotView != null &amp;&amp; bottomView != null) {
                            if (isLoading) {
                                spanResult = (position == 0 || position == getItemCount() - 1);
                            } else {
                                spanResult = (position == 0);
                            }
                        } else if (adSlotView != null) {
                            spanResult = (position==0);
                        } else if (bottomView != null &amp;&amp; isLoading) {
                            spanResult = (position == getItemCount() - 1);
                        }

                        return spanResult
                                ? gridManager.getSpanCount():1;
                    }
                });
            }
        }

        @Override

        public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
            if (viewType == TYPE_ADSLOT) {
                return new JCViewHolder(adSlotView);
            } else if (viewType == TYPE_BOTTOM) {
                return new JCViewHolder(bottomView);
            }

            return adapter.onCreateViewHolder(parent,viewType);
        }

        @Override
        public void onBindViewHolder(ViewHolder holder, int position) {
            if (getItemViewType(0) == TYPE_ADSLOT) {
                if (position == 0) return;
                int newPosition = --position;
                if (adapter != null) {
                    if (newPosition &lt; adapter.getItemCount()) {
                        adapter.onBindViewHolder(holder, newPosition);
                    }
                }
                return;
            } else if (getItemViewType(position) == TYPE_BOTTOM) {
                return;
            }
            adapter.onBindViewHolder(holder, position);

        }

        @Override
        public int getItemCount() {
            int count = adapter.getItemCount();
            if (adSlotView != null) {
                count ++;
            }

            if (bottomView != null &amp;&amp; isLoading) {
                count ++;
            }
            return count;
        }

        @Override
        public int getItemViewType(int position) {
            if (position == 0) {
                return adSlotView == null ? TYPE_NORMAL : TYPE_ADSLOT;
            } else if (position == getItemCount() - 1 &amp;&amp; isLoading) {
                return bottomView == null ? TYPE_NORMAL : TYPE_BOTTOM;
            } else {
                return TYPE_NORMAL;
            }
        }
    }

    private class JCViewHolder extends RecyclerView.ViewHolder {

        public JCViewHolder(View itemView) {
            super(itemView);
        }
    }

    private void showToast(String msg) {
        Toast.makeText(getContext(),msg,Toast.LENGTH_SHORT).show();

    }

    public interface OnLoadMoreListener {
        void onLoadMore();
    }
}
</code></pre>
<p>200 多行代码，轻松实现 RecyclerView 刷新、加载以及异常状态的展示功能。</p>

          <br>
<p align="center">haohao</p>
<div class='date' align="center">2017-04-13</div>

        </section>
      </div>
      <div class='block'>
  
    <a class='main' href='/'>Home</a>
  
    <a class='main' href='/custom'>About</a>
  
    <a class='main' href='mailto:haohaochang86@gmail.com'>Email</a>
  
    <a class='main' href='https://github.com/githubhaohao'>Github</a>
  
</div>

    </div>
    <footer>
  <span class='muted'>&copy; 2017 Powered by haohao</span><br>
  <br>

</footer>

	<script type="text/javascript">
	  $(window).load(function(){
         $('pre').addClass('prettyprint').attr('style', 'overflow:auto;');
         prettyPrint();
      })
	  
	  $(".block .main").hover(function() {
          $(this).css({"background-color" : "#ddd"});
        },function() {
          $(this).css({"background-color" : "white"});
		});	
	</script>
  </body>
</html>
