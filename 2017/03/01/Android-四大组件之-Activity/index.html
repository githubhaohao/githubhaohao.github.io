<html>
  <head>
    <title>Android 四大组件之 Activity - haohao</title>
    <link href='/images/ic_small.png' rel='shortcut icon'>
<link href='/atom.xml' rel='alternate' type='application/rss+xml'>
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/highlight.css">
<link rel="stylesheet" href="/css/responsive.css">
<script src="/js/jquery.js"></script>
<script src="/js/basics.js"></script>
<meta content='width=device-width, initial-scale=1.0, user-scalable=no' name='viewport'>
<meta content='text/html; charset=utf-8' http-equiv='content-type'>


	<script src="/prettify/prettify.js" type="text/javascript"></script>
	<link rel="stylesheet" href="/themes/tomorrow-night-eighties.css" type="text/css">
  </head>
  <body>
    <header>
  <a id='go-back-home' href='/'><img src='/images/ic_middle.png' alt='Home' width='96' height='96'></a>
  <p>haohao</p>
  <p>不忘初心，不惧未来</p>
</header>

    <div id='container'>
      <div class='block'>
  
    <a class='main' href='/'>Home</a>
  
    <a class='main' href='/me'>About</a>
  
    <a class='main' href='mailto:haohaochang86@gmail.com'>Email</a>
  
    <a class='main' href='https://github.com/githubhaohao'>Github</a>
  
</div>

      <section class='paging'>
  
    <div class='left'>
      <a href='/2017/04/01/Android-jar-与-aar/'>
        ‹
      </a>
    </div>
  
  
    <div class='right'>
      <a href='/2017/02/17/Android主题切换和多主题实现/'>
        ›
      </a>
    </div>
  
</section>

      <div class='content'>
        <section class='post'>
          <h1>
            <div class='date'>2017-03-01</div>
            Android 四大组件之 Activity
          </h1>
          <p align="center"><img src="http://i2.buimg.com/588795/f44c5bdc30a8cc26.jpg" alt="Cover"></p>

<p align="center">唉！最近拖延症又犯了</p>

<blockquote>
<p>最近真的是越来越懒了，总是找各种理由不写博客。虽然最近各种事，又搞论文，又搞项目的，再拖下去实在是对不住 “不忘初心” 这一句话。惭愧！<br>虽然关于 Activity 已经被写烂了，但是从本篇文章里，你一定会发现不同的东西。</p>
</blockquote>
<h2 id="Activity-生命周期"><a href="#Activity-生命周期" class="headerlink" title="Activity 生命周期"></a>Activity 生命周期</h2><h3 id="一般情况下"><a href="#一般情况下" class="headerlink" title="一般情况下"></a>一般情况下</h3><p><img src="https://developer.android.com/images/activity_lifecycle.png" alt="haohaochang.cn"></p>
<pre><code class="java"> public class Activity extends ApplicationContext {
     protected void onCreate(Bundle savedInstanceState);

     protected void onStart();

     protected void onResume();

     protected void onPause();

     protected void onStop();

     protected void onDestroy();
 }
</code></pre>
<h3 id="异常情况下"><a href="#异常情况下" class="headerlink" title="异常情况下"></a>异常情况下</h3><h4 id="系统配置变化导致Activity销毁重建"><a href="#系统配置变化导致Activity销毁重建" class="headerlink" title="系统配置变化导致Activity销毁重建"></a>系统配置变化导致Activity销毁重建</h4><ol>
<li>旋转屏幕，Activity 销毁并重新创建，在异常情况下系统会在 onStop 之前调用 onSaveInstanceState 来保存状态。Activity 重新创建后，会在 onStart 之后调用 onRestoreInstanceState 恢复之前保存的数据。</li>
<li>系统只在 Activity 异常终止的时候才会调用 onSaveInstanceState 和 onRestoreInstanceState 方法。其他情况不会触发。</li>
</ol>
<h4 id="资源内存不足导致低优先级的-Activity-被回收"><a href="#资源内存不足导致低优先级的-Activity-被回收" class="headerlink" title="资源内存不足导致低优先级的 Activity 被回收"></a>资源内存不足导致低优先级的 Activity 被回收</h4><ol>
<li>前台- 可见非前台（被对话框遮挡的 Activity ）-后台，这三种 Activity 优先级从高到低。</li>
<li><code>android:configChanges=&quot;orientation&quot;</code> 在 manifest 中指定 configChanges 在系统配置变化后不重新创建 Activity，也不会执行onSaveInstanceState 和 onRestoreInstanceState 方法，而是调用 onConfigurationChnaged 方法。</li>
<li>configChanges 一般常用三个选项：<ul>
<li>locale <strong>系统语言变化</strong></li>
<li>keyborardHidden <strong>键盘的可访问性发生了变化，比如用户调出了键盘</strong></li>
<li>orientation <strong>屏幕方向变化</strong></li>
</ul>
</li>
</ol>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h4 id="首次启动-Activity"><a href="#首次启动-Activity" class="headerlink" title="首次启动 Activity"></a>首次启动 Activity</h4><pre><code>MainActivity onCreate
MainActivity onStart
MainActivity onResume
</code></pre><h4 id="跳转到-SecondActivity"><a href="#跳转到-SecondActivity" class="headerlink" title="跳转到 SecondActivity"></a>跳转到 SecondActivity</h4><pre><code>MainActivity onPause
SecondActivity onCreate
SecondActivity onStart
SecondActivity onResume
MainActivity onStop
</code></pre><h4 id="Back-返回-MainActivity"><a href="#Back-返回-MainActivity" class="headerlink" title="Back 返回 MainActivity"></a>Back 返回 MainActivity</h4><pre><code>SecondActivity onPause
MainActivity onRestart
MainActivity onStart
MainActivity onResume
SecondActivity onStop
SecondActivity onDestroy
</code></pre><h4 id="Home-回退桌面"><a href="#Home-回退桌面" class="headerlink" title="Home 回退桌面"></a>Home 回退桌面</h4><pre><code>MainActivity onPause
MainActivity onStop
</code></pre><h4 id="桌面返回可见"><a href="#桌面返回可见" class="headerlink" title="桌面返回可见"></a>桌面返回可见</h4><pre><code>MainActivity onRestart
MainActivity onStart
MainActivity onResume
</code></pre><h4 id="锁屏"><a href="#锁屏" class="headerlink" title="锁屏"></a>锁屏</h4><pre><code>MainActivity onPause
MainActivity onStop
</code></pre><h4 id="解锁屏"><a href="#解锁屏" class="headerlink" title="解锁屏"></a>解锁屏</h4><pre><code>MainActivity onRestart
MainActivity onStart
MainActivity onResume
</code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><blockquote><p>onStart 开始到 onStop 之前， Activity 可见。<br>onResume 开始到 onPause 之前， Activity 可接受用户交互。<br>在新Activity启动之前，栈顶的Activity需要先onPause后，新Activity才能启动。所以不能在onPause执行耗时操作。</p>
</blockquote>
<h2 id="Activity-数据传递"><a href="#Activity-数据传递" class="headerlink" title="Activity 数据传递"></a>Activity 数据传递</h2><p>Activity 传递数据一般有以下几种方式：</p>
<h3 id="Intent-传递数据"><a href="#Intent-传递数据" class="headerlink" title="Intent 传递数据"></a>Intent 传递数据</h3><p>MainActivity</p>
<pre><code class="java">Intent intent=new Intent();  
intent.setClass(MainActivity.this, OtherActivity.class);  
Bundle bundle = new Bundle();  
bundle.putString(KEY, VALUE);
intent.putExtras(bundle);  
startActivity（intent）;
</code></pre>
<p>OtherActivity</p>
<pre><code class="java">Intent intent = getIntent();  
Bundle bundle = intent.getEtras();  
String value = bundle.getString(KEY);
</code></pre>
<p>利用 Intent 对象在 Activity 之间传递数据是 Android 开发最常用的方式。<br>利用 Intent 对象可以传递基本数据类型，以及一些可序列化的对象。</p>
<h3 id="public-型的静态变量"><a href="#public-型的静态变量" class="headerlink" title="public 型的静态变量"></a>public 型的静态变量</h3><p>public 型的静态变量，在类被加载的时候，就被创建在静态存储区，不依赖于对象。</p>
<h3 id="Application-对象"><a href="#Application-对象" class="headerlink" title="Application 对象"></a>Application 对象</h3><p>在整个应用程序中就一个Application单例，它的生命周期贯穿整个程序，堆内存中只存在一个对象实例，所以程序内所有它的引用指向的是同一块堆内存，所以可以在不同activity对application实例变量进行值的存取。<br><em>不推荐</em>。</p>
<h3 id="Clipboard-剪切板"><a href="#Clipboard-剪切板" class="headerlink" title="Clipboard 剪切板"></a>Clipboard 剪切板</h3><p>ClipboardManager：该类是系统剪切板服务的接口，用来放入或取出全局剪切板中的文本。</p>
<pre><code class="java">ClipboardManager clipboardManager = (ClipboardManager)getSystemService(Context.CLIPBOARD_SERVICE);

clipboardManager.setText(DATA.toString());
}
</code></pre>
<pre><code class="java">ClipboardManager clipboardManager = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);  
String data = clipboardManager.getText().toString();
</code></pre>
<p>Clipboard 也可以传递可序列化对象。</p>
<h3 id="文件传值"><a href="#文件传值" class="headerlink" title="文件传值"></a>文件传值</h3><p>通过向本地文件写入和读取来传递数据。<br>常用的如 SharedPrefrences 对象等。</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>你自己想吧！</p>
<h2 id="Activity-启动模式"><a href="#Activity-启动模式" class="headerlink" title="Activity 启动模式"></a>Activity 启动模式</h2><p>启动模式,简单地说就是 Activity 启动时的策略，在AndroidManifest.xml 中的标签的 android:launchMode 属性设置；</p>
<p>启动模式有4种，分别为 <strong>standard、singleTop、singleTask、singleInstance；</strong></p>
<h3 id="standard-模式"><a href="#standard-模式" class="headerlink" title="standard 模式"></a>standard 模式</h3><p>每次 startActivity 时，都创建 Activity 实例，并放入任务栈，该任务栈中，可以有多个同类 Activity 的实例。</p>
<p><strong>应用场景</strong>：Your idea。</p>
<h3 id="singleTop-模式"><a href="#singleTop-模式" class="headerlink" title="singleTop 模式"></a>singleTop 模式</h3><p>栈顶不是该类型的 Activity，则创建一个新的 Activity。否则，回调该  Activity 实例的 onNewIntent 方法。</p>
<p><strong>应用场景</strong>：接收通知消息启动的页面。</p>
<p>例如，对于推送比较频繁的应用，如果收到多个推送，每次都打开一个页面显示内容是不妥的。</p>
<h3 id="singleTask-模式"><a href="#singleTask-模式" class="headerlink" title="singleTask 模式"></a>singleTask 模式</h3><p>任务栈中不存在启动 Activity 的实例，则创建 Activity 放入任务栈。<br>否则，回调该 Activity 的 onNewIntent 方法，并将该 Activity 置于栈顶，其以上的 Activity 都被弹出 (pop)。<strong>[onNewIntent + clearTop]</strong></p>
<p><strong>应用场景</strong>：作为应用的入口点。</p>
<p>例如，对于浏览器的主界面，不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走 onNewIntent ，并且会清空主界面上面的其他页面。</p>
<h3 id="singleInstance-模式"><a href="#singleInstance-模式" class="headerlink" title="singleInstance 模式"></a>singleInstance 模式</h3><p>回退栈中，只有这一个Activity，没有其他Activity。</p>
<p><strong>应用场景</strong>：闹铃的响铃界面。正在进行 QQ 聊天室时，闹铃响了，弹出一个对话形式的（以 SingleInstance 加载模式打开的）AlarmActivity，按了返回键之后回到 QQ 聊天界面，这是因为 Alarm Activity 所在的任务栈只有它一个元素， 因此退出之后这个任务栈空了。如果是以 SingleTask 打开 AlarmActivity，那么当闹铃响了的时候，按返回键应该进入闹铃设置界面。</p>

          <br>
<p align="center">haohao</p>
<div class='date' align="center">2017-03-01</div>

        </section>
      </div>
      <div class='block'>
  
    <a class='main' href='/'>Home</a>
  
    <a class='main' href='/me'>About</a>
  
    <a class='main' href='mailto:haohaochang86@gmail.com'>Email</a>
  
    <a class='main' href='https://github.com/githubhaohao'>Github</a>
  
</div>

    </div>
    <footer>
  <span class='muted'>&copy; 2017 Powered by haohao</span><br>
  <br>

</footer>

	<script type="text/javascript">
	  $(window).load(function(){
         $('pre').addClass('prettyprint').attr('style', 'overflow:auto;');
         prettyPrint();
      })
	  
	  $(".block .main").hover(function() {
          $(this).css({"background-color" : "#ddd"});
        },function() {
          $(this).css({"background-color" : "white"});
		});	
	</script>
  </body>
</html>
