<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[NDK 直播推流与引流]]></title>
      <url>%2F2018%2F02%2F10%2FNDK-live-streaming-push-and-pull%2F</url>
      <content type="text"><![CDATA[最好的年终奖是拥有随时可以跳槽的能力。 本篇介绍一下直播技术中推流与引流的简单实现。 本博客 NDK 开发系列文章： NDK 编译的三种方式 在 NDK 开发中引入第三方静态库和动态库 NDK 开发中 Native 与 Java 交互 NDK POSIX 多线程编程 NDK Android OpenSL ES 音频采集与播放 NDK FFmpeg 编译 NDK FFmpeg 音视频解码 NDK 直播流媒体服务器搭建 流媒体服务器测试首先利用快直播 app（其他支持 RTMP 推流与引流的 app 亦可）和 ffplay.exe 对流媒体服务器进行测试。 快直播的推流界面和引流界面 Windows 下利用 ffplay 进行引流，命令行执行：12ffplay rtmp://192.168.0.0/live/test # ip 地址换成流媒体服务器的地址， test 表示直播房间号 测试结果： 推流本文直播推流步骤： 使用 AudioRecord 采集音频，使用 Camera API 采集视频数据 分别使用 faac 和 xh264 第三方库在 Native 层对音频和视频进行编码 利用 rtmp-dump 第三方库进行打包和推流 工程目录： 主要的 JNI 方法：123456789101112131415161718192021222324252627282930313233343536373839public class NativePush &#123; public native void startPush(String url); public native void stopPush(); public native void release(); /** * 设置视频参数 * @param width * @param height * @param bitrate * @param fps */ public native void setVideoOptions(int width, int height, int bitrate, int fps); /** * 设置音频参数 * @param sampleRateInHz * @param channel */ public native void setAudioOptions(int sampleRateInHz, int channel); /** * 发送视频数据 * @param data */ public native void fireVideo(byte[] data); /** * 发送音频数据 * @param data * @param len */ public native void fireAudio(byte[] data, int len);&#125; 视频采集视频采集主要基于 Camera 相关 API ，利用 SurfaceView 进行预览，通过 PreviewCallback 获取相机预览数据。 视频预览主要代码实现：123456789101112131415161718192021222324252627282930public void startPreview()&#123; try &#123; mCamera = Camera.open(mVideoParams.getCameraId()); Camera.Parameters param = mCamera.getParameters(); List&lt;Camera.Size&gt; previewSizes = param.getSupportedPreviewSizes(); int length = previewSizes.size(); for (int i = 0; i &lt; length; i++) &#123; Log.i(TAG, "SupportedPreviewSizes : " + previewSizes.get(i).width + "x" + previewSizes.get(i).height); &#125; mVideoParams.setWidth(previewSizes.get(0).width); mVideoParams.setHeight(previewSizes.get(0).height); param.setPreviewFormat(ImageFormat.NV21); param.setPreviewSize(mVideoParams.getWidth(), mVideoParams.getHeight()); mCamera.setParameters(param); //mCamera.setDisplayOrientation(90); // 竖屏 mCamera.setPreviewDisplay(mSurfaceHolder); buffer = new byte[mVideoParams.getWidth() * mVideoParams.getHeight() * 4]; mCamera.addCallbackBuffer(buffer); mCamera.setPreviewCallbackWithBuffer(this); mCamera.startPreview(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 利用 FrameCallback 获取预览数据传入 Native 层，然后进行编码：1234567891011@Overridepublic void onPreviewFrame(byte[] bytes, Camera camera) &#123; if (mCamera != null) &#123; mCamera.addCallbackBuffer(buffer); &#125; if (mIsPushing) &#123; mNativePush.fireVideo(bytes); &#125;&#125; 音频采集音频采集基于 AudioRecord 实现，在一个子线程采集音频 PCM 数据，并将数据不断传入 Native 层进行编码。12345678910111213141516private class AudioRecordRunnable implements Runnable &#123; @Override public void run() &#123; mAudioRecord.startRecording(); while (mIsPushing) &#123; //通过AudioRecord不断读取音频数据 byte[] buffer = new byte[mMinBufferSize]; int length = mAudioRecord.read(buffer, 0, buffer.length); if (length &gt; 0) &#123; //传递给 Native 代码，进行音频编码 mNativePush.fireAudio(buffer, length); &#125; &#125; &#125;&#125; 编码和推流音视频数据编码和推流在 Native 层实现，首先添加 faac ， x264 ， librtmp 第三方库到 AS 工程，然后初始化相关设置，基于生产者与消费者模式，将编码后的音视频数据，在生产者线程中打包 RTMPPacket 放入双向链表，在消费者线程中从链表中取 RTMPPacket ，通过 RTMP_SendPacket 方法发送给服务器。 x264 初始化：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051JNIEXPORT void JNICALLJava_com_haohao_live_jni_NativePush_setVideoOptions(JNIEnv *env, jobject instance, jint width, jint height, jint bitRate, jint fps) &#123; x264_param_t param; //x264_param_default_preset 设置 x264_param_default_preset(&amp;param, "ultrafast", "zerolatency"); //编码输入的像素格式YUV420P param.i_csp = X264_CSP_I420; param.i_width = width; param.i_height = height; y_len = width * height; u_len = y_len / 4; v_len = u_len; //参数i_rc_method表示码率控制，CQP(恒定质量)，CRF(恒定码率)，ABR(平均码率) //恒定码率，会尽量控制在固定码率 param.rc.i_rc_method = X264_RC_CRF; param.rc.i_bitrate = bitRate / 1000; //* 码率(比特率,单位Kbps) param.rc.i_vbv_max_bitrate = bitRate / 1000 * 1.2; //瞬时最大码率 //码率控制不通过timebase和timestamp，而是fps param.b_vfr_input = 0; param.i_fps_num = fps; //* 帧率分子 param.i_fps_den = 1; //* 帧率分母 param.i_timebase_den = param.i_fps_num; param.i_timebase_num = param.i_fps_den; param.i_threads = 1;//并行编码线程数量，0默认为多线程 //是否把SPS和PPS放入每一个关键帧 //SPS Sequence Parameter Set 序列参数集，PPS Picture Parameter Set 图像参数集 //为了提高图像的纠错能力 param.b_repeat_headers = 1; //设置Level级别 param.i_level_idc = 51; //设置Profile档次 //baseline级别，没有B帧,只有 I 帧和 P 帧 x264_param_apply_profile(&amp;param, "baseline"); //x264_picture_t（输入图像）初始化 x264_picture_alloc(&amp;pic_in, param.i_csp, param.i_width, param.i_height); pic_in.i_pts = 0; //打开编码器 video_encode_handle = x264_encoder_open(&amp;param); if (video_encode_handle) &#123; LOGI("打开视频编码器成功"); &#125; else &#123; throwNativeError(env, INIT_FAILED); &#125;&#125; faac 初始化：123456789101112131415161718192021222324252627282930JNIEXPORT void JNICALLJava_com_haohao_live_jni_NativePush_setAudioOptions(JNIEnv *env, jobject instance, jint sampleRateInHz, jint channel) &#123; audio_encode_handle = faacEncOpen(sampleRateInHz, channel, &amp;nInputSamples, &amp;nMaxOutputBytes); if (!audio_encode_handle) &#123; LOGE("音频编码器打开失败"); return; &#125; //设置音频编码参数 faacEncConfigurationPtr p_config = faacEncGetCurrentConfiguration(audio_encode_handle); p_config-&gt;mpegVersion = MPEG4; p_config-&gt;allowMidside = 1; p_config-&gt;aacObjectType = LOW; p_config-&gt;outputFormat = 0; //输出是否包含ADTS头 p_config-&gt;useTns = 1; //时域噪音控制,大概就是消爆音 p_config-&gt;useLfe = 0;// p_config-&gt;inputFormat = FAAC_INPUT_16BIT; p_config-&gt;quantqual = 100; p_config-&gt;bandWidth = 0; //频宽 p_config-&gt;shortctl = SHORTCTL_NORMAL; if (!faacEncSetConfiguration(audio_encode_handle, p_config)) &#123; LOGE("%s", "音频编码器配置失败.."); throwNativeError(env, INIT_FAILED); return; &#125; LOGI("%s", "音频编码器配置成功");&#125; 对视频数据进行编码打包，通过 add_rtmp_packet 放入链表：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960JNIEXPORT void JNICALLJava_com_haohao_live_jni_NativePush_fireVideo(JNIEnv *env, jobject instance, jbyteArray buffer_) &#123; //视频数据转为YUV420P //NV21-&gt;YUV420P jbyte *nv21_buffer = (*env)-&gt;GetByteArrayElements(env, buffer_, NULL); jbyte *u = pic_in.img.plane[1]; jbyte *v = pic_in.img.plane[2]; //nv21 4:2:0 Formats, 12 Bits per Pixel //nv21与yuv420p，y个数一致，uv位置对调 //nv21转yuv420p y = w*h,u/v=w*h/4 //nv21 = yvu yuv420p=yuv y=y u=y+1+1 v=y+1 //如果要进行图像处理（美颜），可以再转换为RGB //还可以结合OpenCV识别人脸等等 memcpy(pic_in.img.plane[0], nv21_buffer, y_len); int i; for (i = 0; i &lt; u_len; i++) &#123; *(u + i) = *(nv21_buffer + y_len + i * 2 + 1); *(v + i) = *(nv21_buffer + y_len + i * 2); &#125; //h264编码得到NALU数组 x264_nal_t *nal = NULL; //NAL int n_nal = -1; //NALU的个数 //进行h264编码 if (x264_encoder_encode(video_encode_handle, &amp;nal, &amp;n_nal, &amp;pic_in, &amp;pic_out) &lt; 0) &#123; LOGE("%s", "编码失败"); return; &#125; //使用rtmp协议将h264编码的视频数据发送给流媒体服务器 //帧分为关键帧和普通帧，为了提高画面的纠错率，关键帧应包含SPS和PPS数据 int sps_len, pps_len; unsigned char sps[100]; unsigned char pps[100]; memset(sps, 0, 100); memset(pps, 0, 100); pic_in.i_pts += 1; //顺序累加 //遍历NALU数组，根据NALU的类型判断 for (i = 0; i &lt; n_nal; i++) &#123; if (nal[i].i_type == NAL_SPS) &#123; //复制SPS数据，序列参数集(Sequence parameter set) sps_len = nal[i].i_payload - 4; memcpy(sps, nal[i].p_payload + 4, sps_len); //不复制四字节起始码 &#125; else if (nal[i].i_type == NAL_PPS) &#123; //复制PPS数据，图像参数集（Picture parameter set） pps_len = nal[i].i_payload - 4; memcpy(pps, nal[i].p_payload + 4, pps_len); //不复制四字节起始码 //发送序列信息 //h264关键帧会包含SPS和PPS数据 add_264_sequence_header(pps, sps, pps_len, sps_len); &#125; else &#123; //发送帧信息 add_264_body(nal[i].p_payload, nal[i].i_payload); &#125; &#125; (*env)-&gt;ReleaseByteArrayElements(env, buffer_, nv21_buffer, 0);&#125; 同样，对音频数据进行编码打包放入链表：12345678910111213141516171819202122232425262728293031323334353637JNIEXPORT void JNICALLJava_com_haohao_live_jni_NativePush_fireAudio(JNIEnv *env, jobject instance, jbyteArray buffer_, jint length) &#123; int *pcmbuf; unsigned char *bitbuf; jbyte *b_buffer = (*env)-&gt;GetByteArrayElements(env, buffer_, 0); pcmbuf = (short *) malloc(nInputSamples * sizeof(int)); bitbuf = (unsigned char *) malloc(nMaxOutputBytes * sizeof(unsigned char)); int nByteCount = 0; unsigned int nBufferSize = (unsigned int) length / 2; unsigned short *buf = (unsigned short *) b_buffer; while (nByteCount &lt; nBufferSize) &#123; int audioLength = nInputSamples; if ((nByteCount + nInputSamples) &gt;= nBufferSize) &#123; audioLength = nBufferSize - nByteCount; &#125; int i; for (i = 0; i &lt; audioLength; i++) &#123;//每次从实时的pcm音频队列中读出量化位数为8的pcm数据。 int s = ((int16_t *) buf + nByteCount)[i]; pcmbuf[i] = s &lt;&lt; 8;//用8个二进制位来表示一个采样量化点（模数转换） &#125; nByteCount += nInputSamples; //利用FAAC进行编码，pcmbuf为转换后的pcm流数据，audioLength为调用faacEncOpen时得到的输入采样数，bitbuf为编码后的数据buff，nMaxOutputBytes为调用faacEncOpen时得到的最大输出字节数 int byteslen = faacEncEncode(audio_encode_handle, pcmbuf, audioLength, bitbuf, nMaxOutputBytes); if (byteslen &lt; 1) &#123; continue; &#125; add_aac_body(bitbuf, byteslen);//从bitbuf中得到编码后的aac数据流，放到数据队列 &#125; if (bitbuf) free(bitbuf); if (pcmbuf) free(pcmbuf); (*env)-&gt;ReleaseByteArrayElements(env, buffer_, b_buffer, 0);&#125; 消费者线程不断从链表中取 RTMPPacket 发送给服务器：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void *push_thread(void *arg) &#123; JNIEnv *env;//获取当前线程JNIEnv (*javaVM)-&gt;AttachCurrentThread(javaVM, &amp;env, NULL); //建立RTMP连接 RTMP *rtmp = RTMP_Alloc(); if (!rtmp) &#123; LOGE("rtmp初始化失败"); goto end; &#125; RTMP_Init(rtmp); rtmp-&gt;Link.timeout = 5; //连接超时的时间 //设置流媒体地址 RTMP_SetupURL(rtmp, rtmp_path); //发布rtmp数据流 RTMP_EnableWrite(rtmp); //建立连接 if (!RTMP_Connect(rtmp, NULL)) &#123; LOGE("%s", "RTMP 连接失败"); throwNativeError(env, CONNECT_FAILED); goto end; &#125; //计时 start_time = RTMP_GetTime(); if (!RTMP_ConnectStream(rtmp, 0)) &#123; //连接流 LOGE("%s", "RTMP ConnectStream failed"); throwNativeError(env, CONNECT_FAILED); goto end; &#125; is_pushing = TRUE; //发送AAC头信息 add_aac_sequence_header(); while (is_pushing) &#123; //发送 pthread_mutex_lock(&amp;mutex); pthread_cond_wait(&amp;cond, &amp;mutex); //取出队列中的RTMPPacket RTMPPacket *packet = queue_get_first(); if (packet) &#123; queue_delete_first(); //移除 packet-&gt;m_nInfoField2 = rtmp-&gt;m_stream_id; //RTMP协议，stream_id数据 int i = RTMP_SendPacket(rtmp, packet, TRUE); //TRUE放入librtmp队列中，并不是立即发送 if (!i) &#123; LOGE("RTMP 断开"); RTMPPacket_Free(packet); pthread_mutex_unlock(&amp;mutex); goto end; &#125; else &#123; LOGI("%s", "rtmp send packet"); &#125; RTMPPacket_Free(packet); &#125; pthread_mutex_unlock(&amp;mutex); &#125; end: LOGI("%s", "释放资源"); free(rtmp_path); RTMP_Close(rtmp); RTMP_Free(rtmp); (*javaVM)-&gt;DetachCurrentThread(javaVM); return 0;&#125; 引流这里引流就不做展开讲，可以通过 QLive 的 SDK 或者 vitamio （小楠总）等第三方库实现。 基于 vitamio 实现引流：1234567891011121314private void init()&#123; mVideoView = (VideoView) findViewById(R.id.live_player_view); mVideoView.setVideoPath(SPUtils.getInstance(this).getString(SPUtils.KEY_NGINX_SER_URI)); mVideoView.setMediaController(new MediaController(this)); mVideoView.requestFocus(); mVideoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener() &#123; @Override public void onPrepared(MediaPlayer mp) &#123; mp.setPlaybackSpeed(1.0f); &#125; &#125;);&#125; PS：源码地址：https://github.com/githubhaohao/NDKLive]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NDK 直播流媒体服务器搭建]]></title>
      <url>%2F2018%2F02%2F03%2FNDK-set-up-streaming-media-server%2F</url>
      <content type="text"><![CDATA[树立一个远大的目标是必要的，然而仅靠目标做动力，这种动力就是强迫式的，而有这种动力的人非常容易焦虑。 本篇介绍一下基于 Nginx 搭建一个非常简单的流媒体服务器。 本博客 NDK 开发系列文章： NDK 编译的三种方式 在 NDK 开发中引入第三方静态库和动态库 NDK 开发中 Native 与 Java 交互 NDK POSIX 多线程编程 NDK Android OpenSL ES 音频采集与播放 NDK FFmpeg 编译 NDK FFmpeg 音视频解码 NginxNginx 是由俄罗斯人 Igor Sysoev 编写的轻量级 Web 服务器，发音为 “engine x”，也可用作反向代理和负载均衡器，于 2004 年公开发布，遵循 BSD 开源许可，它以高稳定性、丰富的功能以及低系统开销而出名。Nginx 也是一种模块化的服务器，基于 Nginx 可以灵活添加各种功能模块，如 HTTP 模块、WebSocket 模块、RTMP 模块等，不同模块占用不同的端口，相互独立，如本文中要使用的 RTMP 模块默认端口为 1935 。 本文中的 Nginx 服务器只添加了一个 RTMP 模块，用作一个简单的流媒体服务器。 RTMP 协议RTMP （ Real Time Message Protocol ）协议是一种实时信息传输协议，由 Adobe 公司开发，用来解决多媒体数据传输流的多路复用（ Multiplexing ）和分包（ packetizing ）的问题，它是应用层协议，传输层通常基于 TCP 实现。RTMP 协议在前期并未受到太多的重视，近两年随着 VR 以及视频直播领域的火热，RTMP 协议正逐渐成为主流。 直播框架 搭建一个简易的直播框架需要三个角色：直播（推流）客户端，流媒体服务器和引流客户端。 安装 Nginx环境： Ubuntu 16.04 ，注意：若使用阿里云主机需要配置安全组规则，开放 80 、1935 等端口。 安装 nginx 和 nginx-rtmp 编译依赖工具:1sudo apt-get install build-essential libpcre3 libpcre3-dev libssl-dev 工作目录：123mkdir nginxchmod +x -R nginx/cd live 下载 nginx 和 nginx-rtmp 源码:12wget http://nginx.org/download/nginx-1.8.1.tar.gzwget https://github.com/arut/nginx-rtmp-module/archive/master.zip 解压：1234# 安装 unzip# sudo apt-get install unziptar -zxvf nginx-1.8.1.tar.gzunzip master.zip 添加 rtmp-nginx 模块:12cd nginx-1.8.1./configure --with-http_ssl_module --add-module=../nginx-rtmp-module-master 编译、安装：1234# 编译 nginx 源码make# 安装sudo make install 启动 Nginx 服务：12sudo service nginx start# sudo service nginx stop 停止 打开浏览器 http://127.0.0.1/ 或者输入阿里云主机的公网 ip : 安装 FFmpeg：123sudo apt-get install ffmpeg# 查看版本信息ffmpeg -v 配置 nginx 服务器：1234567891011121314151617181920# 进入 nginx 安装目录cd /usr/local/nginx# 修改配置文件 /usr/local/nginx/conf/nginx.conf# 在配置文件中添加以下代码rtmp &#123; server &#123; listen 1935; chunk_size 4096; application live &#123; live on; record off; exec ffmpeg -i rtmp://localhost/live/$name -threads 1 -c:v libx264 -profile:v baseline -b:v 350K -s 640x360 -f flv -c:a aac -ac 1 -strict -2 -b:a 56k rtmp://localhost/live360p/$name; &#125; application live360p &#123; live on; record off; &#125; &#125;&#125; 重启 nginx 服务器：1sudo service nginx restart 到目前为止，一个简单的流媒体服务器搭建完成，接下来将实现服务器与客户端之间的推流和引流。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NDK FFmpeg 音视频解码]]></title>
      <url>%2F2018%2F01%2F24%2FNDK-FFmpeg-video-decoding%2F</url>
      <content type="text"><![CDATA[诸葛亮躬耕隆中的时候，与好友石广元、徐庶、孟公威在一起求学，其他三人读书都是一定要滚瓜烂熟，只有诸葛亮只观其大略。 本篇介绍一下 FFmpeg 音视频解码。 本博客 NDK 开发系列文章： NDK 编译的三种方式 在 NDK 开发中引入第三方静态库和动态库 NDK 开发中 Native 与 Java 交互 NDK POSIX 多线程编程 NDK Android OpenSL ES 音频采集与播放 NDK FFmpeg 编译 封装格式我们经常所说的视频格式，如 mp4 、 mkv 、 rmvb 、flv 等，表示的是音视频的封装格式，封装格式实质上是把音频数据、视频数据和字幕数据打包成一个文件的规范。从技术的角度来讲，优秀的音视频封装格式应该支持大多数音视频编码标准。主要的封装格式: 名称 机构 支持的视频编码 支持的音频编码 使用领域 AVI 微软 几乎所有格式 几乎所有格式 BT 下载影视 MP4 MPEG MPEG-4 ， H.264 ， H.263 等 AAC ， MPEG-1 等 互联网视频网站 FLV Adobe VP6 ， H.264 MP3 ， AAC 等 互联网视频网站 MKV CoreCodec 几乎所有格式 几乎所有格式 互联网视频网站 RMVB Real Networks RealVideo 8 ， 9 ， 10 AAC ， Cook Codec BT 下载影视 编码格式编码的目的在于通过压缩算法降低数据量，提高数据的存储和传输效率。视频编码是将视频像素数据（ RGB ， YUV 等）压缩成为视频码流。音频编码是将音频采样数据（ PCM 等）压缩成为音频码流。主要视频编码格式： 名称 机构 推出时间 使用领域 H.265 MPEG/ITU-T 2013 研发中 H.264 MPEG/ITU-T 2003 各个领域 MPEG4 MPEG 2001 小众 MPEG2 MPEG 1994 数字电视 VP9 Google 2013 研发中 VP8 Google 2008 小众 主要音频编码格式： 名称 机构 推出时间 使用领域 AAC MPEG 1997 各个领域 AC-3 Dolby 1992 电影 MP3 MPEG 1993 早期普及 WMV 微软 1999 Windows 音视频解码流程 解封装格式。将输入的按照一定格式封装的音视频数据，分离成为音频流压缩编码数据和视频流压缩编码数据。 解码。将视频和音频的压缩编码数据，解码成为非压缩的视频和音频原始数据。视频压缩数据通过解码输出为像素数据，如 YUV420P 、 RGB 等；音频压缩数据通过解码输出为非压缩的音频抽样数据，如 PCM 数据。 音视频同步。同步解码出来的视频和音频数据，并将音视频数据送至系统的声卡和显卡，播放和显示出来。 FFmpeg 函数库FFmpeg 一般有 8 个函数库，各个函数库的功能如下： 函数库 功能 avcodec 音视频编解码 avdevice 多媒体设备输入输出 avfilter 滤镜特效 avformat 封装格式处理 postproc 后加工 avutil 工具库 swresample 音频采样数据格式转换 swscale 视频像素数据格式转换 FFmpeg 音视频解码FFmpeg 音视频解码主要流程代码描述：1234561. av_register_all() //注册组件2. avformat_alloc_context //获取封装格式上下文3. avformat_find_stream_info //获取输入文件信息4. avcodec_find_decoder //获取解码器5. avcodec_open2 //打开解码器6. avcodec_decode_video2 或 avcodec_decode_audio4 //解码音视频帧 在 AS 工程中引入 FFmpeg 8 个动态库和 libyuv （负责视频像素数据格式转换）动态库。工程的头文件目录：工程的动态库目录： Java 层 API ：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.haohao.ffmpeg;import android.media.AudioFormat;import android.media.AudioManager;import android.media.AudioTrack;import android.util.Log;import android.view.Surface;/** * author: haohao * time: 2017/12/19 * mail: haohaochang86@gmail.com * desc: AVUtils */public class AVUtils &#123; private static final String TAG = "AVUtils"; private static AVCallback AVCallback; private static AVCallback sAVCallback; public static void registerCallback(AVCallback callback) &#123; sAVCallback = callback; &#125; static &#123; System.loadLibrary("avfilter-5"); System.loadLibrary("avdevice-56"); System.loadLibrary("yuv"); System.loadLibrary("avutil-54"); System.loadLibrary("swresample-1"); System.loadLibrary("avcodec-56"); System.loadLibrary("avformat-56"); System.loadLibrary("swscale-3"); System.loadLibrary("postproc-53"); System.loadLibrary("native-lib"); &#125; /** * 解码视频中的视频压缩数据 * @param input_file_path 输入的视频文件路径 * @param output_file_path 视频压缩数据解码后输出的 YUV 文件路径 */ public static native void videoDecode(String input_file_path, String output_file_path); /** * 显示视频视频解码后像素数据 * @param input 输入的视频文件路径 * @param surface 用于显示视频视频解码后的 RGBA 像素数据 */ public static native void videoRender(String input, Surface surface); /** * 解码视频中的音频压缩数据 * @param input 输入的视频文件路径 * @param output 音频压缩数据解码后输出的 PCM 文件路径 */ public static native void audioDecode(String input, String output); /** * 播放视频中的音频数据 * @param input 输入的视频文件路径 */ public static native void audioPlay(String input); /** * 创建一个 AudioTrack 对象，用于播放音频,在 Native 层中调用。 */ public static AudioTrack createAudioTrack(int sampleRate, int num_channel) &#123; int audioFormat = AudioFormat.ENCODING_PCM_16BIT; Log.i(TAG, "声道数:" + num_channel); int channelConfig; if (num_channel == 1) &#123; channelConfig = android.media.AudioFormat.CHANNEL_OUT_MONO; &#125; else if (num_channel == 2) &#123; channelConfig = android.media.AudioFormat.CHANNEL_OUT_STEREO; &#125; else &#123; channelConfig = android.media.AudioFormat.CHANNEL_OUT_STEREO; &#125; int bufferSize = AudioTrack.getMinBufferSize(sampleRate, channelConfig, audioFormat); AudioTrack audioTrack = new AudioTrack( AudioManager.STREAM_MUSIC, sampleRate, channelConfig, audioFormat, bufferSize, AudioTrack.MODE_STREAM); return audioTrack; &#125; public interface AVCallback &#123; void onFinish(); &#125;&#125; MySurfaceView.java 12345678910111213141516171819202122232425/** * author: haohao * time: 2017/12/20 * mail: haohaochang86@gmail.com * desc: MySurfaceView */public class MySurfaceView extends SurfaceView &#123; public MySurfaceView(Context context) &#123; super(context); &#125; public MySurfaceView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public MySurfaceView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; private void init()&#123; // 设置像素绘制格式为 RGBA_8888 SurfaceHolder holder = getHolder(); holder.setFormat(PixelFormat.RGBA_8888); &#125;&#125; activity_main.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;com.haohao.ffmpeg.MySurfaceView android:id="@+id/my_surface_view" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:alpha="0.7" android:orientation="horizontal"&gt; &lt;Button android:id="@+id/video_decode_btn" android:layout_width="0dp" android:layout_weight="1" android:layout_height="wrap_content" android:text="视频解码" /&gt; &lt;Button android:id="@+id/video_render_btn" android:layout_width="0dp" android:layout_weight="1" android:layout_height="wrap_content" android:text="视频渲染" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:alpha="0.7" android:orientation="horizontal"&gt; &lt;Button android:id="@+id/audio_decode_btn" android:layout_width="0dp" android:layout_weight="1" android:layout_height="wrap_content" android:text="音频解码" /&gt; &lt;Button android:id="@+id/audio_play_btn" android:layout_width="0dp" android:layout_weight="1" android:layout_height="wrap_content" android:text="音频播放" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/FrameLayout&gt; MainActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class MainActivity extends AppCompatActivity implements View.OnClickListener, AVUtils.AVCallback &#123; private static final String TAG = "MainActivity"; private static final String BASE_PATH = Environment.getExternalStorageDirectory().getAbsolutePath() + File.separatorChar; private String input_video_file_path = BASE_PATH + "input.mp4"; private String output_video_file_path = BASE_PATH + "output.yuv"; private String input_audio_file_path = BASE_PATH + "hello.mp3"; private String output_audio_file_path = BASE_PATH + "hello.pcm"; private String video_src = BASE_PATH + "ffmpeg.mp4"; private Button mDecodeVideoBtn; private Button mVideoRenderBtn; private Button mAudioPlayBtn, mAudioDecodeBtn; private ProgressDialog mProgressDialog; private ExecutorService mExecutorService; private MySurfaceView mySurfaceView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; requestPermissions(new String[]&#123;Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.MOUNT_UNMOUNT_FILESYSTEMS&#125;, 0); &#125; mDecodeVideoBtn = (Button)findViewById(R.id.video_decode_btn); mVideoRenderBtn = (Button)findViewById(R.id.video_render_btn); mAudioDecodeBtn = (Button) findViewById(R.id.audio_decode_btn); mAudioPlayBtn = (Button)findViewById(R.id.audio_play_btn); mySurfaceView = (MySurfaceView) findViewById(R.id.my_surface_view); mDecodeVideoBtn.setOnClickListener(this); mVideoRenderBtn.setOnClickListener(this); mAudioDecodeBtn.setOnClickListener(this); mAudioPlayBtn.setOnClickListener(this); AVUtils.registerCallback(this); mProgressDialog = new ProgressDialog(this); mProgressDialog.setCanceledOnTouchOutside(false); mExecutorService = Executors.newFixedThreadPool(2); &#125; @Override public void onClick(View view) &#123; int id = view.getId(); switch (id) &#123; case R.id.video_decode_btn: mProgressDialog.setMessage("正在解码..."); mProgressDialog.show(); mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; AVUtils.videoDecode(input_video_file_path, output_video_file_path); &#125; &#125;); break; case R.id.video_render_btn: mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; AVUtils.videoRender(input_video_file_path, mySurfaceView.getHolder().getSurface()); &#125; &#125;); break; case R.id.audio_decode_btn: mProgressDialog.setMessage("正在解码..."); mProgressDialog.show(); mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; AVUtils.audioDecode(input_audio_file_path, output_audio_file_path); &#125; &#125;); break; case R.id.audio_play_btn: mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; AVUtils.audioPlay(input_video_file_path); &#125; &#125;); break; &#125; &#125; @Override public void onFinish() &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; if (mProgressDialog.isShowing()) &#123; mProgressDialog.dismiss(); &#125; Toast.makeText(MainActivity.this, "解码完成", Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); mExecutorService.shutdown(); &#125;&#125; nativelib.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579#include &lt;jni.h&gt;#include &lt;string.h&gt;#include &lt;android/log.h&gt;#include &lt;stdio.h&gt;#include &lt;libavutil/time.h&gt;//编码#include "include/libavcodec/avcodec.h"//封装格式处理#include "include/libavformat/avformat.h"//像素处理#include "include/libswscale/swscale.h"#define LOGI(FORMAT, ...) __android_log_print(ANDROID_LOG_INFO,"haohao",FORMAT,##__VA_ARGS__);#define LOGE(FORMAT, ...) __android_log_print(ANDROID_LOG_ERROR,"haohao",FORMAT,##__VA_ARGS__);//中文字符串转换jstring charsToUTF8String(JNIEnv *env, char *s) &#123; jclass string_cls = (*env)-&gt;FindClass(env, "java/lang/String"); jmethodID mid = (*env)-&gt;GetMethodID(env, string_cls, "&lt;init&gt;", "([BLjava/lang/String;)V"); jbyteArray jb_arr = (*env)-&gt;NewByteArray(env, strlen(s)); (*env)-&gt;SetByteArrayRegion(env, jb_arr, 0, strlen(s), s); jstring charset = (*env)-&gt;NewStringUTF(env, "UTF-8"); return (*env)-&gt;NewObject(env, string_cls, mid, jb_arr, charset);&#125;JNIEXPORT void JNICALLJava_com_haohao_ffmpeg_AVUtils_videoDecode(JNIEnv *env, jclass type, jstring input_, jstring output_) &#123; //访问静态方法 jmethodID mid = (*env)-&gt;GetStaticMethodID(env, type, "onNativeCallback", "()V"); //需要转码的视频文件(输入的视频文件) const char *input = (*env)-&gt;GetStringUTFChars(env, input_, 0); const char *output = (*env)-&gt;GetStringUTFChars(env, output_, 0); //注册所有组件 av_register_all(); //封装格式上下文，统领全局的结构体，保存了视频文件封装格式的相关信息 AVFormatContext *pFormatCtx = avformat_alloc_context(); //打开输入视频文件 if (avformat_open_input(&amp;pFormatCtx, input, NULL, NULL) != 0) &#123; LOGE("%s", "无法打开输入视频文件"); return; &#125; //获取视频文件信息，例如得到视频的宽高 if (avformat_find_stream_info(pFormatCtx, NULL) &lt; 0) &#123; LOGE("%s", "无法获取视频文件信息"); return; &#125; //获取视频流的索引位置 //遍历所有类型的流（音频流、视频流、字幕流），找到视频流 int v_stream_idx = -1; int i = 0; for (; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123; //判断视频流 if (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123; v_stream_idx = i; break; &#125; &#125; if (v_stream_idx == -1) &#123; LOGE("%s", "找不到视频流\n"); return; &#125; //根据视频的编码方式，获取对应的解码器 AVCodecContext *pCodecCtx = pFormatCtx-&gt;streams[v_stream_idx]-&gt;codec; //根据编解码上下文中的编码 id 查找对应的解码器 AVCodec *pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id); if (pCodec == NULL) &#123; LOGE("%s", "找不到解码器，或者视频已加密\n"); return; &#125; //打开解码器，解码器有问题（比如说我们编译FFmpeg的时候没有编译对应类型的解码器） if (avcodec_open2(pCodecCtx, pCodec, NULL) &lt; 0) &#123; LOGE("%s", "解码器无法打开\n"); return; &#125; //输出视频信息 LOGI("视频的文件格式：%s", pFormatCtx-&gt;iformat-&gt;name); LOGI("视频时长：%lld", (pFormatCtx-&gt;duration) / (1000 * 1000)); LOGI("视频的宽高：%d,%d", pCodecCtx-&gt;width, pCodecCtx-&gt;height); LOGI("解码器的名称：%s", pCodec-&gt;name); //准备读取 //AVPacket用于存储一帧一帧的压缩数据（H264） //缓冲区，开辟空间 AVPacket *packet = (AVPacket *) av_malloc(sizeof(AVPacket)); //AVFrame用于存储解码后的像素数据(YUV) //内存分配 AVFrame *pFrame = av_frame_alloc(); //YUV420 AVFrame *pFrameYUV = av_frame_alloc(); //只有指定了AVFrame的像素格式、画面大小才能真正分配内存 //缓冲区分配内存 uint8_t *out_buffer = (uint8_t *) av_malloc( avpicture_get_size(AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height)); //初始化缓冲区 avpicture_fill((AVPicture *) pFrameYUV, out_buffer, AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height); //用于转码（缩放）的参数，转之前的宽高，转之后的宽高，格式等 struct SwsContext *sws_ctx = sws_getContext(pCodecCtx-&gt;width, pCodecCtx-&gt;height, pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height, AV_PIX_FMT_YUV420P, SWS_BICUBIC, NULL, NULL, NULL); int got_picture, ret; //输出文件 FILE *fp_yuv = fopen(output, "wb+"); int frame_count = 0; //一帧一帧的读取压缩数据 while (av_read_frame(pFormatCtx, packet) &gt;= 0) &#123; //只要视频压缩数据（根据流的索引位置判断） if (packet-&gt;stream_index == v_stream_idx) &#123; //解码一帧视频压缩数据，得到视频像素数据 ret = avcodec_decode_video2(pCodecCtx, pFrame, &amp;got_picture, packet); if (ret &lt; 0) &#123; LOGE("%s", "解码错误"); return; &#125; //为 0 说明解码完成，非0正在解码 if (got_picture) &#123; //AVFrame转为像素格式YUV420，宽高 //2 6输入、输出数据 //3 7输入、输出画面一行的数据的大小 AVFrame 转换是一行一行转换的 //4 输入数据第一列要转码的位置 从0开始 //5 输入画面的高度 sws_scale(sws_ctx, pFrame-&gt;data, pFrame-&gt;linesize, 0, pCodecCtx-&gt;height, pFrameYUV-&gt;data, pFrameYUV-&gt;linesize); //输出到YUV文件 //AVFrame像素帧写入文件 //data解码后的图像像素数据（音频采样数据） //Y 亮度 UV 色度（压缩了） 人对亮度更加敏感 //U V 个数是Y的1/4 int y_size = pCodecCtx-&gt;width * pCodecCtx-&gt;height; fwrite(pFrameYUV-&gt;data[0], 1, y_size, fp_yuv); fwrite(pFrameYUV-&gt;data[1], 1, y_size / 4, fp_yuv); fwrite(pFrameYUV-&gt;data[2], 1, y_size / 4, fp_yuv); frame_count++; LOGI("解码第%d帧", frame_count); &#125; &#125; //释放资源 av_free_packet(packet); &#125; fclose(fp_yuv); av_frame_free(&amp;pFrame); avcodec_close(pCodecCtx); avformat_free_context(pFormatCtx); (*env)-&gt;ReleaseStringUTFChars(env, input_, input); (*env)-&gt;ReleaseStringUTFChars(env, output_, output); //通知 Java 层解码完毕 (*env)-&gt;CallStaticVoidMethod(env, type, mid);&#125;//使用这两个 Window 相关的头文件需要在 CMake 脚本中引入 android 库#include &lt;android/native_window_jni.h&gt;#include &lt;android/native_window.h&gt;#include "include/yuv/libyuv.h"JNIEXPORT void JNICALLJava_com_haohao_ffmpeg_AVUtils_videoRender(JNIEnv *env, jclass type, jstring input_, jobject surface) &#123; //需要转码的视频文件(输入的视频文件) const char *input = (*env)-&gt;GetStringUTFChars(env, input_, 0); //注册所有组件 av_register_all(); //avcodec_register_all(); //封装格式上下文，统领全局的结构体，保存了视频文件封装格式的相关信息 AVFormatContext *pFormatCtx = avformat_alloc_context(); //打开输入视频文件 if (avformat_open_input(&amp;pFormatCtx, input, NULL, NULL) != 0) &#123; LOGE("%s", "无法打开输入视频文件"); return; &#125; //获取视频文件信息，例如得到视频的宽高 //第二个参数是一个字典，表示你需要获取什么信息，比如视频的元数据 if (avformat_find_stream_info(pFormatCtx, NULL) &lt; 0) &#123; LOGE("%s", "无法获取视频文件信息"); return; &#125; //获取视频流的索引位置 //遍历所有类型的流（音频流、视频流、字幕流），找到视频流 int v_stream_idx = -1; int i = 0; //number of streams for (; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123; //流的类型 if (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123; v_stream_idx = i; break; &#125; &#125; if (v_stream_idx == -1) &#123; LOGE("%s", "找不到视频流\n"); return; &#125; //获取视频流中的编解码上下文 AVCodecContext *pCodecCtx = pFormatCtx-&gt;streams[v_stream_idx]-&gt;codec; //根据编解码上下文中的编码 id 查找对应的解码器 AVCodec *pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id); if (pCodec == NULL) &#123; LOGE("%s", "找不到解码器，或者视频已加密\n"); return; &#125; //打开解码器，解码器有问题（比如说我们编译FFmpeg的时候没有编译对应类型的解码器） if (avcodec_open2(pCodecCtx, pCodec, NULL) &lt; 0) &#123; LOGE("%s", "解码器无法打开\n"); return; &#125; //准备读取 //AVPacket用于存储一帧一帧的压缩数据（H264） //缓冲区，开辟空间 AVPacket *packet = (AVPacket *) av_malloc(sizeof(AVPacket)); //AVFrame用于存储解码后的像素数据(YUV) //内存分配 AVFrame *yuv_frame = av_frame_alloc(); AVFrame *rgb_frame = av_frame_alloc(); int got_picture, ret; int frame_count = 0; //窗体 ANativeWindow *pWindow = ANativeWindow_fromSurface(env, surface); //绘制时的缓冲区 ANativeWindow_Buffer out_buffer; //一帧一帧的读取压缩数据 while (av_read_frame(pFormatCtx, packet) &gt;= 0) &#123; //只要视频压缩数据（根据流的索引位置判断） if (packet-&gt;stream_index == v_stream_idx) &#123; //7.解码一帧视频压缩数据，得到视频像素数据 ret = avcodec_decode_video2(pCodecCtx, yuv_frame, &amp;got_picture, packet); if (ret &lt; 0) &#123; LOGE("%s", "解码错误"); return; &#125; //为0说明解码完成，非0正在解码 if (got_picture) &#123; //lock window //设置缓冲区的属性：宽高、像素格式（需要与Java层的格式一致） ANativeWindow_setBuffersGeometry(pWindow, pCodecCtx-&gt;width, pCodecCtx-&gt;height, WINDOW_FORMAT_RGBA_8888); ANativeWindow_lock(pWindow, &amp;out_buffer, NULL); //初始化缓冲区 //设置属性，像素格式、宽高 //rgb_frame的缓冲区就是Window的缓冲区，同一个，解锁的时候就会进行绘制 avpicture_fill((AVPicture *) rgb_frame, out_buffer.bits, AV_PIX_FMT_RGBA, pCodecCtx-&gt;width, pCodecCtx-&gt;height); //YUV格式的数据转换成RGBA 8888格式的数据, FFmpeg 也可以转换，但是存在问题，使用libyuv这个库实现 I420ToARGB(yuv_frame-&gt;data[0], yuv_frame-&gt;linesize[0], yuv_frame-&gt;data[2], yuv_frame-&gt;linesize[2], yuv_frame-&gt;data[1], yuv_frame-&gt;linesize[1], rgb_frame-&gt;data[0], rgb_frame-&gt;linesize[0], pCodecCtx-&gt;width, pCodecCtx-&gt;height); //3、unlock window ANativeWindow_unlockAndPost(pWindow); frame_count++; LOGI("解码绘制第%d帧", frame_count); &#125; &#125; //释放资源 av_free_packet(packet); &#125; av_frame_free(&amp;yuv_frame); avcodec_close(pCodecCtx); avformat_free_context(pFormatCtx); (*env)-&gt;ReleaseStringUTFChars(env, input_, input);&#125;#include "libswresample/swresample.h"#define MAX_AUDIO_FRME_SIZE 48000 * 4//音频解码（重采样）JNIEXPORT void JNICALLJava_com_haohao_ffmpeg_AVUtils_audioDecode(JNIEnv *env, jclass type, jstring input_, jstring output_) &#123; //访问静态方法 jmethodID mid = (*env)-&gt;GetStaticMethodID(env, type, "onNativeCallback", "()V"); const char *input = (*env)-&gt;GetStringUTFChars(env, input_, 0); const char *output = (*env)-&gt;GetStringUTFChars(env, output_, 0); //注册组件 av_register_all(); AVFormatContext *pFormatCtx = avformat_alloc_context(); //打开音频文件 if (avformat_open_input(&amp;pFormatCtx, input, NULL, NULL) != 0) &#123; LOGI("%s", "无法打开音频文件"); return; &#125; //获取输入文件信息 if (avformat_find_stream_info(pFormatCtx, NULL) &lt; 0) &#123; LOGI("%s", "无法获取输入文件信息"); return; &#125; //获取音频流索引位置 int i = 0, audio_stream_idx = -1; for (; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123; if (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123; audio_stream_idx = i; break; &#125; &#125; //获取解码器 AVCodecContext *codecCtx = pFormatCtx-&gt;streams[audio_stream_idx]-&gt;codec; AVCodec *codec = avcodec_find_decoder(codecCtx-&gt;codec_id); if (codec == NULL) &#123; LOGI("%s", "无法获取解码器"); return; &#125; //打开解码器 if (avcodec_open2(codecCtx, codec, NULL) &lt; 0) &#123; LOGI("%s", "无法打开解码器"); return; &#125; //压缩数据 AVPacket *packet = (AVPacket *) av_malloc(sizeof(AVPacket)); //解压缩数据 AVFrame *frame = av_frame_alloc(); //frame-&gt;16bit 44100 PCM 统一音频采样格式与采样率 SwrContext *swrCtx = swr_alloc(); //重采样设置参数 //输入的采样格式 enum AVSampleFormat in_sample_fmt = codecCtx-&gt;sample_fmt; //输出采样格式16bit PCM enum AVSampleFormat out_sample_fmt = AV_SAMPLE_FMT_S16; //输入采样率 int in_sample_rate = codecCtx-&gt;sample_rate; //输出采样率 int out_sample_rate = 44100; //获取输入的声道布局 //根据声道个数获取默认的声道布局（2个声道，默认立体声stereo） //av_get_default_channel_layout(codecCtx-&gt;channels); uint64_t in_ch_layout = codecCtx-&gt;channel_layout; //输出的声道布局（立体声） uint64_t out_ch_layout = AV_CH_LAYOUT_STEREO; swr_alloc_set_opts(swrCtx, out_ch_layout, out_sample_fmt, out_sample_rate, in_ch_layout, in_sample_fmt, in_sample_rate, 0, NULL); swr_init(swrCtx); //输出的声道个数 int out_channel_nb = av_get_channel_layout_nb_channels(out_ch_layout); //重采样设置参数 //位宽16bit 采样率 44100HZ 的 PCM 数据 uint8_t *out_buffer = (uint8_t *) av_malloc(MAX_AUDIO_FRME_SIZE); FILE *fp_pcm = fopen(output, "wb"); int got_frame = 0, index = 0, ret; //不断读取压缩数据 while (av_read_frame(pFormatCtx, packet) &gt;= 0) &#123; //解码 ret = avcodec_decode_audio4(codecCtx, frame, &amp;got_frame, packet); if (ret &lt; 0) &#123; LOGI("%s", "解码完成"); &#125; //解码一帧成功 if (got_frame &gt; 0) &#123; LOGI("解码：%d", index++); swr_convert(swrCtx, &amp;out_buffer, MAX_AUDIO_FRME_SIZE, frame-&gt;data, frame-&gt;nb_samples); //获取sample的size int out_buffer_size = av_samples_get_buffer_size(NULL, out_channel_nb, frame-&gt;nb_samples, out_sample_fmt, 1); fwrite(out_buffer, 1, out_buffer_size, fp_pcm); &#125; av_free_packet(packet); &#125; fclose(fp_pcm); av_frame_free(&amp;frame); av_free(out_buffer); swr_free(&amp;swrCtx); avcodec_close(codecCtx); avformat_close_input(&amp;pFormatCtx); (*env)-&gt;ReleaseStringUTFChars(env, input_, input); (*env)-&gt;ReleaseStringUTFChars(env, output_, output); //通知 Java 层解码完成 (*env)-&gt;CallStaticVoidMethod(env, type, mid);&#125;JNIEXPORT void JNICALLJava_com_haohao_ffmpeg_AVUtils_audioPlay(JNIEnv *env, jclass type, jstring input_) &#123; const char *input = (*env)-&gt;GetStringUTFChars(env, input_, 0); LOGI("%s", "sound"); //注册组件 av_register_all(); AVFormatContext *pFormatCtx = avformat_alloc_context(); //打开音频文件 if (avformat_open_input(&amp;pFormatCtx, input, NULL, NULL) != 0) &#123; LOGI("%s", "无法打开音频文件"); return; &#125; //获取输入文件信息 if (avformat_find_stream_info(pFormatCtx, NULL) &lt; 0) &#123; LOGI("%s", "无法获取输入文件信息"); return; &#125; //获取音频流索引位置 int i = 0, audio_stream_idx = -1; for (; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123; if (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123; audio_stream_idx = i; break; &#125; &#125; //获取解码器 AVCodecContext *codecCtx = pFormatCtx-&gt;streams[audio_stream_idx]-&gt;codec; AVCodec *codec = avcodec_find_decoder(codecCtx-&gt;codec_id); if (codec == NULL) &#123; LOGI("%s", "无法获取解码器"); return; &#125; //打开解码器 if (avcodec_open2(codecCtx, codec, NULL) &lt; 0) &#123; LOGI("%s", "无法打开解码器"); return; &#125; //压缩数据 AVPacket *packet = (AVPacket *) av_malloc(sizeof(AVPacket)); //解压缩数据 AVFrame *frame = av_frame_alloc(); //frame-&gt;16bit 44100 PCM 统一音频采样格式与采样率 SwrContext *swrCtx = swr_alloc(); //输入的采样格式 enum AVSampleFormat in_sample_fmt = codecCtx-&gt;sample_fmt; //输出采样格式16bit PCM enum AVSampleFormat out_sample_fmt = AV_SAMPLE_FMT_S16; //输入采样率 int in_sample_rate = codecCtx-&gt;sample_rate; //输出采样率 int out_sample_rate = in_sample_rate; //获取输入的声道布局 //根据声道个数获取默认的声道布局（2个声道，默认立体声stereo） //av_get_default_channel_layout(codecCtx-&gt;channels); uint64_t in_ch_layout = codecCtx-&gt;channel_layout; //输出的声道布局（立体声） uint64_t out_ch_layout = AV_CH_LAYOUT_STEREO; swr_alloc_set_opts(swrCtx, out_ch_layout, out_sample_fmt, out_sample_rate, in_ch_layout, in_sample_fmt, in_sample_rate, 0, NULL); swr_init(swrCtx); //输出的声道个数 int out_channel_nb = av_get_channel_layout_nb_channels(out_ch_layout); //AudioTrack对象 jmethodID create_audio_track_mid = (*env)-&gt;GetStaticMethodID(env, type, "createAudioTrack", "(II)Landroid/media/AudioTrack;"); jobject audio_track = (*env)-&gt;CallStaticObjectMethod(env, type, create_audio_track_mid, out_sample_rate, out_channel_nb); //调用AudioTrack.play方法 jclass audio_track_class = (*env)-&gt;GetObjectClass(env, audio_track); jmethodID audio_track_play_mid = (*env)-&gt;GetMethodID(env, audio_track_class, "play", "()V"); jmethodID audio_track_stop_mid = (*env)-&gt;GetMethodID(env, audio_track_class, "stop", "()V"); (*env)-&gt;CallVoidMethod(env, audio_track, audio_track_play_mid); //AudioTrack.write jmethodID audio_track_write_mid = (*env)-&gt;GetMethodID(env, audio_track_class, "write", "([BII)I"); //16bit 44100 PCM 数据 uint8_t *out_buffer = (uint8_t *) av_malloc(MAX_AUDIO_FRME_SIZE); int got_frame = 0, index = 0, ret; //不断读取压缩数据 while (av_read_frame(pFormatCtx, packet) &gt;= 0) &#123; //解码音频类型的Packet if (packet-&gt;stream_index == audio_stream_idx) &#123; //解码 ret = avcodec_decode_audio4(codecCtx, frame, &amp;got_frame, packet); if (ret &lt; 0) &#123; LOGI("%s", "解码完成"); &#125; //解码一帧成功 if (got_frame &gt; 0) &#123; LOGI("解码：%d", index++); swr_convert(swrCtx, &amp;out_buffer, MAX_AUDIO_FRME_SIZE, (const uint8_t **) frame-&gt;data, frame-&gt;nb_samples); //获取sample的size int out_buffer_size = av_samples_get_buffer_size(NULL, out_channel_nb, frame-&gt;nb_samples, out_sample_fmt, 1); //out_buffer缓冲区数据，转成byte数组 jbyteArray audio_sample_array = (*env)-&gt;NewByteArray(env, out_buffer_size); jbyte *sample_bytep = (*env)-&gt;GetByteArrayElements(env, audio_sample_array, NULL); //out_buffer的数据复制到sampe_bytep memcpy(sample_bytep, out_buffer, out_buffer_size); //同步 (*env)-&gt;ReleaseByteArrayElements(env, audio_sample_array, sample_bytep, 0); //AudioTrack.write PCM数据 (*env)-&gt;CallIntMethod(env, audio_track, audio_track_write_mid, audio_sample_array, 0, out_buffer_size); //释放局部引用 (*env)-&gt;DeleteLocalRef(env, audio_sample_array); &#125; &#125; av_free_packet(packet); &#125; (*env)-&gt;CallVoidMethod(env, audio_track, audio_track_stop_mid); av_frame_free(&amp;frame); av_free(out_buffer); swr_free(&amp;swrCtx); avcodec_close(codecCtx); avformat_close_input(&amp;pFormatCtx); (*env)-&gt;ReleaseStringUTFChars(env, input_, input);&#125; CMakeLists.txt1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980cmake_minimum_required(VERSION 3.4.1)include_directories($&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/include)set(jnilibs "$&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs")set(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;jnilibs&#125;/$&#123;ANDROID_ABI&#125;)add_library( # Sets the name of the library. native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/native-lib.c)# 添加 FFmpeg 的 8 个函数库和 yuvlib 库add_library(avutil-54 SHARED IMPORTED )set_target_properties(avutil-54 PROPERTIES IMPORTED_LOCATION "$&#123;jnilibs&#125;/$&#123;ANDROID_ABI&#125;/libavutil-54.so")add_library(swresample-1 SHARED IMPORTED )set_target_properties(swresample-1 PROPERTIES IMPORTED_LOCATION "$&#123;jnilibs&#125;/$&#123;ANDROID_ABI&#125;/libswresample-1.so")add_library(avcodec-56 SHARED IMPORTED )set_target_properties(avcodec-56 PROPERTIES IMPORTED_LOCATION "$&#123;jnilibs&#125;/$&#123;ANDROID_ABI&#125;/libavcodec-56.so")add_library(avformat-56 SHARED IMPORTED )set_target_properties(avformat-56 PROPERTIES IMPORTED_LOCATION "$&#123;jnilibs&#125;/$&#123;ANDROID_ABI&#125;/libavformat-56.so")add_library(swscale-3 SHARED IMPORTED )set_target_properties(swscale-3 PROPERTIES IMPORTED_LOCATION "$&#123;jnilibs&#125;/$&#123;ANDROID_ABI&#125;/libswscale-3.so")add_library(postproc-53 SHARED IMPORTED )set_target_properties(postproc-53 PROPERTIES IMPORTED_LOCATION "$&#123;jnilibs&#125;/$&#123;ANDROID_ABI&#125;/libpostproc-53.so")add_library(avfilter-5 SHARED IMPORTED )set_target_properties(avfilter-5 PROPERTIES IMPORTED_LOCATION "$&#123;jnilibs&#125;/$&#123;ANDROID_ABI&#125;/libavfilter-5.so")add_library(avdevice-56 SHARED IMPORTED )set_target_properties(avdevice-56 PROPERTIES IMPORTED_LOCATION "$&#123;jnilibs&#125;/$&#123;ANDROID_ABI&#125;/libavdevice-56.so")add_library(yuv SHARED IMPORTED )set_target_properties(yuv PROPERTIES IMPORTED_LOCATION "$&#123;jnilibs&#125;/$&#123;ANDROID_ABI&#125;/libyuv.so")find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log )#找到 Android 系统 Window 绘制相关的库find_library( android-lib android )target_link_libraries( native-lib $&#123;log-lib&#125; $&#123;android-lib&#125; avutil-54 swresample-1 avcodec-56 avformat-56 swscale-3 postproc-53 avfilter-5 avdevice-56 yuv) PS： 注意添加文件读写权限。 关注公众号 AndroidGeeks ，并在后台回复 ffmpeglib 获取相应的函数库。 参考文章雷霄骅博客 http://blog.csdn.net/leixiaohua1020/article/details/15811977Jason 的 NDK 开发高级教程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NDK FFmpeg 编译]]></title>
      <url>%2F2018%2F01%2F20%2FNDK-FFmpeg-compile%2F</url>
      <content type="text"><![CDATA[互联网时代限制个人发展的不再是掌握知识和信息的多少，而是个人的认知水平。 本篇介绍一下 Linux 环境下 FFmpeg 的编译。 本博客 NDK 开发系列文章： NDK 编译的三种方式 在 NDK 开发中引入第三方静态库和动态库 NDK 开发中 Native 与 Java 交互 NDK POSIX 多线程编程 NDK Android OpenSL ES 音频采集与播放 FFmpeg 是什么？FFmpeg 全称（First Forward MPEG），是一款领先的开源多媒体框架，采用 LGPL 或 GPL 许可证，除了具有音视频编解码功能外，还有视频格式转换、视频抓图、视频水印、推流等功能。 FFmpeg 在 Linux 平台下开发，但它同样也可以在其它操作系统环境中编译运行，包括 Windows 、Mac OS X 等。 FFmpeg的官方网站是：http://ffmpeg.org/ Windows 平台下，编译好的可用版本一般有三个： Static ，Shared ，Dev 。Static 里面有 3 个应用程序：ffmpeg.exe ，ffplay.exe ，ffprobe.exe ，动态链接库都被编译在 exe 文件中，每个 exe 的体积都很大，可直接运行，如播放一段视频，命令行下执行：ffmpeg video.mp4。Shared 里面除了 3 个应用程序：ffmpeg.exe ，ffplay.exe ，ffprobe.exe 之外，还有一些动态链接库，如 avcodec-54.dll 之类的，Shared 里面的 exe 体积较小。Dev 版本主要用于开发的，里面包含了一些库文件 xxx.lib 和文件 xxx.h 。 Linux 平台下，本文选择的版本是 2.6.9 ，地址：http://ffmpeg.org/olddownload.html 编译 FFmpeg搭建 Linux 开发环境，安装 Ubuntu 虚拟机或者电脑装成双系统，或者购买一个低配的阿里云主机，文件传输工具推荐 FileZilla 或 XFTP 。 Linux 环境下配置 NDK首先下载 Linux 环境下的 NDK （注意科学上网），如 android-ndk-r11c-linux-x86_64.bin 。执行如下命令进行解压缩：./android-ndk-r11c-linux-x86_64.bin配置环境变量，首先编辑 .bashrc 文件。vim ~/.bashrc在文件结尾添加两行代码：12export NDKROOT=( NDK 解压的根目录）如 、/usr/workspace/ndk/android-ndk-r11cexport PATH=$NDKROOT:$PATH 更新环境变量：source ~/.bashrc 编译准备首先下载 FFmpeg ，地址：http://ffmpeg.org/olddownload.html。解压：uzip ffmpeg-2.6.9.zip然后编写用于编译的 Shell 脚本，在 ffmpeg-2.6.9 根目录下执行：vim build_android.sh1234567891011121314151617181920212223242526272829303132#!/bin/bashmake cleanexport NDK=/home/wuhuannan/Android/Sdk/ndk-bundleexport SYSROOT=$NDK/platforms/android-14/arch-arm/export TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64export CPU=armexport PREFIX=$(pwd)/android/$CPUexport ADDI_CFLAGS="-marm"./configure --target-os=linux \--prefix=$PREFIX --arch=arm \--disable-doc \--enable-shared \--disable-static \--disable-yasm \--disable-symver \--enable-gpl \--disable-ffmpeg \--disable-ffplay \--disable-ffprobe \--disable-ffserver \--disable-doc \--disable-symver \--cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \--enable-cross-compile \--sysroot=$SYSROOT \--extra-cflags="-Os -fpic $ADDI_CFLAGS" \--extra-ldflags="$ADDI_LDFLAGS" \$ADDITIONAL_CONFIGURE_FLAGmake cleanmakemake install 然后修改根目录下的 configure 文件。1234567891011#找到并注释以下代码#SLIBNAME_WITH_MAJOR='$(SLIBNAME).$(LIBMAJOR)'#LIB_INSTALL_EXTRA_CMD='$$(RANLIB) "$(LIBDIR)/$(LIBNAME)"'#SLIB_INSTALL_NAME='$(SLIBNAME_WITH_VERSION)'#SLIB_INSTALL_LINKS='$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)'#在上述代码下添加以下代码SLIBNAME_WITH_MAJOR='$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)'LIB_INSTALL_EXTRA_CMD='$$(RANLIB)"$(LIBDIR)/$(LIBNAME)"'SLIB_INSTALL_NAME='$(SLIBNAME_WITH_MAJOR)'SLIB_INSTALL_LINKS='$(SLIBNAME)' 修改文件权限： chmod +x build_android.sh configure 执行一下脚本开始编译： ./build_android.sh 约几分钟后，编译生成的动态库文件如下： 后续我们将在 Android 环境下的音视频编解码中使用这个动态库。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NDK Android OpenSL ES 音频采集与播放]]></title>
      <url>%2F2018%2F01%2F15%2FNDK-Android-OpenSL-ES-Tutorial%2F</url>
      <content type="text"><![CDATA[不要用战术上的勤奋掩盖战略上的懒惰。 本篇详细介绍一下基于 Android OpenSL ES 实现音频的采集与播放。 本博客 NDK 开发系列文章： NDK 编译的三种方式 在 NDK 开发中引入第三方静态库和动态库 NDK 开发中 Native 与 Java 交互 NDK POSIX 多线程编程 OpenSL ES 是什么？OpenSL ES 是一个针对嵌入式系统的开放硬件音频加速库，也可以将其视为一套针对嵌入式平台的音频标准，全称为： Open Sound Library for Embedded Systems ，它提供了一套高性能、 低延迟的音频功能实现方法，并且实现了软硬件音频性能的跨平台部署，大大降低了上层处理音频应用的开发难度。 在 Android 开发中，Google 官方从 Android 2.3 （API 9）开始，便支持了 OpenSL ES 标准 ，并且对其进行了扩展。本文介绍的 OpenSL ES 是针对 Android NDK 开发来说。 OpenSL ES 的一些基本概念基于 c 语言的面向对象接口OpenSL ES 是基于 c 语言实现的，但其提供的接口是采用面向对象的方式实现，OpenSL ES 的大多数 API 是通过对象来调用的。例如，以下代码片段，主要的逻辑是实例化引擎对象和获取引擎对象接口：12345678910SLresult result;// realize the engineresult = (*engineObject)-&gt;Realize(engineObject, SL_BOOLEAN_FALSE);assert(SL_RESULT_SUCCESS == result);(void)result;result = (*engineObject)-&gt;GetInterface(engineObject, SL_IID_ENGINE, &amp;engineEngine);assert(SL_RESULT_SUCCESS == result);(void)result; 对象和接口概念Object 和 Interface OpenSL ES 中的两大基本概念，可以类比为 Java 中的对象和接口。在 OpenSL ES 中， 每个 Object 可以存在一系列的 Interface ，并且为每个对象都提供了一系列的基本操作，如 Realize，GetState，Destroy 等。重要的一点，只有通过 GetInterface 方法拿到 Object 的 Interface ，才能使用 Object 提供的功能。 对象的生命周期OpenSL ES 的 Object 一般有三种状态，分别是： SL_OBJECT_STATE_UNREALIZED （不可用），SL_OBJECT_STATE_REALIZED（可用），SL_OBJECT_STATE_SUSPENDED（挂起）。 Object 处于 SL_OBJECT_STATE_UNREALIZED （不可用）状态时，系统不会为其分配资源；调用 Realize 方法后便进入 SL_OBJECT_STATE_REALIZED（可用）状态，此时对象的各个功能和资源可以正常访问；当系统音频相关的硬件设备被其他进程占用时，OpenSL ES Object 便会进入 SL_OBJECT_STATE_SUSPENDED （挂起）状态，随后调用 Resume 方法可使对象重回 SL_OBJECT_STATE_REALIZED（可用）状态；当 Object 使用结束后，调用 Destroy 方法释放资源，是对象重回 SL_OBJECT_STATE_UNREALIZED （不可用）状态。 OpenSL ES 常用的 Object 和 InterfaceAudio 引擎对象和接口Audio 引擎对象和接口，即 Engine Object 和 SLEngineItf Interface 。Engine Object 的主要功能是管理 Audio Engine 的生命周期，提供引擎对象的管理接口。引擎对象的使用方法如下：1234567891011121314151617181920SLresult result;// 创建引擎对象result = slCreateEngine(&amp;engineObject, 0, NULL, 0, NULL, NULL);assert(SL_RESULT_SUCCESS == result);(void)result;// 实例化result = (*engineObject)-&gt;Realize(engineObject, SL_BOOLEAN_FALSE);assert(SL_RESULT_SUCCESS == result);(void)result;// 获取引擎对象接口result = (*engineObject)-&gt;GetInterface(engineObject, SL_IID_ENGINE, &amp;engineEngine);assert(SL_RESULT_SUCCESS == result);(void)result;// 释放引擎对象的资源result = (*engineObject)-&gt;Destroy(engineObject, SL_BOOLEAN_FALSE);assert(SL_RESULT_SUCCESS == result);(void)result; SLRecordItf 和 SLPlayItfSLRecordItf 和 SLPlayItf 分别抽象多媒体功能 recorder 和 player ，通过 SLEngineItf 的 CreateAudioPlayer 和 CreateAudioRecorder 方法分别创建 player 和 recorder 对象实例。1234567891011121314// 创建 audio recorder 对象result = (*engineEngine)-&gt;CreateAudioRecorder(engineEngine, &amp;recorderObject , &amp;recSource, &amp;dataSink, NUM_RECORDER_EXPLICIT_INTERFACES, iids, required);// 创建 audio player 对象SLresult result = (*engineEngine)-&gt;CreateAudioPlayer( engineEngine, &amp;audioPlayerObject, &amp;dataSource, &amp;dataSink, 1, interfaceIDs, requiredInterfaces); SLDataSource 和 SLDataSinkOpenSL ES 中的 SLDataSource 和 SLDataSink 结构体，主要用于构建 audio player 和 recorder 对象，其中 SLDataSource 表示音频数据来源的信息，SLDataSink 表示音频数据输出信息。1234567891011121314151617181920212223242526272829303132// 数据源简单缓冲队列定位器SLDataLocator_AndroidSimpleBufferQueue dataSou SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEU 1&#125;;// PCM 数据源格式SLDataFormat_PCM dataSourceFormat = &#123; SL_DATAFORMAT_PCM, // 格式类型 wav_get_channels(wav), // 通道数 wav_get_rate(wav) * 1000, //采样率 wav_get_bits(wav), // 位宽 wav_get_bits(wav), SL_SPEAKER_FRONT_CENTER, // 通道屏蔽 SL_BYTEORDER_LITTLEENDIAN // 字节顺序&#125;;// 数据源SLDataSource dataSource = &#123; &amp;dataSourceLocator, &amp;dataSourceFormat&#125;;// 针对数据接收器的输出混合定位器(混音器)SLDataLocator_OutputMix dataSinkLocator = &#123; SL_DATALOCATOR_OUTPUTMIX, // 定位器类型 outputMixObject // 输出混合&#125;;// 输出SLDataSink dataSink = &#123; &amp;dataSinkLocator, // 定位器 0,&#125;; OpenSL ES Recorder 和 Player 功能构建Audio RecorderAudio Player PS： Audio Player 的 Data Source 也可以是本地存储或缓存的音频数据，以上图片来自于 Jhuster 的博客。 代码实现以下代码主要实现音频数据的采集、保存和播放。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358//// Created by haohao on 2018/1/12.//#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;assert.h&gt;#include &lt;SLES/OpenSLES.h&gt;#include &lt;SLES/OpenSLES_Android.h&gt;#include &lt;android/log.h&gt;#define AUDIO_SRC_PATH "/sdcard/audio.pcm"#define LOGI(FORMAT, ...) __android_log_print(ANDROID_LOG_INFO,"haohao",FORMAT,##__VA_ARGS__);#define LOGE(FORMAT, ...) __android_log_print(ANDROID_LOG_ERROR,"haohao",FORMAT,##__VA_ARGS__);#define NUM_RECORDER_EXPLICIT_INTERFACES 2#define NUM_BUFFER_QUEUE 1#define SAMPLE_RATE 44100#define PERIOD_TIME 20 // 20ms#define FRAME_SIZE SAMPLE_RATE * PERIOD_TIME / 1000#define CHANNELS 2#define BUFFER_SIZE (FRAME_SIZE * CHANNELS)// engine interfacesstatic SLObjectItf engineObject = NULL;static SLEngineItf engineEngine = NULL;// audio recorder interfacesstatic SLObjectItf recorderObject = NULL;static SLRecordItf recorderRecord = NULL;static SLAndroidSimpleBufferQueueItf recorderBuffQueueItf = NULL;static SLAndroidConfigurationItf configItf = NULL;// pcm audio player interfacesstatic SLObjectItf playerObject = NULL;static SLPlayItf playerPlay = NULL;static SLObjectItf outputMixObjext = NULL; // 混音器static SLAndroidSimpleBufferQueueItf playerBufferQueueItf = NULL;void createEngine()&#123; SLEngineOption EngineOption[] = &#123; &#123;(SLuint32) SL_ENGINEOPTION_THREADSAFE, (SLuint32) SL_BOOLEAN_TRUE&#125; &#125;; SLresult result; result = slCreateEngine(&amp;engineObject, 1, EngineOption, 0, NULL, NULL); assert(SL_RESULT_SUCCESS == result); /* Realizing the SL Engine in synchronous mode. */ result = (*engineObject)-&gt;Realize(engineObject, SL_BOOLEAN_FALSE); assert(SL_RESULT_SUCCESS == result); // get the engine interface, which is needed in order to create other objects result = (*engineObject)-&gt;GetInterface(engineObject, SL_IID_ENGINE, &amp;engineEngine); assert(SL_RESULT_SUCCESS == result);&#125;class AudioContext &#123;public: FILE *pfile; uint8_t *buffer; size_t bufferSize; AudioContext(FILE *pfile, uint8_t *buffer, size_t bufferSize)&#123; this-&gt;pfile = pfile; this-&gt;buffer = buffer; this-&gt;bufferSize = bufferSize; &#125;&#125;;static AudioContext *recorderContext = NULL;// 录制音频时的回调void AudioRecorderCallback(SLAndroidSimpleBufferQueueItf bufferQueueItf, void *context)&#123; AudioContext *recorderContext = (AudioContext*)context; assert(recorderContext != NULL); if (recorderContext-&gt;buffer != NULL) &#123; fwrite(recorderContext-&gt;buffer, recorderContext-&gt;bufferSize, 1, recorderContext-&gt;pfile); LOGI("save a frame audio data."); SLresult result; SLuint32 state; result = (*recorderRecord)-&gt;GetRecordState(recorderRecord, &amp;state); assert(SL_RESULT_SUCCESS == result); (void) result; if (state == SL_RECORDSTATE_RECORDING) &#123; result = (*bufferQueueItf)-&gt;Enqueue(bufferQueueItf, recorderContext-&gt;buffer, recorderContext-&gt;bufferSize); assert(SL_RESULT_SUCCESS == result); (void) result; &#125; &#125;&#125;// 播放音频时的回调void AudioPlayerCallback(SLAndroidSimpleBufferQueueItf bufferQueueItf, void *context)&#123; AudioContext *playerContext = (AudioContext*)context; if (!feof(playerContext-&gt;pfile)) &#123; fread(playerContext-&gt;buffer, playerContext-&gt;bufferSize, 1, playerContext-&gt;pfile); LOGI("read a frame audio data."); (*bufferQueueItf)-&gt;Enqueue(bufferQueueItf, playerContext-&gt;buffer, playerContext-&gt;bufferSize); &#125; else &#123; fclose(playerContext-&gt;pfile); delete playerContext-&gt;buffer; &#125;&#125;// 创建音频播放器void createAudioPlayer(SLEngineItf engineEngine, SLObjectItf outputMixObject, SLObjectItf &amp;audioPlayerObject)&#123; SLDataLocator_AndroidSimpleBufferQueue dataSourceLocator = &#123; SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE, 1 &#125;; // PCM 数据源格式 SLDataFormat_PCM dataSourceFormat = &#123; SL_DATAFORMAT_PCM, 2, SL_SAMPLINGRATE_44_1, SL_PCMSAMPLEFORMAT_FIXED_16, 16, SL_SPEAKER_FRONT_LEFT| SL_SPEAKER_FRONT_RIGHT, SL_BYTEORDER_LITTLEENDIAN &#125;; SLDataSource dataSource = &#123; &amp;dataSourceLocator, &amp;dataSourceFormat &#125;; SLDataLocator_OutputMix dataSinkLocator = &#123; SL_DATALOCATOR_OUTPUTMIX, // 定位器类型 outputMixObject // 输出混合 &#125;; SLDataSink dataSink = &#123; &amp;dataSinkLocator, // 定位器 0, &#125;; // 需要的接口 SLInterfaceID interfaceIDs[] = &#123; SL_IID_BUFFERQUEUE &#125;; SLboolean requiredInterfaces[] = &#123; SL_BOOLEAN_TRUE &#125;; // 创建音频播放对象 SLresult result = (*engineEngine)-&gt;CreateAudioPlayer( engineEngine, &amp;audioPlayerObject, &amp;dataSource, &amp;dataSink, 1, interfaceIDs, requiredInterfaces ); assert(SL_RESULT_SUCCESS == result); (void) result;&#125;extern "C" &#123;// 开始播放音频JNIEXPORT void JNICALLJava_com_haohao_opensl_1es_AudioRecorder_startPlay(JNIEnv *env, jobject instance) &#123; // 创建引擎 if (engineEngine == NULL) &#123; createEngine(); &#125; // 创建混音器 SLresult result; result = (*engineEngine)-&gt;CreateOutputMix(engineEngine, &amp;outputMixObjext, 0, 0, 0); assert(SL_RESULT_SUCCESS == result); (void) result; result = (*outputMixObjext)-&gt;Realize(outputMixObjext, SL_BOOLEAN_FALSE); assert(SL_RESULT_SUCCESS == result); (void) result; FILE *p_file = fopen(AUDIO_SRC_PATH, "r"); // 创建播放器 createAudioPlayer(engineEngine, outputMixObjext, playerObject); result = (*playerObject)-&gt;Realize(playerObject, SL_BOOLEAN_FALSE); assert(SL_RESULT_SUCCESS == result); (void) result; result = (*playerObject)-&gt;GetInterface(playerObject, SL_IID_BUFFERQUEUE, &amp;playerBufferQueueItf); assert(SL_RESULT_SUCCESS == result); (void) result; uint8_t *buffer = new uint8_t[BUFFER_SIZE]; AudioContext *playerContext = new AudioContext(p_file, buffer, BUFFER_SIZE); result = (*playerBufferQueueItf)-&gt;RegisterCallback(playerBufferQueueItf, AudioPlayerCallback, playerContext); assert(SL_RESULT_SUCCESS == result); (void) result; result = (*playerObject)-&gt;GetInterface(playerObject, SL_IID_PLAY, &amp;playerPlay); assert(SL_RESULT_SUCCESS == result); (void) result; result = (*playerPlay)-&gt;SetPlayState(playerPlay, SL_PLAYSTATE_PLAYING); assert(SL_RESULT_SUCCESS == result); AudioPlayerCallback(playerBufferQueueItf, playerContext);&#125;// 停止播放音频JNIEXPORT void JNICALLJava_com_haohao_opensl_1es_AudioRecorder_stopPlay(JNIEnv *env, jobject instance) &#123; if (playerPlay != NULL) &#123; SLresult result; result = (*playerPlay)-&gt;SetPlayState(playerPlay, SL_PLAYSTATE_STOPPED); assert(SL_RESULT_SUCCESS == result); &#125;&#125;// 开始采集音频数据，并保存到本地JNIEXPORT void JNICALLJava_com_haohao_opensl_1es_AudioRecorder_startRecord(JNIEnv *env, jobject instance) &#123; if (engineEngine == NULL) &#123; createEngine(); &#125; if (recorderObject != NULL) &#123; LOGI("Audio recorder already has been created."); return ; &#125; FILE *p_file = fopen(AUDIO_SRC_PATH, "w"); if (p_file == NULL) &#123; LOGI("Fail to open file."); return ; &#125; SLresult result; /* setup the data source*/ SLDataLocator_IODevice ioDevice = &#123; SL_DATALOCATOR_IODEVICE, SL_IODEVICE_AUDIOINPUT, SL_DEFAULTDEVICEID_AUDIOINPUT, NULL &#125;; SLDataSource recSource = &#123;&amp;ioDevice, NULL&#125;; SLDataLocator_AndroidSimpleBufferQueue recBufferQueue = &#123; SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE, NUM_BUFFER_QUEUE &#125;; SLDataFormat_PCM pcm = &#123; SL_DATAFORMAT_PCM, // pcm 格式的数据 2, // 2 个声道（立体声） SL_SAMPLINGRATE_44_1, // 44100hz 的采样频率 SL_PCMSAMPLEFORMAT_FIXED_16, SL_PCMSAMPLEFORMAT_FIXED_16, SL_SPEAKER_FRONT_LEFT| SL_SPEAKER_FRONT_RIGHT, SL_BYTEORDER_LITTLEENDIAN &#125;; SLDataSink dataSink = &#123; &amp;recBufferQueue, &amp;pcm &#125;; SLInterfaceID iids[NUM_RECORDER_EXPLICIT_INTERFACES] = &#123;SL_IID_ANDROIDSIMPLEBUFFERQUEUE, SL_IID_ANDROIDCONFIGURATION&#125;; SLboolean required[NUM_RECORDER_EXPLICIT_INTERFACES] = &#123;SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE&#125;; /* Create the audio recorder */ result = (*engineEngine)-&gt;CreateAudioRecorder(engineEngine, &amp;recorderObject , &amp;recSource, &amp;dataSink, NUM_RECORDER_EXPLICIT_INTERFACES, iids, required); assert(SL_RESULT_SUCCESS == result); /* get the android configuration interface*/ result = (*recorderObject)-&gt;GetInterface(recorderObject, SL_IID_ANDROIDCONFIGURATION, &amp;configItf); assert(SL_RESULT_SUCCESS == result); /* Realize the recorder in synchronous mode. */ result = (*recorderObject)-&gt;Realize(recorderObject, SL_BOOLEAN_FALSE); assert(SL_RESULT_SUCCESS == result); /* Get the buffer queue interface which was explicitly requested */ result = (*recorderObject)-&gt;GetInterface(recorderObject, SL_IID_ANDROIDSIMPLEBUFFERQUEUE, (void*) &amp;recorderBuffQueueItf); assert(SL_RESULT_SUCCESS == result); /* get the record interface */ result = (*recorderObject)-&gt;GetInterface(recorderObject, SL_IID_RECORD, &amp;recorderRecord); assert(SL_RESULT_SUCCESS == result); uint8_t *buffer = new uint8_t[BUFFER_SIZE]; recorderContext = new AudioContext(p_file, buffer, BUFFER_SIZE); result = (*recorderBuffQueueItf)-&gt;RegisterCallback(recorderBuffQueueItf, AudioRecorderCallback, recorderContext); assert(SL_RESULT_SUCCESS == result); /* Enqueue buffers to map the region of memory allocated to store the recorded data */ result = (*recorderBuffQueueItf)-&gt;Enqueue(recorderBuffQueueItf, recorderContext-&gt;buffer, BUFFER_SIZE); assert(SL_RESULT_SUCCESS == result); /* Start recording */ // 开始录制音频 result = (*recorderRecord)-&gt;SetRecordState(recorderRecord, SL_RECORDSTATE_RECORDING); assert(SL_RESULT_SUCCESS == result); LOGI("Starting recording");&#125;// 停止音频采集JNIEXPORT void JNICALLJava_com_haohao_opensl_1es_AudioRecorder_stopRecord(JNIEnv *env, jobject instance) &#123; if (recorderRecord != NULL) &#123; SLresult result = (*recorderRecord)-&gt;SetRecordState(recorderRecord, SL_RECORDSTATE_STOPPED); assert(SL_RESULT_SUCCESS == result); if (recorderContext != NULL) &#123; fclose(recorderContext-&gt;pfile); delete recorderContext-&gt;buffer; &#125; &#125;&#125;// 释放资源JNIEXPORT void JNICALLJava_com_haohao_opensl_1es_AudioRecorder_release(JNIEnv *env, jobject instance) &#123; if (recorderObject != NULL) &#123; (*recorderObject)-&gt;Destroy(recorderObject); recorderObject = NULL; recorderRecord = NULL; recorderBuffQueueItf = NULL; configItf = NULL; recorderContext = NULL; &#125; if (playerObject != NULL) &#123; (*playerObject)-&gt;Destroy(playerObject); playerObject = NULL; playerPlay = NULL; playerBufferQueueItf = NULL; outputMixObjext = NULL; &#125; // destroy engine object, and invalidate all associated interfaces if (engineObject != NULL) &#123; (*engineObject)-&gt;Destroy(engineObject); engineObject = NULL; engineEngine = NULL; &#125;&#125;&#125;; CMake 脚本 CMakeLists.txt 。123456789101112131415cmake_minimum_required(VERSION 3.4.1)add_library( # Sets the name of the library. audio-recorder # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/audio-recorder.cpp)target_link_libraries(audio-recorder android log OpenSLES)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NDK POSIX 多线程编程]]></title>
      <url>%2F2018%2F01%2F09%2FNDK-posix-multi-thread%2F</url>
      <content type="text"><![CDATA[人价值的高低取决于稀缺性，即不可代替性。 本篇详细介绍一下 POSIX 多线程编程常用的 API 。 本博客 NDK 开发系列文章： NDK 编译的三种方式 在 NDK 开发中引入第三方静态库和动态库 NDK 开发中 Native 与 Java 交互 POSIXPOSIX 全称是 Portable Operating System Interface of UNIX ，表示可移植操作系统接口，本质上是一种编程标准。它定义了操作系统应该为应用程序提供的接口标准，是 IEEE 为要在各种 UNIX 操作系统上运行的软件而定义的一系列 API 标准的总称。 PthreadsPOSIX 线程是 POSIX 的线程标准，也称为 Pthreads ，它定义了创建和管理线程的一套 API 。本文的 Pthreads 是实现 POSIX 线程标准的 c 语言编程库。在 Linux 系统中，一般多线程的实现由 POSIX 多线程编程实现，而 Android 系统基于 Linux 系统，原生便支持 POSIX 多线程编程。 POSIX Linux 编译命令：gcc hello.c -o hello -lpthread，执行命令：./hello。 由于本文讲的是 NDK 开发，代码编译基于 Android 平台实现。 POSIX 线程创建线程创建相关 API：pthread_t 线程 id 。pthread_create 负责创建线程，传入 pthread_t（线程 ID ）的指针，线程的执行方法和传入线程的参数。pthread_join 使当前线程挂起，等待指定线程执行结束，并获取线程返回值。pthread_exit 退出当前线程，并且可以设置当前线程的返回值。pthread_cancel 终止当前线程。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include "hello-thread.h"#define NUM_THREADS 5// 类似于 Java Runnablevoid *run(void *arg)&#123; // 取传入当前线程的参数 char *thread_tag = (char*)arg; for (int i = 0; i &lt; 5; ++i) &#123; LOGD("%s thread %d", thread_tag, i); if (i == 4) &#123; // 结束当前线程,参数为线程结束后的返回值 pthread_exit(thread_tag); //pthread_cancel(); send a cancellation request to a thread &#125; &#125; return 0; // 线程正常执行完成后的返回值&#125;void create_threads()&#123; LOGD("Main thread"); char tag_arr[][5] = &#123;"No.1","No.2","No.3","No.4","No.5"&#125;; //线程 id ，用于区分线程，一个线程对应一个唯一的 id pthread_t tids[NUM_THREADS]; for (int i = 0; i &lt; NUM_THREADS; ++i) &#123; // 创建线程，指定 run 方法，传入参数 tags[i] pthread_create(&amp;tids[i], NULL, run, (void *) tag_arr[i]); &#125; void *return_val[NUM_THREADS]; for (int i = 0; i &lt; NUM_THREADS; ++i) &#123; // 阻塞当前线程，等待指定 tid 的线程结束，并获取线程返回值 // join with a terminated thread pthread_join(tids[i], &amp;return_val[i]); LOGD("thread %s terminated.", (char*)return_val[i]); &#125;&#125; 运行结果：12345678910111213141516171819202122232425262728293031I/hello-thread: Main threadI/hello-thread: No.1 thread 0I/hello-thread: No.1 thread 1I/hello-thread: No.1 thread 2I/hello-thread: No.1 thread 3I/hello-thread: No.1 thread 4I/hello-thread: No.2 thread 0I/hello-thread: No.2 thread 1I/hello-thread: No.2 thread 2I/hello-thread: No.2 thread 3I/hello-thread: No.2 thread 4I/hello-thread: No.3 thread 0I/hello-thread: No.3 thread 1I/hello-thread: No.3 thread 2I/hello-thread: No.3 thread 3I/hello-thread: No.3 thread 4I/hello-thread: No.4 thread 0I/hello-thread: No.4 thread 1I/hello-thread: No.4 thread 2I/hello-thread: No.4 thread 3I/hello-thread: No.4 thread 4I/hello-thread: thread No.1 terminated.I/hello-thread: No.5 thread 0I/hello-thread: No.5 thread 1I/hello-thread: No.5 thread 2I/hello-thread: No.5 thread 3I/hello-thread: No.5 thread 4I/hello-thread: thread No.2 terminated.I/hello-thread: thread No.3 terminated.I/hello-thread: thread No.4 terminated.I/hello-thread: thread No.5 terminated. POSIX 线程同步线程同步相关 API :pthread_mutex_t 互斥锁。pthread_mutex_init 初始化互斥锁，需传入互斥锁的指针。pthread_mutex_destroy 销毁互斥锁，需传入互斥锁的指针。pthread_mutex_lock 加锁，需传入互斥锁的指针。pthread_mutex_unlock 解锁，需传入互斥锁的指针。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include "hello-thread.h"int g_count = 0;// 互斥锁pthread_mutex_t mutex;void *asyn_run(void *arg)&#123; // lock pthread_mutex_lock(&amp;mutex); // 取传入当前线程的参数 char *thread_tag = (char*)arg; for (int i = 0; i &lt; 10; ++i) &#123; // 休眠 200 ms usleep(200 * 1000); g_count ++; LOGD("%s thread %d, g_count = %d", thread_tag, i, g_count); &#125; // unlock pthread_mutex_unlock(&amp;mutex); return thread_tag; // 线程正常执行完成后的返回值&#125;void syn_thread()&#123; LOGD("Main thread"); // 初始化互斥锁 pthread_mutex_init(&amp;mutex, NULL); pthread_t t1, t2; // 创建 2 个线程 pthread_create(&amp;t1, NULL, asyn_run, "No.1"); pthread_create(&amp;t2, NULL, asyn_run, "No.2"); void *rtn_val[2]; pthread_join(t1, &amp;rtn_val[0]); pthread_join(t2, &amp;rtn_val[1]); LOGD("thread %s terminated.", (char*)rtn_val[0]); LOGD("thread %s terminated.", (char*)rtn_val[1]); // 销毁互斥锁 pthread_mutex_destroy(&amp;mutex);&#125; 运行结果：12345678910111213141516171819202122I/hello-thread: No.1 thread 0, g_count = 1I/hello-thread: No.1 thread 1, g_count = 2I/hello-thread: No.1 thread 2, g_count = 3I/hello-thread: No.1 thread 3, g_count = 4I/hello-thread: No.1 thread 4, g_count = 5I/hello-thread: No.1 thread 5, g_count = 6I/hello-thread: No.1 thread 6, g_count = 7I/hello-thread: No.1 thread 7, g_count = 8I/hello-thread: No.1 thread 8, g_count = 9I/hello-thread: No.1 thread 9, g_count = 10I/hello-thread: No.2 thread 0, g_count = 11I/hello-thread: No.2 thread 1, g_count = 12I/hello-thread: No.2 thread 2, g_count = 13I/hello-thread: No.2 thread 3, g_count = 14I/hello-thread: No.2 thread 4, g_count = 15I/hello-thread: No.2 thread 5, g_count = 16I/hello-thread: No.2 thread 6, g_count = 17I/hello-thread: No.2 thread 7, g_count = 18I/hello-thread: No.2 thread 8, g_count = 19I/hello-thread: No.2 thread 9, g_count = 20I/hello-thread: thread No.1 terminated.I/hello-thread: thread No.2 terminated. POSIX 线程间通信线程间通信相关 API ：pthread_cond_t 条件变量，条件变量是线程同步的一种手段，使线程可以休眠等待某种条件出现。pthread_cond_signal 发送一个信号给另外一个正在处于阻塞等待状态的线程，原本这两个线程竞争同一个 mutex lock 。pthread_cond_wait 使当前线程处于阻塞状态，直到接收到其他线程发送对应的 cond_signal 。pthread_cond_init 初始化条件变量。pthread_cond_destroy 销毁条件变量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include "hello-thread.h"// 共享数据volatile int shared_count = 0;pthread_mutex_t pthread_mutex;// 条件变量pthread_cond_t pthread_cond;void *producer(void *arg)&#123; char *tag = (char*)arg; for (;;) &#123; pthread_mutex_lock(&amp;pthread_mutex); // 生产者生产产品 shared_count ++; LOGD("%s thread 生产产品, count = %d", tag, shared_count); // 通知消费者线程消费 pthread_cond_signal(&amp;pthread_cond); pthread_mutex_unlock(&amp;pthread_mutex); // 休眠 200 ms usleep(200 * 1000); &#125; return (void*)0;&#125;void *consumer(void *arg)&#123; char* tag = (char*)arg; for(;;)&#123; pthread_mutex_lock(&amp;pthread_mutex); while (shared_count == 0)&#123; // 当没有产品可以消费时，等待生产者生产（等待条件变量被唤醒，当前线程释放互斥锁） // 当被其他线程唤醒时，解除阻塞状态，重新申请获得互斥锁 pthread_cond_wait(&amp;pthread_cond, &amp;pthread_mutex); &#125; shared_count --; LOGD("%s thread 消费产品, count = %d", tag, shared_count); pthread_mutex_unlock(&amp;pthread_mutex); // 休眠 500 ms usleep(500 * 1000); &#125; return (void*)0;&#125;;// 线程间通信void communicate_thread()&#123; pthread_mutex_init(&amp;pthread_mutex, NULL); // 初始化条件变量 pthread_cond_init(&amp;pthread_cond, NULL); // 线程 id pthread_t producer_tid, consumer_tid; // 创建生产者线程 pthread_create(&amp;producer_tid, NULL, producer, "producer"); // 创建消费者线程 pthread_create(&amp;consumer_tid, NULL, consumer, "consumer"); // 等待线程结束 pthread_join(producer_tid, NULL); pthread_join(consumer_tid, NULL); // 销毁互斥锁 pthread_mutex_destroy(&amp;pthread_mutex); // 销毁条件变量 pthread_cond_destroy(&amp;pthread_cond);&#125; 运行结果:12345678910111213141516I/hello-thread: producer thread 生产产品, count = 1I/hello-thread: consumer thread 消费产品, count = 0I/hello-thread: producer thread 生产产品, count = 1I/hello-thread: producer thread 生产产品, count = 2I/hello-thread: consumer thread 消费产品, count = 1I/hello-thread: producer thread 生产产品, count = 2I/hello-thread: producer thread 生产产品, count = 3I/hello-thread: consumer thread 消费产品, count = 2I/hello-thread: producer thread 生产产品, count = 3I/hello-thread: producer thread 生产产品, count = 4I/hello-thread: producer thread 生产产品, count = 5I/hello-thread: consumer thread 消费产品, count = 4I/hello-thread: producer thread 生产产品, count = 5I/hello-thread: producer thread 生产产品, count = 6I/hello-thread: consumer thread 消费产品, count = 5......]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NDK 开发中 Native 与 Java 交互]]></title>
      <url>%2F2018%2F01%2F06%2FNDK-native-call-java-method%2F</url>
      <content type="text"><![CDATA[人生远比我们想象得漫长，所以不争一城一池的得失，要把一切机会和挫折都放到尽可能长的周期里来思考。 本篇详细介绍一下 Native 层与 Java 交互方式 前面文章分别介绍的 NDK 编译方式和第三方库的引入方式： NDK 编译的三种方式 在 NDK 开发中引入第三方静态库和动态库 Java 与 JNI 数据类型对应关系 Java 数据类型 JNI 数据类型 boolean jboolean byte jbyte char jchar short jshort int jint long jlong float jfloat double jdouble String jstring Object jobject byte[] jbyteArray Object[] jobjectArray Native 中的签名NDK 开发中会用到 Java 对象的属性签名和方法签名，用于区分不同的属性和方法。 属性签名属性的签名就是属性类型的简称。属性类型与其签名的对应关系如下： 属性类型 类型签名 boolean Z byte B char C short S int I long L float F double D void V String Ljava/lang/String; Object 以 L 开头，后加完整的包名，并以分号结束 byte[] [B Object[] 以 [ 开头，后加对象类型签名，例如 String[] 对应 [Ljava/lang/String; 方法签名方法签名格式：(参数类型签名)返回值类型签名 那么如何获取方法签名？执行命令 javah &lt;class 文件的全名&gt;如 javah com.haohao.hellojni.NativeTest.class 生成 com_haohao_hellojni_NativeTest.h 文件，文件中便标出了方法的 Signature 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class com_haohao_hellojni_NativeTest */#ifndef _Included_com_haohao_hellojni_NativeTest#define _Included_com_haohao_hellojni_NativeTest#ifdef __cplusplusextern "C" &#123;#endif/* * Class: com_haohao_hellojni_NativeTest * Method: getString * Signature: ()Ljava/lang/String; */JNIEXPORT jstring JNICALL Java_com_haohao_hellojni_NativeTest_getString__ (JNIEnv *, jobject);/* * Class: com_haohao_hellojni_NativeTest * Method: getString * Signature: (Ljava/lang/String;)Ljava/lang/String; */JNIEXPORT jstring JNICALL Java_com_haohao_hellojni_NativeTest_getString__Ljava_lang_String_2 (JNIEnv *, jobject, jstring);/* * Class: com_haohao_hellojni_NativeTest * Method: getInt * Signature: ()I */JNIEXPORT jint JNICALL Java_com_haohao_hellojni_NativeTest_getInt__ (JNIEnv *, jobject);/* * Class: com_haohao_hellojni_NativeTest * Method: getInt * Signature: (I)I */JNIEXPORT jint JNICALL Java_com_haohao_hellojni_NativeTest_getInt__I (JNIEnv *, jobject, jint);/* * Class: com_haohao_hellojni_NativeTest * Method: input * Signature: (Ljava/lang/String;I)V */JNIEXPORT void JNICALL Java_com_haohao_hellojni_NativeTest_input__Ljava_lang_String_2I (JNIEnv *, jobject, jstring, jint);/* * Class: com_haohao_hellojni_NativeTest * Method: input * Signature: ([Ljava/lang/String;I)V */JNIEXPORT void JNICALL Java_com_haohao_hellojni_NativeTest_input___3Ljava_lang_String_2I (JNIEnv *, jobject, jobjectArray, jint);/* * Class: com_haohao_hellojni_NativeTest * Method: getBytes * Signature: ([Ljava/lang/String;Ljava/lang/String;)[B */JNIEXPORT jbyteArray JNICALL Java_com_haohao_hellojni_NativeTest_getBytes (JNIEnv *, jobject, jobjectArray, jstring);#ifdef __cplusplus&#125;#endif#endif Native 与 Java 交互设置一个简单的类 NativeUtils.java 用于测试，Native 与 Java 交互的实现类似于 Java 的反射机制。 12345678910111213141516171819202122232425262728293031323334353637383940package com.haohao.hellojni;import android.util.Log;/** * author: haohao * time: 2018/1/1 * mail: haohaochang86@gmail.com * desc: description */public class NativeUtils &#123; static &#123; System.loadLibrary("native-utils"); &#125; private static final String TAG = "NativeUtils"; public static int staticProp = -1; public int prop = -1; public String getStringFromJava(String str)&#123; Log.i(TAG, "getStringFromJava: "+ str); return "Hello C , I am from Java."; &#125; public static String getStringFromJavaStatic(String str)&#123; Log.i(TAG, "getStringFromJavaStatic: " + str); return "Hello C , I am from Java static."; &#125; public native void accessJavaClassProp(); public native void callJavaClassMethod(); public static native void accessStaticJavaProp(); public static native void callStaticJavaMethod();&#125; 访问 Java 对象的非静态属性123456789101112131415JNIEXPORT void JNICALLJava_com_haohao_hellojni_NativeUtils_accessJavaClassProp(JNIEnv *env, jobject instance) &#123; //访问 Java 对象的非静态属性 //通过 JNIEnv 和对象 instance 实例拿到 class 。 jclass cls = (*env)-&gt;GetObjectClass(env, instance); //获取属性的 field id jfieldID fid = (*env)-&gt;GetFieldID(env, cls, "prop", "I"); //通过 field id 获取属性的值 jint prop = (*env)-&gt;GetIntField(env, instance, fid); //在 Native 层修改属性 prop += 101; (*env)-&gt;SetIntField(env, instance, fid, prop);&#125; 调用 Java 对象的非静态方法1234567891011121314151617JNIEXPORT void JNICALLJava_com_haohao_hellojni_NativeUtils_callJavaClassMethod(JNIEnv *env, jobject instance) &#123; //调用 Java 对象的非静态方法 jclass myClass = (*env)-&gt;GetObjectClass(env, instance); //获取发方法的 method id jmethodID mid = (*env)-&gt;GetMethodID(env, myClass, "getStringFromJava", "(Ljava/lang/String;)Ljava/lang/String;"); //调用 Java 对象的方法 jstring jstr = (*env)-&gt;CallObjectMethod(env, instance, mid, (*env)-&gt;NewStringUTF(env, "Hello Java, I am From C.")); //jstring 转换为 c 的字符串 const char* cstr = (*env)-&gt;GetStringUTFChars(env, jstr, NULL); LOGD("%s", cstr); //注意区别对待 Java 字符串和 C 的字符串，除了基本数据类型之外，其他都需要进行类型转换 //释放资源 (*env)-&gt;ReleaseStringUTFChars(env, jstr, cstr);&#125; 访问 Java 对象的静态属性12345678910JNIEXPORT void JNICALLJava_com_haohao_hellojni_NativeUtils_accessStaticJavaProp(JNIEnv *env, jclass type) &#123; //访问 Java 对象的静态属性, jfieldID fid = (*env)-&gt;GetStaticFieldID(env, type, "staticProp", "I"); jint staticProp = (*env)-&gt;GetStaticIntField(env, type, fid); staticProp += 101; (*env)-&gt;SetStaticIntField(env, type, fid, staticProp);&#125; 调用 Java 对象的静态方法123456789101112JNIEXPORT void JNICALLJava_com_haohao_hellojni_NativeUtils_callStaticJavaMethod(JNIEnv *env, jclass type) &#123; //调用 Java 对象的静态方法 jmethodID mid = (*env)-&gt;GetStaticMethodID(env, type, "getStringFromJavaStatic", "(Ljava/lang/String;)Ljava/lang/String;"); jstring jstr = (*env)-&gt;CallStaticObjectMethod(env, type, mid, (*env)-&gt;NewStringUTF(env, "Hello Java, I am From C.")); const char* cstr = (*env)-&gt;GetStringUTFChars(env, jstr, NULL); LOGD("%s", cstr); //释放资源 (*env)-&gt;ReleaseStringUTFChars(env, jstr, cstr);&#125; 测试123456789nativeUtils = new NativeUtils();Log.i(TAG, "old prop : " + nativeUtils.prop);nativeUtils.accessJavaClassProp();Log.i(TAG, "new prop : " + nativeUtils.prop);Log.i(TAG, "old static prop : " + NativeUtils.staticProp);NativeUtils.accessStaticJavaProp();Log.i(TAG, "new static prop : " + NativeUtils.staticProp);nativeUtils.callJavaClassMethod();NativeUtils.callStaticJavaMethod(); native-utils.c 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//// Created by haohao on 2018/1/1.//#include &lt;jni.h&gt;#include &lt;android/log.h&gt;#define TAG "native-utils"#define LOGD(...) __android_log_print(ANDROID_LOG_INFO,TAG ,__VA_ARGS__) // 定义LOGD类型JNIEXPORT void JNICALLJava_com_haohao_hellojni_NativeUtils_accessJavaClassProp(JNIEnv *env, jobject instance) &#123; //访问 Java 对象的非静态属性 //通过 JNIEnv 和对象 instance 实例拿到 class 。 jclass cls = (*env)-&gt;GetObjectClass(env, instance); //获取属性的 field id jfieldID fid = (*env)-&gt;GetFieldID(env, cls, "prop", "I"); //通过 field id 获取属性的值 jint prop = (*env)-&gt;GetIntField(env, instance, fid); //在 Native 层修改属性 prop += 101; (*env)-&gt;SetIntField(env, instance, fid, prop);&#125;JNIEXPORT void JNICALLJava_com_haohao_hellojni_NativeUtils_callJavaClassMethod(JNIEnv *env, jobject instance) &#123; //调用 Java 对象的非静态方法 jclass myClass = (*env)-&gt;GetObjectClass(env, instance); //获取发方法的 method id jmethodID mid = (*env)-&gt;GetMethodID(env, myClass, "getStringFromJava", "(Ljava/lang/String;)Ljava/lang/String;"); //调用 Java 对象的方法 jstring jstr = (*env)-&gt;CallObjectMethod(env, instance, mid, (*env)-&gt;NewStringUTF(env, "Hello Java, I am From C.")); //jstring 转换为 c 的字符串 const char* cstr = (*env)-&gt;GetStringUTFChars(env, jstr, NULL); LOGD("%s", cstr); //注意区别对待 Java 字符串和 C 的字符串，除了基本数据类型之外，其他都需要进行类型转换 //释放资源 (*env)-&gt;ReleaseStringUTFChars(env, jstr, cstr);&#125;JNIEXPORT void JNICALLJava_com_haohao_hellojni_NativeUtils_accessStaticJavaProp(JNIEnv *env, jclass type) &#123; //访问 Java 对象的静态属性, jfieldID fid = (*env)-&gt;GetStaticFieldID(env, type, "staticProp", "I"); jint staticProp = (*env)-&gt;GetStaticIntField(env, type, fid); staticProp += 101; (*env)-&gt;SetStaticIntField(env, type, fid, staticProp);&#125;JNIEXPORT void JNICALLJava_com_haohao_hellojni_NativeUtils_callStaticJavaMethod(JNIEnv *env, jclass type) &#123; //调用 Java 对象的静态方法 jmethodID mid = (*env)-&gt;GetStaticMethodID(env, type, "getStringFromJavaStatic", "(Ljava/lang/String;)Ljava/lang/String;"); jstring jstr = (*env)-&gt;CallStaticObjectMethod(env, type, mid, (*env)-&gt;NewStringUTF(env, "Hello Java, I am From C.")); const char* cstr = (*env)-&gt;GetStringUTFChars(env, jstr, NULL); LOGD("%s", cstr); //释放资源 (*env)-&gt;ReleaseStringUTFChars(env, jstr, cstr);&#125; 结果12345678I/MainActivity: old prop : -1I/MainActivity: new prop : 100I/MainActivity: old static prop : -1I/MainActivity: new static prop : 100I/NativeUtils: getStringFromJava: Hello Java, I am From C.I/native-utils: Hello C , I am from Java.I/NativeUtils: getStringFromJavaStatic: Hello Java, I am From C.I/native-utils: Hello C , I am from Java static.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[你好 2018]]></title>
      <url>%2F2018%2F01%2F01%2Fhello-2018%2F</url>
      <content type="text"><![CDATA[为 2018 立几个 FLAG 回看 20172017 是极其平淡的一年，也是孕育希望的一年。2017 我还在读研，2017 我还在租房。如果非要用几个字来形容 2017 年，那就是“学习”、“美食”、“电影”。 整个 2017 年，我和媳妇儿，看了很多场电影，吃了很多顿大餐（直接的后果就是导致我的体重增加 10 斤），这也许是我们最大的共同爱好。2017 年主要靠媳妇儿的工作收入和我研究生的微薄补足，支撑着我们的“电影”、“美食”和房租，另外我们还喜欢到处走走。 接下来主要总结一下，2017 年在技术方面的一些收获。除了搞项目之外，上半年主要掌握了 Facebook 的全家桶，包括 RN 和 React 前端开发技术，下半年以完成论文为目的学习了 Python 和 TensorFlow 开发，再到后来，系统地学习了 Kotlin Android 开发。以上技术学习都是基于个人兴趣，自己做了几个小项目，并没有运用的生产环境中。总体来说，对常规开发中的技术栈有了一定的掌握，但并没有深入，这也是兴趣太广泛的缺点。 回望 2017 ，非常感谢导师和同学在生活和学习上给予我的帮助，感谢我的家人给予我的陪伴和支持。 展望 2018不得不说，时间过得真的是太快了，大一的生活还历历在目，可是那已经是 7 年前的事了。正如，上帝悄悄偷走了我们的纯真，却神圣地说是成长的代价。 马上就要毕业了，接下来必须要独当一面，给我的 2018 立几个 FLAG （希望明年再看这篇文章的时候不会脸疼）。 生活继续培养我和媳妇儿共同爱好，“电影”、“美食”，在追加一个“到处走走”。继续培养我的新技能–烹饪，具体一点就是精通媳妇儿最喜欢吃的那几道菜的做法。等未来什么时候人工智能也淘汰了，那我就当厨师咯，人类总要吃饭的，哈哈。 技术熟练掌握音视频编解码技术，至少搞一个开源项目；掌握基于移动端的 TensorFlow 开发。 文章继续打理自己的公众号、博客，保证周期性更新。 健身毫无疑问，身体是革命的本钱，是一切美好的基石，尤其是针对经常调侃自己是吃青春饭的程序员来说。 2017 年由于实验室制度等各种原因（其实主要是自己太懒），周期运动都没坚持下来。 2018 年量化目标，确保体重比现在下降 10 斤。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[推荐 2 款 Google 访问工具]]></title>
      <url>%2F2017%2F12%2F31%2Frecommended-2-Google-access-tools%2F</url>
      <content type="text"><![CDATA[影响人生命运的选择，不在于某个重要关头的重大事件，而在于一些很无所谓的事情。&gt; 2017 年最后一篇文章，只有福利，没有干货。# iShadow #iShadow 是一个提供科学上网服务的网站。当然科学上网工具不只有某风、某灯、**-Net 等，iShadow 网站整体风格独树一帜，进入该网站后，你首先会因看到一大堆美食而口水直流。iShadow 网站主界面 这个网站给人的第一感觉就是，它是搞美食烹饪的，但细想一下也没错，毕竟大部分程序员都是吃货。该网站提供免费和付费的 SS 账号，免费账号的密码每 6 个小时更换一次，速度良好，对于一般需求的开发者足够了。 使用教程支持四种平台，配置非常方便。点击一道美食后，上方会出现一个二维码，用你的客户端扫描一下就完成配置。 iShadow 网站地址： https://global.ishadowx.net/ 由于不可抗力，网址会不断变更，但只需要记住和搜索 iShadow 关键词。 Google 访问助手 Google 访问助手是一款浏览器插件，该插件可以助你使用 Google 所提供的服务，如搜索引擎、Gmail 等，使用非常方便，但是屏蔽掉了大部分国外网站，包括 Android 官网等。那么，怎样才能获得插件呢？关注『 AndroidGeeks 』公众号 ，并在公众号后台回复关键字『 Google 』，即可获得该插件。 获得该插件后，打开 Chrome 浏览器，然后进入chrome://extensions/ 扩展程序页面，将 .crx 文件直接拖进去，即完成插件安装。 安装完成后，进入 Chrome 浏览器的设置页面，即 chrome://settings/ ，将启动页设置为 hao123 主页（忍忍吧），重启浏览器，即可以使用 Google 服务。 公众号文章链接 https://mp.weixin.qq.com/s/Zh5aZQH7er6CAzZNUifwLA]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在 NDK 开发中引入第三方静态库和动态库]]></title>
      <url>%2F2017%2F11%2F11%2FNDK-packaging-third-party-static-and-dynamic-lib%2F</url>
      <content type="text"><![CDATA[自律的前期是兴奋的，中期是痛苦的，后期是享受的。 本篇介绍在 NDK 开发中通过 CMake 引入第三方静态库和动态库。 静态库和动态库静态库静态库文件后缀一般为 .a ，利用静态库编译成的可执行文件通常比较大，编译后的执行程序不需要外部函数库的支持。但是，如果一个程序依赖的静态库发生改变，那么这个程序就需要重新编译。 动态库动态库也称为共享库，动态库文件后缀一般为 .so (Linux) 或 .dll (Windows) ，相对于静态库，动态库在编译时, 并没有被编译进目标代码中，程序执行到相关函数时才调用动态库里的相关函数，动态库编译后所产生的可执行文件通常较小。由于动态库没有被整合进程序，而是程序运行时动态地申请并调用，因此程序的运行环境中必须提供相应的库。动态库的改变并不影响程序，便于升级。 两种函数库特点静态库：编译后的执行程序不需要外部的函数库支持，编译过程中已经被载入可执行程序,程序运行时将不再需要该静态库；动态库：动态库的代码在程序运行时才载入内存，而编译过程中仅简单的引用，代码体积较小，并且动态库与程序代码独立，可复用，耦合度低； 生成第三方动态库和静态库本文主要通过 CMake 工具构建，请确保 AS 版本在 2.2 以上。本节简单生成一个动态库和静态库，模仿我们要引入的第三方库文件。新建一个工程，选择 Support C++ ，文件结构： 文件 haohao/haohao.h ，定义一个简单的结构体和一个简单的类。 12345678910111213141516171819202122232425262728293031323334353637//// Created by haohao on 2017/12/14.//#ifndef NDKLIB_HAOHAO_H#define NDKLIB_HAOHAO_H#include &lt;stddef.h&gt;#include &lt;android/log.h&gt;#include &lt;jni.h&gt;#include &lt;string&gt;#define LOG_E(...) __android_log_print(ANDROID_LOG_ERROR,"HaoHao",__VA_ARGS__)#ifdef __cplusplusextern "C" &#123;#endiftypedef struct &#123; std::string (*getResponse)();&#125; HaoHao_FUN;class HaoHao&#123;public: HaoHao(std::string, int); std::string getHaoHaoWord();private: std::string name; int age;&#125;;extern __attribute__ ((visibility ("default"))) HaoHao_FUN haohao_fun;#ifdef __cplusplus&#125;#endif#endif //NDKLIB_HAOHAO_H haohao/haohao.cpp ，实例化一个结构体。 123456789101112131415161718192021#include "haohao.h"HaoHao::HaoHao(std::string name, int age) &#123; this-&gt;name = name; this-&gt;age = age;&#125;std::string HaoHao::getHaoHaoWord() &#123; char tem[3]; sprintf(tem, "%d", age); return "Hello, My name is " + name + " I am " + tem + " years old";&#125;std::string get_response()&#123; HaoHao hao = HaoHao("chary", 23); return hao.getHaoHaoWord();&#125;__attribute__ ((visibility ("default"))) HaoHao_FUN haohao_fun = &#123; get_response&#125;; haohao/CMakeLists.txt 123456cmake_minimum_required(VERSION 3.4.1)add_library(haohao STATIC haohao.cpp ) // 添加为静态库find_library(log-lib log )target_link_libraries(haohao $&#123;log-lib&#125; ) nannan/nannan.h ，定义一个简单的结构体，提供给其他程序使用。 123456789101112131415161718192021222324#ifndef NDKLIB_NANNAN_H#define NDKLIB_NANNAN_H#include &lt;stddef.h&gt;#include &lt;android/log.h&gt;#include &lt;jni.h&gt;#include &lt;string&gt;#define LOG_E(...) __android_log_print(ANDROID_LOG_ERROR,"NanNan",__VA_ARGS__)#ifdef __cplusplusextern "C" &#123;#endiftypedef struct &#123; std::string (*getResponse)(); std::int32_t (*getNanNanKey)();&#125; NANNAN_FUN;extern __attribute__ ((visibility ("default"))) NANNAN_FUN nannan_fun;#ifdef __cplusplus&#125;#endif#endif //NDKLIB_NANNAN_H nannan/nannan.cpp 12345678910111213141516#include "nannan.h"std::string get_nannan_response()&#123; LOG_E("Nannan get response"); return "Hello, My name is Nannan!";&#125;std::int32_t get_nannan_age()&#123; LOG_E("Nannan get age"); return 23;&#125;__attribute__ ((visibility ("default"))) NANNAN_FUN nannan_fun = &#123; get_nannan_response, get_nannan_age&#125;; nannan/CmakeLists.txt 1234567cmake_minimum_required(VERSION 3.4.1)add_library(nannan SHARED nannan.cpp ) // 添加为动态库find_library(log-lib log )target_link_libraries(nannan $&#123;log-lib&#125; ) 根目录下的 CMakeLists.txt 123456789cmake_minimum_required(VERSION 3.4.1)include_directories($&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp)set(jnilibs &quot;$&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs&quot;)set(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;jnilibs&#125;/$&#123;ANDROID_ABI&#125;)set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++14 -pthread -DMGULK_LOG_STDERR=1 -Wall -Wextra -Wnon-virtual-dtor -g&quot;)ADD_SUBDIRECTORY($&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/haohao)ADD_SUBDIRECTORY($&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/nannan) app/build.gradle make 工程，在 app/src/main/jniLibs 目录下生成了我们需要的第三方库文件。 引入第三方库新建一个工程，将上节生成的第三方库文件拷贝到 app/src/main/jniLibs 目录下，在 cpp 目录下新建 include 目录，拷贝第三方库的头文件在 include 目录下。工程目录 MainActivity.java 1234567891011121314151617181920212223242526272829package com.haohao.ndklib;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; // Used to load the 'native-lib' library on application startup. static &#123; System.loadLibrary("native"); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // Example of a call to a native method TextView tv = (TextView) findViewById(R.id.sample_text); tv.setText(stringFromJNI()); &#125; /** * A native method that is implemented by the 'native-lib' native library, * which is packaged with this application. */ public native String stringFromJNI();&#125; native/native.cpp ，调用第三方库提供的 API 。 1234567891011121314151617181920#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;nannan.h&gt;#include &lt;haohao.h&gt;extern "C"&#123;JNIEXPORT jstring JNICALLJava_com_haohao_ndklib_MainActivity_stringFromJNI(JNIEnv *env, jobject instance) &#123; char age[3]; sprintf(age, "%d", nannan_fun.getNanNanKey()); std::string value = nannan_fun.getResponse() + " I am " + age + " years old.\n"; value += haohao_fun.getResponse(); //std::string value = "Hello"; return env-&gt;NewStringUTF(value.c_str());&#125;&#125; native/CMakeLists.txt 文件。 12345678910111213add_library(native SHARED native.cpp)# 引入 .so 文件add_library(nannan SHARED IMPORTED )set_target_properties(nannan PROPERTIES IMPORTED_LOCATION &quot;$&#123;jnilibs&#125;/$&#123;ANDROID_ABI&#125;/libnannan.so&quot;)# 引入 .a 文件add_library(haohao STATIC IMPORTED )set_target_properties(haohao PROPERTIES IMPORTED_LOCATION &quot;$&#123;jnilibs&#125;/$&#123;ANDROID_ABI&#125;/libhaohao.a&quot;)find_library( log-lib log )target_link_libraries(native nannan haohao $&#123;log-lib&#125;) 根目录下的 CMakeLists.txt 文件。 123456789cmake_minimum_required(VERSION 3.4.1)include_directories($&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/include)set(jnilibs &quot;$&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs&quot;)set(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;jnilibs&#125;/$&#123;ANDROID_ABI&#125;)set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++14 -pthread -DMGULK_LOG_STDERR=1 -Wall -Wextra -Wnon-virtual-dtor -g&quot;)ADD_SUBDIRECTORY($&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/native) app/build.gradle 文件配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445apply plugin: 'com.android.application'android &#123; compileSdkVersion 25 buildToolsVersion "25.0.3" defaultConfig &#123; applicationId "com.haohao.ndklib" minSdkVersion 15 targetSdkVersion 25 versionCode 1 versionName "1.0" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" externalNativeBuild &#123; cmake &#123; arguments '-DANDROID_PLATFORM=android-15', '-DANDROID_TOOLCHAIN=clang', '-DANDROID_STL=gnustl_static'// cppFlags "-DANDROID_STL=c++_static" abiFilters 'armeabi-v7a','x86_64', 'arm64-v8a','x86' &#125; &#125; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125; externalNativeBuild &#123; cmake &#123; path "CMakeLists.txt" &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123; exclude group: 'com.android.support', module: 'support-annotations' &#125;) compile 'com.android.support:appcompat-v7:25.3.1' testCompile 'junit:junit:4.12' compile 'com.android.support.constraint:constraint-layout:1.0.2'&#125; build 工程后，生成 libnative.so ，直接运行项目，安装 apk 。 本文示例代码 https://github.com/githubhaohao/NDKLib]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NDK 编译的三种方式]]></title>
      <url>%2F2017%2F11%2F04%2FNDK-compiled-three-ways%2F</url>
      <content type="text"><![CDATA[做任何事都不可能有 100% 的准备，我们都是一边准备一边面对未知。 本篇以图文的方式介绍一下 Android NDK 编译的几种方式 通过 Android Studio 默认的方式创建带有 native 方法的类，build 项目。 生成与类名相关的 .h 文件。进入 app -&gt; build -&gt; intermediates -&gt; classes -&gt; debug 目录下执行： javah com.haohao.hellojni.MyJNI （先配置好 JDK 的环境变量）,生成 com_haohao_hellojni_MyJNI.h 文件 创建 cpp 文件。在 main 文件夹下，新建 jni 目录，剪切 .h 文件到 jni 目录下，创建 hello.cpp 文件 hello.cpp 配置 build.gradle 文件。修改 app/build.gradle 文件， muduleName 为引入的 .so name , 直接运行项目，安装 apk ，运行就 OK 了 生成的 .so 文件位置。 PS： 未指定 CPU 框架时，AS 会生成支持所有 CPU 框架的 .so 文件。 通过 ndk-build创建 Android.mk 和 Application.mk 文件。新建一个项目，在 app 目录下（任目录下都可以）新建 jni 文件，添加 Android.mk 和 Application.mk 文件，以及 com_haohao_hellojni_MyJNI.h 文件（运用上一小节的方法生成）。Android.mk12345678910LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)# 要生成的.so库名称。java代码System.loadLibrary(&quot;hello&quot;);加载的就是它LOCAL_MODULE := hello# C++文件LOCAL_SRC_FILES := hello.cppinclude $(BUILD_SHARED_LIBRARY) Application.mk123# 不写 APP_ABI 会生成全部支持的平台,目前支持：armeabi arm64-v8a armeabi-v7a# APP_ABI := armeabi arm64-v8a armeabi-v7a mips mips64 x86 x86_64APP_ABI := armeabi arm64-v8a armeabi-v7a 生成 .so 文件。在 jni 目录下（配置好NDK环境变量）直接执行 ndk-build ， 生成 .so 文件。 配置项目工程。在 main 目录下新建 jniLibs 目录，并拷贝 armeabi arm64-v8a armeabi-v7a 文件夹，运行 proj 。 通过 CMake 工具。从 Android Studio 2.2 开始，就默认使用 CMake 工具构建 NDK 项目，请确保你的 AS 版本大于 2.2 。 通过 IDE 自动构建创建项目时，勾选 Include C++ support 选择默认的 Toolchain Default AS 自动生成 CMakeLists.txt 文件（CMake 构建脚本） CMakeLists.txt1234567891011121314151617181920212223242526272829303132333435363738394041424344# For more information about using CMake with Android Studio, read the# documentation: https://d.android.com/studio/projects/add-native-code.html# Sets the minimum version of CMake required to build the native library. # 指定CMake的最小版本cmake_minimum_required(VERSION 3.4.1)# Creates and names a library, sets it as either STATIC# or SHARED, and provides the relative paths to its source code.# You can define multiple libraries, and CMake builds them for you.# Gradle automatically packages shared libraries with your APK.# 设置模块名为 native-lib，SHARED 可分享的，以及配置源文件的路径add_library( # Sets the name of the library. 设置模块名 native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). 文件路径 src/main/cpp/native-lib.cpp )# Searches for a specified prebuilt library and stores the path as a# variable. Because CMake includes system libraries in the search path by# default, you only need to specify the name of the public NDK library# you want to add. CMake verifies that the library exists before# completing its build.# 找到 log 本地模块find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log )# Specifies libraries CMake should link to your target library. You# can link multiple libraries, such as libraries you define in this# build script, prebuilt third-party libraries, or system libraries.# 关联 native-lib 模块和 log 模块target_link_libraries( # Specifies the target library. native-lib # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125; ) 在配置 app/build.gradle ，针对特殊平台 abiFilters 。配置完成之后，同步，运行。 手动构建新建一个工程，创建 native 类，快捷键 Alt + Enter ,自动创建 jni 目录和相应的 .cpp 文件。 native-lib.cpp1234567891011#include &lt;jni.h&gt;#include &lt;string&gt;extern "C"JNIEXPORT jstring JNICALLJava_com_haohao_ndk_1cpp_MyJNI_stringFromJNI(JNIEnv *env, jobject instance) &#123; std::string hello = "Hello from C++"; return env-&gt;NewStringUTF(hello.c_str());&#125; 在工程根目录下创建 CMakeLists.txt 文件。1234567891011# 指定CMake的最小版本cmake_minimum_required(VERSION 3.4.1)add_library( # Sets the name of the library. 设置模块名 native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). 文件路径 src/main/cpp/native-lib.cpp ) 选择 app modulde ，右击选择Link C++ Project with Gradle。 选择脚本文件的路径。 app/build.gradle 会自动同步。同步完成后，运行项目。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在 Android 系统源码中自定义系统服务]]></title>
      <url>%2F2017%2F10%2F27%2Fcustom-android-system-service%2F</url>
      <content type="text"><![CDATA[一件事如果犹豫做还是不做，选“做”。 做了也可能会后悔，但是这种后悔和“没做”而产生的一辈子的妄念相比，坏处小多了。 本篇详细介绍一下在 Android 系统源码中自定义系统服务的过程。 在 Android 系统源码中自定义系统服务（Custom System Service in AOSP）配置编译环境（Initial AOSP build environment.）cd AOSP root dirsource build/envsetup.shlunch2 定义 Service 的 AIDL 文件（Define service AIDL file）path: frameworks/base/core/java/android/os/Create IHaoHaoService.aidl file 12345678package android.os;interface IHaoHaoService &#123; void setVal(String key,String value); String getVal(String key);&#125; 修改 Android 模块文件（Modify Android.mk file）path: frameworks/base/Android.mk 1234567891011121314151617181920212223242526......## READ ME: ############################################################ When updating this list of aidl files, consider if that aidl is## part of the SDK API. If it is, also add it to the list below that## is preprocessed and distributed with the SDK. This list should## not contain any aidl files for parcelables, but the one below should## if you intend for 3rd parties to be able to send those objects## across process boundaries.#### READ ME: ########################################################LOCAL_SRC_FILES += \ ...... core/java/android/os/IPowerManager.aidl \ core/java/android/os/IRemoteCallback.aidl \ core/java/android/os/ISchedulingPolicyService.aidl \ core/java/android/os/IUpdateLock.aidl \ core/java/android/os/IUserManager.aidl \ core/java/android/os/IVibratorService.aidl \ core/java/android/os/IHaoHaoService.aidl \ ...... 进行模块编译： ~/aosp/android-6.0.1_r1$ mmm frameworks/base generate IHaoHaoService.java file. 创建 HaoHaoService 文件（Create HaoHaoService file）path: frameworks/base/services/core/java/com/android/server/Create HaoHaoService.java file. 1234567891011121314151617181920212223242526package com.android.server;import android.util.Slog; import android.os.RemoteException;import android.os.IHaoHaoService;import java.util.HashMap;public class HaoHaoService extends IHaoHaoService.Stub &#123; private static HashMap&lt;String,String&gt; mCache = null; private static final String TAG="HaoHaoService"; public HaoHaoService() &#123; mCache = new HashMap&lt;&gt;(); Slog.d(TAG, "HaoHaoService starting."); &#125; public void setVal(String key, String value) throws RemoteException &#123; mCache.put(key, value); &#125; public String getVal(String key) throws RemoteException &#123; return mCache.get(key); &#125;&#125; 注册服务（Register service）Modify frameworks/base/core/java/android/content/Context.javaAdd: 12345678 /** * Use with &#123;@link #getSystemService&#125; to retrieve a * &#123;@link android.os.IHaoHaoService&#125; for accessing the HaoHao service. * * @see #getSystemService * @hide */public static final String HAOHAO_SERVICE = "haohao"; Modify frameworks/base/services/java/com/android/server/SystemServer.javaFind function startOtherServices()Add: 1234567try &#123; Slog.i(TAG, "***HaoHao Service***"); ServiceManager.addService(Context.HAOHAO_SERVICE, new HaoHaoService());&#125; catch (Throwable e) &#123; Slog.e(TAG, "Failure starting HaoHao Service", e);&#125; Create HaoHaoServiceManager.java filepath: frameworks/base/core/java/android/app/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package android.app;/** * Created by haohao on 17/10/2. */import android.annotation.SdkConstant;import android.annotation.SystemApi;import android.content.Context;import android.content.Intent;import android.os.Build;import android.os.Parcel;import android.os.Parcelable;import android.os.RemoteException;import android.os.IHaoHaoService;import android.util.Log;public class HaoHaoServiceManager &#123; private static final String TAG = "HaoHaoServiceManager"; private IHaoHaoService mService; public HaoHaoServiceManager(Context context, IHaoHaoService service)&#123; mService = service; &#125; public void setVal(String key,String value)&#123; try &#123; mService.setVal(key,value); &#125; catch(Exception e)&#123; Log.e(TAG, e.toString()); e.printStackTrace(); &#125; &#125; public String getVal(String key)&#123; try &#123; return mService.getVal(key); &#125; catch(Exception e)&#123; Log.e(TAG, e.toString()); e.printStackTrace(); &#125; return null; &#125;&#125; Register service in SystemServiceRegistry.java filepath: frameworks/base/core/java/android/app/SystemServiceRegistry.javaAdd: 1234567891011121314import android.os.IHaoHaoService; ...... registerService(Context.HAOHAO_SERVICE, HaoHaoServiceManager.class, new CachedServiceFetcher&lt;HaoHaoServiceManager&gt;() &#123; @Override public HaoHaoServiceManager createService(ContextImpl ctx) &#123; IBinder binder = ServiceManager.getService(Context.HAOHAO_SERVICE); IHaoHaoService service = IHaoHaoService.Stub.asInterface(binder); return new HaoHaoServiceManager(ctx, service); &#125;&#125;); ...... Modify SePolicy Build Checkpath: external/sepolicy/service.te Add: 1type haohao_service, system_api_service, system_server_service, service_manager_type; path: external/sepolicy/service_contexts Add: 1haohao u:object_r:haohao_service:s0 service_contexts 1234567accessibility u:object_r:accessibility_service:s0account u:object_r:account_service:s0activity u:object_r:activity_service:s0alarm u:object_r:alarm_service:s0haohao u:object_r:haohao_service:s0android.security.keystore u:object_r:keystore_service:s0android.service.gatekeeper.IGateKeeperService u:object_r:gatekeeper_service:s0 Update api and build~/aosp/android-6.0.1_r1$ make update-api -j8 ~/aosp/android-6.0.1_r1$ make -j8 Test service in your Activity123456@Overridepublic void onCreate() &#123; super.onCreate(); mHaoHaoServiceManager = (HaoHaoServiceManager)getSystemService(Context.HAOHAO_SERVICE); mHaoHaoServiceManager.setVal("haohao", "Android Developer");]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构与算法（Java 实现）之线性表（三）]]></title>
      <url>%2F2017%2F10%2F20%2FJava-data-structure-stack-and-queue%2F</url>
      <content type="text"><![CDATA[生活苟且的人，傻了吧唧的去了诗和远方；而鼓吹诗和远方的人，工作比谁都积极。 本篇简单介绍一下栈和队列的实现，它们是数据结构与算法中非常重要的基础。 栈（Stack） 栈是限定在表尾进行插入和删除的线性表。允许插入的端称为栈顶，另一端称为栈底。 栈的抽象数据类型1234567891011public interface Stack&lt;T&gt; &#123; T pop(); void push(T item); int size(); boolean isEmpty();&#125; 栈的实现(链栈)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class LinkedStack&lt;T&gt; implements Stack&lt;T&gt; &#123; private Node head; private int count; public LinkedStack() &#123; head = null; count = 0; &#125; @Override public T pop() &#123; if (head == null) &#123; throw new IllegalStateException("the stack is null."); &#125; Node node = head; head = head.getNext(); node.setNext(null); return (T) node.getElement(); &#125; @Override public void push(T item) &#123; Node node = new Node(item); node.setNext(head); head = node; count ++; &#125; @Override public int size() &#123; return count; &#125; @Override public boolean isEmpty() &#123; return count == 0; &#125; @Override public String toString() &#123; if (head == null) &#123; return null; &#125; else &#123; Node p = head; StringBuilder stringBuilder = new StringBuilder(); while (p != null) &#123; stringBuilder.append(p.getElement()).append("\n"); p = p.getNext(); &#125; return stringBuilder.toString(); &#125; &#125; public static void main(String[] args) &#123; LinkedStack&lt;String&gt; linkedStack = new LinkedStack&lt;String&gt;(); linkedStack.push("Android"); linkedStack.push("iOS"); linkedStack.push("Kotlin"); System.out.println(linkedStack.toString()); System.out.println("pop -&gt; " + linkedStack.pop()); System.out.println("pop -&gt; " + linkedStack.pop()); System.out.println(linkedStack.toString()); &#125;&#125; 输出： 1234567KotliniOSAndroidpop -&gt; Kotlinpop -&gt; iOSAndroid 队列（Queue） 队列是只允许在一端进行插入操作，在另一端进行删除操作的线性表。队列是一种先进先出的线性表（FIFO）。允许插入的一段称为队尾，允许删除的一端称为队头。 队列的抽象数据类型123456789101112public interface Queue&lt;T&gt; &#123; void enQueue(T item); T deQueue(); T peek(); int size(); boolean isEmpty();&#125; 队列实现（链队列）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class LinkedQueue&lt;T&gt; implements Queue&lt;T&gt; &#123; private int size; private Node head; public LinkedQueue() &#123; size = 0; head = null; &#125; @Override public void enQueue(T item) &#123; Node node = new Node(item); if (head == null) &#123; head = node; &#125; else &#123; Node p = head; Node prev = null; while (p != null) &#123; prev = p; p = p.getNext(); &#125; prev.setNext(node); &#125; size++; &#125; @Override public T deQueue() &#123; if (head == null) &#123; throw new IllegalStateException("the queue is empty."); &#125; Node node = head; head = head.getNext(); node.setNext(null); size --; return (T) node.getElement(); &#125; @Override public T peek() &#123; return (T) head.getElement(); &#125; @Override public int size() &#123; return size; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public String toString() &#123; if (isEmpty()) &#123; return null; &#125; else &#123; StringBuilder stringBuilder = new StringBuilder(); Node p = head; while (p != null) &#123; stringBuilder.append(p.getElement()).append("\n"); p = p.getNext(); &#125; return stringBuilder.toString(); &#125; &#125; public static void main(String[] args) &#123; LinkedQueue&lt;String&gt; linkedQueue = new LinkedQueue&lt;String&gt;(); linkedQueue.enQueue("Android"); linkedQueue.enQueue("iOS"); linkedQueue.enQueue("Kotlin"); linkedQueue.enQueue("Java"); System.out.println(linkedQueue.toString()); System.out.println("LinkedQueue dequeue -&gt; " + linkedQueue.deQueue()); System.out.println("LinkedQueue dequeue -&gt; " + linkedQueue.deQueue()); System.out.println(linkedQueue.toString()); &#125;&#125; 输出：123456789AndroidiOSKotlinJavaLinkedQueue dequeue -&gt; AndroidLinkedQueue dequeue -&gt; iOSKotlinJava]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Socket Socket.io Websocket 与 HTTP 之间的区别]]></title>
      <url>%2F2017%2F09%2F30%2Fdiff-between-socket-websocket-socket-io-and-http%2F</url>
      <content type="text"><![CDATA[教育的目的从来都是精神的独立而不是给予苦头，除非有人不希望看到你太“自在”，需要通过制度展示权力的威严 本篇从特征角度介绍一下，Socket、 Socket.io、 Websocket、 HTTP 之间的区别。 Socket 、 Socket.io 、 Websocket 、 HTTP 之间的区别 Socket 是操作系统提供的对于传输层（TCP / UDP）抽象的接口，是一个编程概念，而 Websocket 、Socket.io 与 HTTP 一样是一个成文的互联网协议。另外，Websocket 和 HTTP 都是基于 TCP 传输数据，Socket.io 可以看作是对 Websocket 和 HTTP 的又一次封装。 HTTP 是基于请求响应式的，即通信只能由客户端发起，服务端做出响应，无状态，无连接。无状态：每次连接只处理一个请求，请求结束后断开连接。无连接：对于事务处理没有记忆能力，服务器不知道客户端是什么状态。 以往实现即时通讯的手段：轮询：客户端定时向服务器发送 Ajax 请求，服务器接到请求后马上返回响应信息并关闭连接。长轮询：客户端向服务器发送 Ajax 请求，服务器接到请求后 hold 住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。长连接：在页面里嵌入一个隐蔵 iframe，将这个隐蔵 iframe 的 src 属性设为对一个长连接的请求，服务器端就能源源不断地往客户端输入数据。Flash Socket：在页面中内嵌入一个使用了 Socket 类的 Flash 程序 JavaScript 通过调用此 Flash 程序提供的 Socket 接口与服务器端的 Socket 接口进行通信，JavaScript 在收到服务器端传送的信息后控制页面的显示。 Websocket 的出现就是为了解决 HTTP 在即时通信中存在的不足，HTTP 是通过 Polling 实现即时通信存在很大的资源开销。 Webscoket 握手阶段采用 HTTP 协议，连接建立之后便与 HTTP 协议没有任何关系，Websocket 连接建立之后，client 与 server 可以同时收发数据，全双工通讯。 Socket.io 支持 Websocket 协议，支持多种轮询机制，它实现了实时、双向、基于事件的通讯机制，天生用来解决实时通讯问题。另外，Socket.io 能够根据浏览器对通讯机制的支持情况自动地选择最佳的方式来实现网络实时应用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构与算法（Java 实现）之线性表（二）]]></title>
      <url>%2F2017%2F09%2F26%2FJava-data-structure-linkedlist%2F</url>
      <content type="text"><![CDATA[因为我们的言语表达了我们的想法，而我们的想法创造了我们的生活。 本篇简单介绍一下单链表，单循环链表和双向循环链表。链表是线性表的核心内容，单链表可以很方便地构成栈和队列。 单链表节点12345678910111213141516171819202122232425262728293031323334353637/** * Created by HaohaoChang on 2017/9/9. */public class Node &#123; Object data; // 数据元素 Node next; // 下一节点的对象引用 public Node(Node nextval) &#123; // 用于头结点的构造函数 next = nextval; &#125; public Node(Object obj, Node nextval) &#123; // 用于下一节点的构造函数 data = obj; next = nextval; &#125; public Object getElement() &#123; return data; &#125; public Node getNext() &#123; return next; &#125; public void setElement(Object data) &#123; this.data = data; &#125; public void setNext(Node next) &#123; this.next = next; &#125; @Override public String toString() &#123; return data.toString(); &#125;&#125; 单链表 本篇的单链表是带头结点的单链表。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * Created by HaohaoChang on 2017/9/9. * 单链表 * | a0 | next | --&gt; | a1 | next | --&gt; | a2 | next | --&gt; ... --&gt; | an | null | * 时间复杂度O(n) */public class SingleLinkedList implements List &#123; Node head; // 头指针 Node current; // 当前节点位置 int size; // 数据元素个数 public SingleLinkedList() &#123; head = current = new Node(null); size = 0; &#125; @Override public int size() &#123; return size; &#125; @Override public void insert(int index, Object o) throws IllegalArgumentException &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalStateException("参数错误"); &#125; locate(index - 1); current.setNext(new Node(o, current.next)); size ++; System.out.println("insert node : " + o); &#125; @Override public Object delete(int index) throws IllegalArgumentException &#123; if (size == 0) &#123; throw new IllegalArgumentException("链表已空，没有元素可以删除"); &#125; if (index &lt; 0 || index &gt; size - 1) &#123; throw new IllegalArgumentException("参数错误"); &#125; locate(index - 1); Object o = current.next.getElement(); current.setNext(current.next.next); size --; System.out.println("delete node : " + o); return o; &#125; @Override public Object getData(int index) &#123; if (index &lt; 0 || index &gt; size - 1) &#123; throw new IllegalArgumentException("参数错误"); &#125; locate(index); return current.getElement(); &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; public void locate(int index) throws IllegalArgumentException &#123; // 定位 if (index &lt; -1 || index &gt; size - 1) &#123; throw new IllegalArgumentException("参数错误"); &#125; if (index == -1) &#123; current = head; return; &#125; current = head.next; int j = 0; while (current != null &amp;&amp; j &lt; index) &#123; current = current.next; j++; &#125; &#125; public static void main(String[] args) &#123; SingleLinkedList singleLinkedList = new SingleLinkedList(); singleLinkedList.insert(0, "Android"); singleLinkedList.insert(1, "iOS"); singleLinkedList.insert(2, "React Native"); singleLinkedList.insert(3, "Kotlin"); singleLinkedList.delete(0); System.out.println(singleLinkedList.size()); &#125; 运行输出：123456insert node : Androidinsert node : iOSinsert node : React Nativeinsert node : Kotlindelete node : Android3 单循环链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/** * Created by HaohaoChang on 2017/9/22. */public class SingleCirLinkedList implements List&#123; Node head; Node current; int size; public SingleCirLinkedList() &#123; head = current = new Node(null); head.setNext(head); size = 0; &#125; @Override public int size() &#123; return size; &#125; @Override public void insert(int index, Object o) throws IllegalArgumentException &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException("参数错误"); &#125; locate(index - 1); current.setNext(new Node(o, current.getNext())); size ++; &#125; @Override public Object delete(int index) throws IllegalArgumentException &#123; if (index &lt; 0 || index &gt; size - 1) &#123; throw new IllegalArgumentException("参数错误"); &#125; locate(index - 1); Object o = current.getNext().getElement(); System.out.println("delete : " + o); current.setNext(current.getNext().getNext()); size --; return o; &#125; @Override public Object getData(int index) throws IllegalArgumentException&#123; if (index &lt; 0 || index &gt; size - 1) &#123; throw new IllegalArgumentException("参数错误"); &#125; locate(index - 1); return current.getNext().getElement(); &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public String toString() &#123; if (size == 0) &#123; return "null"; &#125; StringBuilder stringBuilder = new StringBuilder(); Node p = head.getNext(); while (p != head) &#123; stringBuilder.append(p.getElement()).append("\n"); p = p.getNext(); &#125; return stringBuilder.toString(); &#125; /** * index 取值范围 -1 至 size - 2 需要考虑 0 -1 这两种特殊情况 */ private void locate(int index) throws IllegalArgumentException &#123; if (index &lt; -1) &#123; throw new IllegalArgumentException("参数错误"); &#125; if (index == -1) &#123; current = head; return; &#125; int j = 0; current = head.getNext(); while (current != head &amp;&amp; j &lt; index) &#123; current = current.getNext(); j++; &#125; &#125; public static void main(String[] args) &#123; SingleCirLinkedList cirLinkedList = new SingleCirLinkedList(); cirLinkedList.insert(0, "Android"); cirLinkedList.insert(1, "iOS"); cirLinkedList.insert(2, "Kotlin"); System.out.println(cirLinkedList.getData(0)); System.out.println(cirLinkedList.getData(1)); System.out.println(cirLinkedList.getData(2)); cirLinkedList.delete(1); System.out.println(cirLinkedList.toString()); &#125;&#125; 运行输出：123456AndroidiOSKotlindelete : iOSAndroidKotlin 双向循环链表双向循环链表节点123456789101112131415161718192021222324252627282930313233343536373839404142/** * Created by HaohaoChang on 2017/9/25. * 双向链表的节点 */public class DulNode &#123; Object element; DulNode prior; // 直接前驱指针 DulNode next; // 直接后继指针 public DulNode() &#123; &#125; public DulNode(Object element, DulNode prior, DulNode next) &#123; this.element = element; this.prior = prior; this.next = next; &#125; public Object getElement() &#123; return element; &#125; public DulNode getPrior() &#123; return prior; &#125; public DulNode getNext() &#123; return next; &#125; public void setElement(Object element) &#123; this.element = element; &#125; public void setPrior(DulNode prior) &#123; this.prior = prior; &#125; public void setNext(DulNode next) &#123; this.next = next; &#125;&#125; 双向循环链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/** * Created by HaohaoChang on 2017/9/25. */public class CirDulLinkedList implements List &#123; DulNode head; // 头结点 int size; public CirDulLinkedList() &#123; // 初始化头结点 head = new DulNode(); head.setPrior(head); head.setNext(head); head.setElement(null); &#125; @Override public int size() &#123; return size; &#125; @Override public void insert(int index, Object o) throws IllegalArgumentException &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException("参数错误"); &#125; if (index == size) &#123; // 特殊情况，在尾部直接添加节点 add(o); &#125; else &#123; DulNode p = search(index); DulNode s = p.getPrior(); DulNode newNode = new DulNode(o, s, p); s.setNext(newNode); p.setPrior(newNode); size++; &#125; &#125; @Override public Object delete(int index) throws IllegalArgumentException &#123; if (index &lt; 0 || index &gt; size - 1) &#123; throw new IllegalArgumentException("参数错误"); &#125; DulNode p = search(index); Object o = p.getElement(); DulNode s = p.getPrior(); s.setNext(p.getNext()); p.getNext().setPrior(s); size--; System.out.println("CirDulLinkedList.delete : " + o); return o; &#125; @Override public Object getData(int index) throws IllegalArgumentException &#123; if (index &lt; 0 || index &gt; size - 1) &#123; throw new IllegalArgumentException("参数错误"); &#125; return search(index).getElement(); &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public String toString() throws IllegalStateException &#123; if (size == 0) &#123; throw new IllegalStateException("链表为空"); &#125; StringBuilder stringBuilder = new StringBuilder(); DulNode p = head.getNext(); while (p != head) &#123; stringBuilder.append(p.getElement()).append("\n"); p = p.getNext(); &#125; return stringBuilder.toString(); &#125; /** * 直接在链表尾部添加节点 */ private void add(Object o) &#123; DulNode rear = head.getPrior(); DulNode newNode = new DulNode(o, rear, head); rear.setNext(newNode); head.setPrior(newNode); size++; &#125; // 按照位置查找节点 private DulNode search(int index) throws IllegalArgumentException &#123; DulNode p = null; if (index &gt; size / 2) &#123; // 位于链表的后半部分，反向查询 p = head.getPrior(); for (int i = size - 1; i &gt; index; i--) &#123; p = p.getPrior(); &#125; &#125; else &#123; // 位于链表的前半部分，正向查询 p = head.getNext(); for (int i = 0; i &lt; index; i++) &#123; p = p.getNext(); &#125; &#125; return p; &#125; public static void main(String[] args) &#123; CirDulLinkedList cirDulLinkedList = new CirDulLinkedList(); cirDulLinkedList.insert(0, "Android"); cirDulLinkedList.insert(1, "iOS"); cirDulLinkedList.insert(2, "Kotlin"); cirDulLinkedList.add("ReactNative"); System.out.println(cirDulLinkedList.toString()); cirDulLinkedList.delete(2); System.out.println(cirDulLinkedList.toString()); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构与算法（Java 实现）之线性表（一）]]></title>
      <url>%2F2017%2F09%2F26%2FJava-data-structure-lineartable%2F</url>
      <content type="text"><![CDATA[成年人学习的目的，应该是追求更好的思维模型，而不是更多的知识。 线性表 线性表（Linear List）是由 n（n≥0）个数据元素（结点）a[0]，a[1]，a[2]…，a[n-1] 组成的有限序列。 线性表按照存储结构分为：顺序表和链表顺序表：用一块地址连续的存储空间依次存储线性表中的数据元素；链表：链式存储结构的线性表，逻辑上相邻的元素在物理上可以不相邻，元素间的逻辑关系表现在节点的连接上。 抽象线性表123456789101112131415/** * Created by HaohaoChang on 2017/9/8. * 抽象线性表操作 */public interface List &#123; int size(); void insert(int index, Object o); Object delete(int index); Object getData(int index); boolean isEmpty();&#125; 顺序表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/** * Created by HaohaoChang on 2017/9/8. * 顺序表 * 数据元素存储在连续地址空间的内存单元 * 插入/删除操作时间复杂度O(n) */public class SeqList implements List &#123; private static final String TAG = "SeqList"; final int defultSize = 10; int maxSize; int size; Object[] array; public SeqList() &#123; initiate(defultSize); &#125; public SeqList(int size) &#123; initiate(size); &#125; private void initiate(int sz) &#123; maxSize = sz; size = 0; array = new Object[sz]; &#125; @Override public int size() &#123; return size; &#125; @Override public void insert(int index, Object o) throws IllegalArgumentException &#123; if (maxSize == index) &#123; throw new IllegalArgumentException("Seq list is full."); &#125; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException("argument error."); &#125; for (int i = size; i &gt; index; i--) &#123; array[i] = array[i-1]; &#125; array[index] = o; size ++; System.out.println("insert item : " + o); &#125; public void add(Object o) throws IllegalArgumentException &#123; if (maxSize == size) &#123; throw new IllegalArgumentException("Seq list is full."); &#125; array[size] = o; size ++; System.out.println("add item : " + o); &#125; @Override public Object delete(int index) &#123; if (size == 0) &#123; throw new IllegalArgumentException("Seq list is empty."); &#125; if (index &lt; 0 || index &gt; size - 1) &#123; throw new IllegalArgumentException("argument error."); &#125; Object o = array[index]; for (int i = index; i &lt; size - 1; i++) &#123; array[i] = array[i + 1]; &#125; size --; System.out.println("delete item : " + o + ",index : " + index); return o; &#125; @Override public Object getData(int index) &#123; if (size == 0) &#123; throw new IllegalArgumentException("Seq list is empty."); &#125; if (index &lt; 0 || index &gt; size - 1) &#123; throw new IllegalArgumentException("argument error."); &#125; return array[index]; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public String toString() &#123; if (size == 0) &#123; return "null"; &#125; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; size; i++) &#123; stringBuilder.append("index : ").append(i).append(", value : ").append(array[i]).append("\n"); &#125; return stringBuilder.toString(); &#125; public static void main(String[] args) &#123; SeqList seqList = new SeqList(); seqList.insert(0, "Kotlin"); seqList.add("Android"); seqList.insert(2, "NodeJS"); System.out.println(seqList); seqList.delete(0); seqList.delete(0); System.out.println(seqList); &#125;&#125; 代码运行结果：12345678910insert item : Kotlinadd item : Androidinsert item : NodeJSindex : 0, value : Kotlinindex : 1, value : Androidindex : 2, value : NodeJSdelete item : Kotlin,index : 0delete item : Android,index : 0index : 0, value : NodeJS 可变容量的顺序表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/** * Created by HaohaoChang on 2017/9/13. * 可变容量顺序表 */public class VarSeqList implements List &#123; static final int defaultSize = 10; int size; int length; Object[] array; public VarSeqList() &#123; array = new Object[defaultSize]; size = defaultSize; length = 0; &#125; @Override public int size() &#123; return length; &#125; @Override public void insert(int index, Object o) &#123; if (index &lt; 0 || index &gt; length) &#123; throw new IllegalStateException("参数错误"); &#125; if (length == size) &#123; extend(); &#125; for (int i = length; i &gt; index; i--) &#123; array[i] = array[i -1]; &#125; array[index] = o; length ++; &#125; @Override public Object delete(int index) &#123; System.out.println(index + " ," + length); if (length == 0) &#123; throw new IllegalStateException("列表为空"); &#125; if (index &lt; 0 || index &gt; length - 1) &#123; throw new IllegalStateException("参数错误"); &#125; Object o = array[index]; for (int i = index; i &lt; length - 1; i++) &#123; array[i] = array[i + 1]; &#125; length --; return o; &#125; @Override public Object getData(int index) &#123; if (length == 0) &#123; throw new IllegalStateException("列表为空"); &#125; if (index &lt; 0 || index &gt; length - 1) &#123; throw new IllegalStateException("参数错误"); &#125; return array[index]; &#125; @Override public boolean isEmpty() &#123; return length == 0; &#125; @Override public String toString() &#123; if (length == 0) &#123; throw new IllegalStateException("列表为空"); &#125; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; length; i++) &#123; stringBuilder.append(getData(i)).append("\n"); &#125; return stringBuilder.toString(); &#125; public void add(Object o) &#123; if (length == size) &#123; extend(); &#125; array[length] = o; length ++; &#125; private void extend() &#123; // 小心越界 size *= 2; Object[] newArray = new Object[size]; for (int i = 0; i &lt; length; i++) &#123; newArray[i] = array[i]; &#125; array = newArray; &#125; private void clear() &#123; length = 0; size = defaultSize; array = new Object[size]; &#125; public static void main(String[] args) &#123; VarSeqList varSeqList = new VarSeqList(); for (int i = 0; i &lt; 1000; i++) &#123; varSeqList.add(i); &#125; for (int i = 0; i &lt; 995; i++) &#123; varSeqList.delete(0); &#125; System.out.println(varSeqList.toString()); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浏览器从输入 Url 到展示出页面都经历了哪些过程]]></title>
      <url>%2F2017%2F09%2F23%2Ffrom-url-to-page-displaying%2F</url>
      <content type="text"><![CDATA[当你想完全准备好再做一件事的时候，不如先做起来，边做边准备 本篇简单介绍一下，浏览器从输入 Url 到展示出页面都经历了哪些过程。 输入域名在浏览器输入网址时，浏览器会根据历史记录、书签智能匹配补全域名或者 url 。例如 chrome 浏览器，甚至会根据匹配结果直接把网页加载出来。 解析域名请求发起时，浏览器首先解析域名，一般会首先查看本地的 hosts 文件，查找相关域名与 ip 地址的对应规则，若查找到的话，就直接使用 hosts 文件里面的 ip 地址。 若在本地 hosts 文件中，未找到目标域名与 ip 地址的对应关系，浏览器便会向本地 DNS 服务器发起一个 DNS 请求，本地 DNS 服务器收到请求之后，便会查询其缓存记录，若查询到此记录便直接返回结果。 若本地 DNS 服务器缓存中未查询到相关记录，便向 DNS 根服务器进行查询，根 DNS 服务器没有记录具体的域名与 ip 地址的映射关系，而是返回域服务器的地址。 本地 DNS 继续向域服务器发起请求，域服务器收到请求之后，返回域名解析服务器的地址。最后本地 DNS 服务器向域名解析服务器发送请求，域名解析服务器收到请求之后，返回域名与 ip 映射关系信息，然后本地 DNS 服务器将映射信息保存到其缓存中，同时也将 ip 地址返回给用户电脑。 图片来自网络 浏览器发起 http 请求浏览器获取到域名对应的 ip 地址之后，便会以一个随机端口（1024&lt; port &lt; 65535）向服务端 web 程序 80 端口发起 TCP 连接请求。 浏览器与服务端经过 3 次 TCP 握手之后，建立 TCP 连接，然后浏览器发起一个 http 请求。一般的浏览器只能发起 GET 或者 POST 请求。 请求信格式包含四个部分： 请求行（请求方法 URI 协议/版本） 请求头(缓存、客户端身份信息等) 空行 消息体 http 请求格式示例：1234567GET /index.html HTTP/1.1Cache-Control:max-age=0Cookie:gsScrollPos=; _ga=GA1.2.329038035.1465891024; _gat=1If-Modified-Since:Sun, 01 May 2016 23:59:59 GMTUser-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.84 Safari/537.36//消息体 PS：常用的请求方法有 GET/POST/DELETE/PUT/HEAD 。 三次握手四次挥手示意图 TCP 三次握手的目的是：为了防止已经失效的连接请求报文发送到服务端，服务端因而产生不必要的响应开销。 在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。在另一部经典的《计算机网络》一书中讲“三次握手”的目的是为了解决“网络中存在延迟的重复分组”的问题。 TCP 四次挥手的目的是：为确保收发双方数据传输的完整性。 那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。 服务器返回 http 响应服务端返回 http 响应的格式包含四个部分: 响应行（状态行）（协议/版本号 状态码 状态说明） 响应头（响应头是服务器传递给客户端用于说明服务器的一些信息，以及将来继续访问该资源时的策略。） 空行 消息体（响应体是服务端返回给客户端的 HTML 文本内容，或者其他格式的数据，比如：视频流、图片或者音频数据。） http 响应格式示例：12345678910111213HTTP/1.1 200 OKDate: Sat, 31 Dec 2016 23:59:59 GMTContent-Type: text/html;charset=ISO-8859-1Content-Length: 113＜html＞＜head＞＜title＞Haohao＜/title＞＜/head＞＜body＞Hello World！＜/body＞＜/html＞ PS：服务器在返回响应之前可能会经过重定向、反向代理服务器请求等过程。 浏览器处理响应以服务端响应消息体为 HTML 文本为例，浏览器解析 HTML 文本时，会”自上而下“加载，并在加载过程中进行解析渲染展现给用户。在解析过程中，如果遇到请求外部资源时，如图片、外链的 CSS 、 js 等，请求过程是异步的，并不会影响整个 HTML 文档的加载。 参考文章https://foofish.net/http-request-process.html https://github.com/jawil/blog/issues/14]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[接口与抽象类的区别（Java 7版本）]]></title>
      <url>%2F2017%2F09%2F20%2Fdiff-between-interface-and-abstract-class%2F</url>
      <content type="text"><![CDATA[你看起来像什么地位，你就是什么地位，互联网时代也是一个看颜的时代，虽无奈，但是事实 本篇从 8 个方面介绍一下，接口与抽象类的区别。 抽象接口与抽象类具备抽象多类对象相同属性特征的特点，均可作为一种规范。 属性（成员变量）抽象类中的成员变量与普通的 Java 类声明一样；接口中的成员变量只能是 public static final 类型的。 方法实现抽象类可以有方法实现，也可以用 abstract 关键字将其抽象化；接口不存在方法实现，所有的方法均为 public 抽象方法。 实例化抽象类有构造函数，但不能实例化，除了不能实例化之外，与普通的 Java 类没有区别；接口没有实例化的概念，无构造函数。 继承抽象类只能有一个父类，但可以实现多个接口；一个接口可以继承多个接口。 子类实现子类通过 extends 关键字来继承抽象类，如果子类不是抽象类的话，它需要提供抽象类中所有抽象方法的实现；子类通过 implements 关键字来实现接口，需要提供接口中所有声明方法的实现。 访问修饰符抽象类中抽象方法可以有 public、 protected 和 default 这些修饰符；接口方法默认修饰符是 public ，不可以使用其它修饰符。 访问速度同等条件下，对抽象类方法的访问速度快于接口，接口需要花时间寻找类中实现的方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017 下半年学习规划]]></title>
      <url>%2F2017%2F09%2F06%2F2017-study-plan%2F</url>
      <content type="text"><![CDATA[种一棵树最好的时间是 10 年前，其次是现在。 最近差不多解决了小论文的问题，心理负担一下子减轻一大半。上个月花了 20 多天时间在外地维护项目，坑啊，哪是维护项目，其实就是现场开发调试测试新功能。这一搞不要紧，彻底打乱了个人计划，本来论文是九月初完成，一直拖到现在，搞得现在计划很混乱，自己很头疼，更特么头疼的是自己的博客和公众号也有将近一个月没维护了，又一次被“啪啪”打脸。 我习惯于未来的生活有一个大致的安排，中间可以有点小插曲，但是不要打乱节奏就好。 接下来就是毕业季找工作，压力山大，所以目前必须要有一个明确的规划。主要应对接下来的面试、论文。 接下来每天解决掉的知识点都会在上面做记录。 2017 下学年学习规划大论文10 月份之前完成论文框架，其他 TBD Java按照 Java 工程师的标准储备 Java 基础知识 AndroidAndroid 进阶书籍反复学习 《Android开发艺术探索》《Android源码设计模式》 专业书籍 设计模式熟悉常用的设计模式六大原则 + 24 种设计模式 Android 架构熟悉 MVP MVVM Clean 架构 开源库源码阅读熟悉 RxJava Retrofit Glide 等常用开源库的原理和流程。 每天阅读优秀的开源库源码不少于半个小时。 数据结构解决掉两本书： 大话数据结构 程序员代码面试指南 算法时间复杂度线性表 顺序表线性表 单链表线性表 循环单链表线性表 循环双链表栈 顺序栈栈 链栈队列 顺序循环队列队列 链队列二叉树，树图 计算机网络计算机网路基础物理层数据链路层网络层运输层 操作系统操作系统原理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java 线程的七种状态]]></title>
      <url>%2F2017%2F07%2F21%2FJava-thread-7-kinds-of-state%2F</url>
      <content type="text"><![CDATA[明知对要做的事情进行拖延，它所消耗的心理能量会远远多于做事情本身 本篇感性地介绍一下 Java 线程的七种状态以及状态之间的转换 Java 线程状态转换图 Java 线程状态转换图 Java 线程状态在 Java 线程的生命周期中，按复杂的并发场景考虑，可将 Java 线程的状态分为七种，分别是：新建（New），可运行（Runnable 或 Ready），运行（Running），无限期等待（Waiting），限期等待（Timed Waiting），阻塞（Blocked），结束（Terminated）。 新建（New）状态新创建一个线程对象，尚未执行。 可运行（Runnable 或 Ready）状态新创建的线程调用 start 方法后便处于 Runnable 状态，刚刚结束等待（获取到锁）或刚结束阻塞状态的线程也会处于 Runnable 状态，处于该状态的线程位于可运行线程池中，等待获取 CPU 资源。 运行（Running）状态处于 Runnable 状态的线程获取到 CPU 资源，执行程序代码。 无限期等待（Waiting）状态synchronized 代码块内被锁住的对象调用了它的 wait() 方法或者在当前线程中调用了其他线程的 join() 方法，那么当前线程将会释放占有的锁，释放 CPU 资源，阻塞在等待队列里面，一直等待被 synchronized 修饰的对象调用 notify() 或 notifyAll() 方法唤醒或者 join 的其他线程执行结束（异常退出）。在并发时，处于无限期等待状态的线程被唤醒之后，还要去竞争对象的锁，如果竞争不到，线程将会被阻塞在对象的锁池中，竞争到锁之后，线程将会处于 Runnable 状态。 限期等待（Timed Waiting）状态与无限期等待（Waiting）状态不同之处在于，调用 wait 和 join 方法时传入了等待限定时间。另外，线程调用 sleep() 方法也会处于限期等待（Timed Waiting）状态，会释放 CPU 资源，但并不会释放锁，一直到休眠结束变成 Runnable 状态。 阻塞（Blocked）状态线程程序执行到 synchronized 代码块或 Reentrant.lock() 方法，对象的锁被其他线程占用时，当前线程将会被阻塞在对象的锁池中，处于阻塞（Blocked）状态。 结束（Terminated）状态线程 run 方法执行完毕或者异常退出，则该线程的生命周期终结，不能再次使用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java 虚拟机基础知识（二）]]></title>
      <url>%2F2017%2F07%2F20%2FBasic-knowledge-of-JVM-GC%2F</url>
      <content type="text"><![CDATA[一切努力都应该指向现实，给生活带来直接、可触碰的变化 本篇是 Java 虚拟机系列的第二篇，主要介绍 Java 虚拟机垃圾回收机制。 JVM 垃圾回收机制理解 JVM 垃圾回收机制需要弄清楚两个问题： 什么是垃圾，或者怎么判定垃圾？ 怎么回收，或者通过什么方式回收垃圾？ 什么是垃圾，或者怎么判定垃圾？“垃圾”即不再存活的对象，判定对象是否存活，一般有两种方法： 引用计数算法 可达性分析算法 引用计数算法为每一个创建的对象分配一个引用计数器，用来存储该对象被引用的个数。当有一个地方引用它，引用计数器就加 1 ；当引用失效，引用计数器就减 1 ；当引用计数器为 0 ，意味这个对象没有被使用，可以认为“对象死去”。 但是，引用计数算法很难检测出对象之间的循环引用，当两个对象互相引用，即时它俩都不被外界任何东西引用，它俩的计数都不为零，因此永远不会被回收。所以， JVM 并没有用此方案来检测对象是否存活。 可达性分析算法可达性分析算法的基本思路是以一系列 GC Roots 对象为起点出发，然后向下搜索，搜索所走过的路经称为引用链，处在引用链上的对象称为可达对象，或存活对象；而当一个对象到 GC Roots 对象没有任何引用链相连，则被视为不可达对象，或垃圾。JVM 采用可达性分析算法判断对象是否存活。 可达性分析算法判断对象是否存活JVM 中哪些对象可以作为 GC Roots？GC Roots 对象本身一定是可达的，这样从它们出发遍历到的对象才能保证一定可达。一般有如下几种： 虚拟机栈（帧栈中的本地变量表）中引用的对象。 方法区中静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中 JNI 引用的对象。 通过什么方式回收垃圾？常用的垃圾回收方式有： 标记-清除算法 (Mark-Sweep) 标记-整理算法 (Mark-Compact) 复制算法 (Copying) 分代收集算法 (Generational Collection) 标记-清除算法 (Mark-Sweep)基本原理：先标记出需要回收的对象，然后一并回收被标记过的对象。 通过可达性分析算法判定对象不可用，是标记的第一步，如果对象已经被标记一次，它将被进行一次筛选，筛选条件为对象是否重写了 finalize() 方法，或者 finalize() 已经被虚拟机调用。当对象没重写或 finalize() 已经被执行过，就证明对象已经没有可能再回到可用状态，待虚拟机第二次标记它时，就会被放到回收的集合中。 标记-清除算法缺点： 效率低，标记和清除两个过程的效率都不高 易产生内存碎片，标记清除之后会导致内存中出现大量的不连续的内存碎片，之后分配较大对象的内存空间时，导致没有足够的连续内存，可能会触发另一次的垃圾回收，这个问题也间接的反映出了效率不高。当然， JVM 并不是只用这一个算法去回收垃圾，而是在对象存活率较高的时候，使用这个算法。 标记-整理算法 (Mark-Compact)标记-整理算法可以说是标记-清除算法的完善版，标记-清除算法容易产生内存碎片。标记-整理算法是在标记后，将所有存活的对象都向一端移动，然后再清理掉边界以外的内存。 复制算法 (Copying)复制算法的基本思想是将可用内存容量划分为大小相等的两块，每次只用其中的一块，当这块内存用完了，就将还存活的对象复制到另一块上，然后清除已使用的那块。这样每次固定回收一半内存，实现简单，运行高效，并且不会出现内存碎片。这个算法的代价也很大，就是要牺牲一半的内存。主流的商业虚拟机一般采用复制算法来回收新生代，因为新生代里的对象 98% 都是“朝生夕死”，所以并不需要按照 1：1 的比例划分内存空间。一般新生代只有 10% （不绝对）左右的对象存活，虚拟机的划分比例往往高于 8：1 。 分代收集算法 (Generational Collection)目前主流的商业虚拟机均采用分代收集算法，根据对象存活周期的不同将内存划分为几块，一般分为新生代和老年代。 新生代：对象存活率低，每次垃圾回收后都只有少量对象存活，因此适合用复制算法。 老年代：对象存活率高，适合使用标记-清除或者标记-整理算法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 设计模式之代理模式]]></title>
      <url>%2F2017%2F07%2F07%2FAndroid-design-pattern-Proxy-pattern%2F</url>
      <content type="text"><![CDATA[生活中的很多烦恼都源于盲目的攀比，而忘了享受自己的生活 本文是 Android 设计模式的第五篇，接下来会陆续推出整个常用的设计模式系列。本篇主要介绍一下在 Android 开发中无所不在的一种设计模式 – 代理模式。说它无所不在，主要是因为 Android 四大组件的创建和使用均会涉及与 Framework 层进行频繁的 IPC ，而 Binder IPC 模型使用的就是代理模式。 代理模式代理模式（Proxy Pattern）：为访问对象提供一个代理对象来实现对被访问者的访问，其实就是在访问对象与被访问对象之间添加一个中介，用来隔离访问者与被访问者的具体实现细节。它是一种结构型设计模式。 模式结构 抽象对象：声明了目标对象和代理对象的共同接口； 目标对象：被代理或者被访问的对象； 代理对象：代理对象内部持有目标对象的引用，代理对象与目标对象实现相同的接口， Client 访问代理对象相当于间接访问目标对象。 图片来自于网络 模式实现下面是一个非常简单的例子。 抽象对象123interface CommonInterface &#123; fun operate(str: String)&#125; 目标对象12345class SubjectObj : CommonInterface &#123; override fun operate(str: String) &#123; println("目标对象 : $str") &#125;&#125; 代理对象123456class ProxyObj(private val subjectObj: SubjectObj) : CommonInterface &#123; override fun operate(str: String) &#123; println("代理对象 : 调用目标对象") subjectObj.operate(str) &#125;&#125; Client123456fun main(args: Array&lt;String&gt;) &#123; val subjectObj = SubjectObj() val proxyObj = ProxyObj(subjectObj) proxyObj.operate("执行操作")&#125; Running12代理对象 : 调用目标对象目标对象 : 执行操作 Android 中的代理模式Android Binder 类是实现进程间通信的媒介，由于进程间通信贯穿四大组件使用的始末，所以在 Android 开发过程中进程间通信随处可见，而 Android Binder IPC 模型是基于代理模式。 Android Binder IPC 通信模型： Client : 持有 Server 的本地 Binder 对象的代理对象； Server : 持有本地 Binder 对象，为 Client 端提供功能性服务； ServiceManager : 负责管理 Binder 服务，可以根据 Binder Name 获取 Binder 引用，功能类似于 DNS 服务器； Binder 驱动 : Client 与 Server ，以及 Server 与 ServiceManager 之间的通信都会经过 Binder 驱动，维持 Binder Proxy 与 Binder 实体引用之间的映射，根据 Client 端由 Binder Proxy 打包发送过来数据包，调用 Server 方法，再将返回结果打包由 Binder Proxy 传回 Client 端。 下面实现一个最简单的 Binder IPC 模型： 抽象对象接口1234public interface RemoteCompute extends android.os.IInterface &#123; // 实现一个远程加法调用，并将结果返回给 Client 端 public int remoteAdd(int arg1, int arg2) throws android.os.RemoteException;&#125; 目标对象（Binder 本地对象）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Stub 就是 Binder 本地对象，它的方法是在 Server 进程中执行。 public static abstract class Stub extends android.os.Binder implements RemoteCompute &#123; private static final java.lang.String DESCRIPTOR = "cn.haohao.ipc.ICompute"; /** * Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an cn.haohao.ipc.ICompute interface, * generating a proxy if needed. */ public static RemoteCompute asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof RemoteCompute))) &#123; return ((RemoteCompute) iin); &#125; return new RemoteCompute.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_remoteAdd: &#123; data.enforceInterface(DESCRIPTOR); int _arg0; _arg0 = data.readInt(); int _arg1; _arg1 = data.readInt(); int _result = this.remoteAdd(_arg0, _arg1); reply.writeNoException(); reply.writeInt(_result); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; static final int TRANSACTION_remoteAdd = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);&#125; 代理对象1234567891011121314151617181920212223242526272829303132333435363738// 在 IPC 时 Proxy 对象只是持有 Binder Proxy 对象的引用，严格来说它是间接的代理。// Proxy 负责打包 Client 端的请求参数，发送给 Binder 驱动，由 Binder 驱动调用 Server 端本地 Binder 对象解析数据并执行对应的操作，同时 Client 端线程挂起，当 Server 端方法执行完毕后，再将返回结果打包，通过 Binder 驱动传回到 Client 端的 Binder Proxy，Binder Proxy 会解析数据包中的内容并将原始结果返回给 Client 端。private static class Proxy implements RemoteCompute &#123; private android.os.IBinder mRemote; // IPC 时由 Binder 驱动返回的 Binder Proxy (Binder 代理对象) Proxy(android.os.IBinder remote) &#123; mRemote = remote; Log.d(TAG, "Proxy: remote : " + mRemote); &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; @Override public int remoteAdd(int arg1, int arg2) throws android.os.RemoteException &#123; Log.d(TAG, "remoteAdd() called with: arg1 = [" + arg1 + "], arg2 = [" + arg2 + "]"); android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); int _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeInt(arg1); _data.writeInt(arg2); mRemote.transact(Stub.TRANSACTION_remoteAdd, _data, _reply, 0); _reply.readException(); _result = _reply.readInt(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125;&#125; Client12345678910111213private ServiceConnection mConn = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; // 在 IPC 时，service 就是 Binder 驱动返回的 Binder Proxy 对象的引用。 remoteCompute = RemoteCompute.Stub.asInterface(service); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125;&#125;;// 调用远程方法int result = remoteCompute.remoteAdd(88, 12); 代理模式的优点和缺点优点 降低访问者与被访问者之间的耦合度 可以控制访问者对被访问者的访问权限 虚拟代理通过使用一个小对象来代理一个大对象，可以减少系统开销 缺点 代理对象会增加逻辑的复杂度 减慢对目标对象的访问速度]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 系统启动流程]]></title>
      <url>%2F2017%2F07%2F04%2FAndroid-system-boot-process%2F</url>
      <content type="text"><![CDATA[凡事都往好的一面去想，这种习惯比收入千磅还好 对于 Android 系统的启动流程，每一位 Android Developer 都应该烂熟于心，它在某种程度上代表着 Android 开发的学习路线。本篇感性地介绍一下 Android 系统的启动流程。 Android 系统启动流程示意图图片来自于网络 启动过程： Loader -&gt; Kernel -&gt; Native -&gt; Framework -&gt; App 。 Android 系统启动过程LoaderLoader 层执行过程分为两步： Android 设备上电以后，引导芯片执行固化在 Boot ROM 里的启动引导代码，加载 Boot Loader 代码到内存； Boot Loader 代码开始执行，检查 RAM ，完成硬件的初始化，加载Linux内核代码到内存。 KernelLinux 内核开始启动，初始化各种软硬件环境，加载驱动程序，挂载根文件系统，执行init程序。 Native init 进程 fork 出 logd 、 healthd 、 installd 、 adbd 等用户守护进程； 启动 ServiceManager 和 MediaServer（本地服务）； fork 出 Zygote 进程，Zygote 进程是所有 Java 进程的父进程。 FrameworkFramework 层由 C++ Framework 层和 Java Framework 层组成。 C++ Framework 层C++ Framework 层主要运行本地服务，即 MediaServer 进程，它是由 init 进程 fork 而来，负责启动和管理整个 C++ framework ，包含 AudioFlinger ，Camera Service 等服务。 Java Framework 层Java Framework 层主要运行 SystemServer 进程，SystemServer 进程是 Zygote 进程 fork 出的第一个 Java 进程，SystemServer 负责启动和管理 Java Framework ，主要管理 Android 服务，如 ActivityManagerService ，NotificationManagerService ，WindowManagerService 等，它们均以线程的方式运行在 SystemServer 进程中。 AppZygote 进程 fork 出来的第一个 App 进程是 Launcher ，即桌面 App ，所有的 App 进程都是由 Zygote 进程 fork 生成的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RxJava for Kotlin 实践（三）]]></title>
      <url>%2F2017%2F07%2F01%2FRxJava-to-Kotlin-Util-and-Operator%2F</url>
      <content type="text"><![CDATA[我们很少想我们已经拥有的，而总是想我们所没有的 本篇是 RxJava for Kotlin 系列的第三篇，本系列从可观察系列的创建、组合变换以及监听的实践入手，最后一直到 RxJava 的实现原理分析。 上一篇主要介绍了 RxJava 可观察序列常用的组合和变换方式，本篇主要简单介绍可观察序列在生产和消费时线程的转换方式以及如何自定义 RxJava 操作符。 RxJava 线程转换RxJava 的精髓在于它的异步处理，可以轻松实现线程切换。 RxJava 常用线程切换操作符： subscribeOn ，observeOn 。 subscribeOn : 指定 Observable 自身在哪个调度器上执行，即指定生产者所在的线程。 observeOn : 指定一个观察者在哪个调度器上观察这个 Observable 即指定消费者所在的线程. 另外还有一个常用的操作符 doOnNext ，事件序列被消费之前，注册一个回调，接收 Observable 发射的每一项数据，但是不消费事件。通常在事件被消费之前做一些保存操作，例如，在进行网络请求时，对响应数据做一下缓存操作。 一个简单的线程切换例子：12345678910111213141516fun main(args: Array&lt;String&gt;) &#123; /* * observeOn 指定一个观察者在哪个调度器上观察这个 Observable 即指定消费者所在的线程。 * * subscribeOn 指定 Observable 自身在哪个调度器上执行，即指定生产者所在的线程。 * * doOnNext 事件序列被消费之前，注册一个回调，接收 Observable 发射的每一项数据，但是不消费事件。 * */ Observable.from(arrayOf("Hello Kotlin", "Hello RxJava", "Hello Android")) .doOnNext &#123; println("$&#123;Thread.currentThread().name&#125; : $it") &#125; .subscribeOn(Schedulers.io()) .observeOn(Schedulers.newThread()) .subscribe&#123; p -&gt; println("$&#123;Thread.currentThread().name&#125; : $p") &#125;&#125; 输出：123456RxIoScheduler-2 : Hello KotlinRxIoScheduler-2 : Hello RxJavaRxIoScheduler-2 : Hello AndroidRxNewThreadScheduler-1 : Hello KotlinRxNewThreadScheduler-1 : Hello RxJavaRxNewThreadScheduler-1 : Hello Android 自定义操作符RxJava 提供了接口 Operator 和 Transformer 接口用于轻松实现自定义操作符。 自定义序列操作符这里需要说一下 lift 操作符，它可以将我们自定义的操作符和其它的操作符一起做链式调用。12345678910111213141516171819202122232425262728293031323334353637//序列操作符class MyOperator(private val name: String) : Observable.Operator&lt;String, String&gt; &#123; override fun call(p0: Subscriber&lt;in String&gt;): Subscriber&lt;in String&gt; &#123; return object : Subscriber&lt;String&gt;(p0) &#123; override fun onError(t: Throwable?) &#123; if (!p0.isUnsubscribed) &#123; p0.onError(t) &#125; &#125; override fun onCompleted() &#123; if (!p0.isUnsubscribed) &#123; p0.onCompleted() &#125; &#125; override fun onNext(t: String?) &#123; // 对每一项进行简单的标记打印操作 if (!p0.isUnsubscribed) &#123; println("$name : $t") p0.onNext(t) &#125; &#125; &#125; &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; Observable.from(arrayOf("Hello Kotlin", "Hello RxJava", "Hello Android")) .lift(MyOperator("Opt-1")) .lift(MyOperator("Opt-2")) .subscribe&#123; println(it) &#125;&#125; 输出：123456MyOperator : Hello KotlinHello KotlinMyOperator : Hello RxJavaHello RxJavaMyOperator : Hello AndroidHello Android 自定义变换操作符这里需要说一下 compose 操作符，它同 lift 操作符类似，可以将自定义操作符与标准的 RxJava 操作符一起使用。123456789101112131415// 变换操作符class MyTransformer(private val name: String) : Observable.Transformer&lt;Int, String&gt; &#123; override fun call(p0: Observable&lt;Int&gt;): Observable&lt;String&gt; = p0.map &#123; "$name : $it" &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; Observable.from(arrayOf(123, 456, 789)) .compose(MyTransformer("Transformer-1")) .subscribe&#123; println(it) &#125;&#125; 输出：123Transformer-1 : 123Transformer-1 : 456Transformer-1 : 789]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java 虚拟机基础知识（一）]]></title>
      <url>%2F2017%2F06%2F24%2FBasic-knowledge-of-JVM%2F</url>
      <content type="text"><![CDATA[唯有进入经常失败的未知空间，才能产生创造力 本篇主要介绍 Java 虚拟机运行时内存区域的划分。 Java 虚拟机特性Java 虚拟机具有两大特性： 平台无关性。Java 虚拟机屏蔽了与具体操作系统平台相关的信息，使得 Java 语言编译程序只需生成在 Java 虚拟机上运行的目标代码(字节码)，就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。 语言无关性。Java 虚拟机不和包括 Java 在内的任何语言绑定，它只与 .class 文件这种特定的二进制文件格式相关联，而 Java 虚拟机不关心 .class 文件的来源。基于这一特性出现了很多运行在 JVM 之上的编程语言，如 Groovy ， JRuby， Jyphon， Scala 等。 Java 虚拟机运行时内存区域划分由图所示，Java 虚拟机将运行时数据区划分为 5 块，分别是： Java 堆， 方法区（静态存储区），虚拟机栈，本地方法栈以及程序计数器。 图片来自极客学院 Java 堆Java 堆是 JVM 所管理内存中的最大的一块，Java 堆是被一个虚拟机内所有线程共享的内存区域，它在虚拟机启动时创建。 Java 堆唯一的目的就是存放对象实例，绝大部分对象实例和数组都要在堆上分配。Java 堆可以处于物理上不连续的内存空间，只需保证逻辑上连续即可。如果在堆中没有完成实例的内存分配，并且堆也无法再扩展，将会抛出 OutOfMemoryError 异常。 方法区（静态存储区）方法区也是线程间共享内存区域，用于存储已被虚拟机加载的类信息，常量，静态变量以及即时编译器编译后的代码等数据。 方法区可以处于物理上不连续的内存空间。当方法区无法满足内存分配需求时，将会抛出 OutOfMemoryError 异常。 Java 虚拟机栈Java 虚拟机栈为线程私有内存区域，生命周期与线程相同。 Java 虚拟机栈描述的是 Java 方法执行的内存模型，每个方法执行的同时都会创建一个栈帧，主要用于存储局部变量表，操作数栈，动态链接，方法出口信息。每一个方法从调用到直至执行完的过程，都对应着一个栈帧在虚拟机栈入栈和出栈的过程。 Java 虚拟机规范中对 Java 虚拟机栈规定了两种异常情况： 线程请求的栈深度大于虚拟机所允许的深度，将会抛出 StackOverflowError 异常，（不过现在大多数虚拟机都支持虚拟机栈的动态扩展）； 虚拟机栈在进行扩展时无法申请到足够的内存，将会抛出 OOM 异常。 局部变量表局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，其中存放的数据的类型是编译期可知的各种基本数据类型、对象引用（reference）和 returnAddress 类型（它指向了一条字节码指令的地址）。 局部变量表所需的内存空间在编译期间完成分配，即在 Java 程序被编译成 Class 文件时，就确定了所需分配的最大局部变量表的容量。当进入一个方法时，这个方法需要在栈中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 操作数栈操作数栈又常被称为操作栈，操作数栈的最大深度也是在编译的时候就确定了。 动态链接一般来说，方法正常退出时，调用者的程序计数器的值就可以作为返回地址，栈帧中很可能保存了这个计数器值，而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。 本地方法栈 （Native Method Stack）本地方法栈与 Java 虚拟机栈的作用非常相似，虚拟栈为虚拟机执行的 Java 方法服务，本地方法栈则为使用到的 Native 方法服务。 与虚拟机栈一样，本地方法栈也会抛出 StackOverflowError 和 OutOfMemoryError 异常。 程序计数器程序计数器为一小块线程私有的内存空间，可以看成当前线程所执行字节码的行号指示器。 程序计数器存在的意义是确保线程切换后或者线程被 CPU 重新调度后，恢复到正确的执行位置。如果一个线程执行的 Java 方法，程序计数器记录的是正在执行的虚拟机字节码指令的位置；如果正在执行的是 Native 方法，则计数器的值为空。程序计数器存储区域是 JVM 规范中没有规定任何 OutOfMemoeyError 情况的唯一一块区域。 直接内存直接内存不是虚拟机运行时数据区域的一部分，也不是 Java 虚拟机规范中定义的内存区域，但这部分内存也被频繁使用，也是可能导致 OutOfMemoryError 异常的内存区域。 在 JDK1.4 中新引入了 NIO 机制，它是一种基于通道与缓冲区的新 I/O 方式，可以直接从操作系统中分配直接内存，即在堆外分配内存，这样能在一些场景中提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RxJava for Kotlin 实践（二）]]></title>
      <url>%2F2017%2F06%2F17%2FRxJava-for-Kotlin-practice-transforming-and-combining%2F</url>
      <content type="text"><![CDATA[放下执着，却又成了新的执着 本篇是 RxJava for Kotlin 系列的第二篇，本系列从可观察系列的创建、组合变换以及监听的实践入手，最后一直到 RxJava 的实现原理分析。上一篇主要介绍了 RxJava 可观察序列常用的创建方式，本篇主要简单介绍观察序列的组合变换以及过滤操作，掌握 RxJava 可观察序列的组合变换以及过滤操作，才能真正体会 Rx 之美。 RxJava 可观察序列的变换常用的操作符 map() : 对序列的每一项都应用一个函数来变换 Observable 发射的数据序列； flatMap() : concatMap() : 将 Observable 发射的数据集合变换为 Observables 集合，然后将这些 Observable 发射的数据平坦化的放进一个单独的 Observable ； scan() ： 对 Observable 发射的每一项数据应用一个函数，然后按顺序依次发射每一个值； groupBy() : 将 Observable 分拆为 Observable 集合，将原始 Observable 发射的数据按 Key 分组，每一个 Observable 发射一组不同的数据； cast() : 在发射之前强制将 Observable 发射的所有数据转换为指定类型. mapmap 对 Observable 发射的每一项数据应用一个函数，执行变换操作。12345fun main(args: Array&lt;String&gt;) &#123; Observable.from(arrayOf("Kotlin", "iOS", "Java", "Objective-c")) .map &#123; it -&gt; "Hello $it" &#125; .subscribe&#123; p -&gt; println(p) &#125;&#125; 输出：1234Hello KotlinHello iOSHello JavaHello Objective-c flatMapflatMap 将一个发射数据的 Observable 变换为多个 Observables ，然后将它们发射的数据合并(不一定按次序)后放进一个单独的 Observable 。123456789fun main(args: Array&lt;String&gt;) &#123; val list1 = arrayOf("Kotlin", "iOS") val list2 = arrayOf("Java", "Objective-c") val collections = arrayOf(list1, list2) Observable.from(collections) .flatMap &#123; it -&gt; Observable.from(it) &#125; .map &#123; it -&gt; "Hello $it" &#125; .subscribe&#123; p -&gt; println(p) &#125;&#125; 输出：1234Hello KotlinHello iOSHello JavaHello Objective-c concatMapconcatMap 类似于最简单版本的 flatMap ，但是它按次序连接而不是合并那些生成的 Observables ，然后产生自己的数据序列。123456789fun main(args: Array&lt;String&gt;) &#123; val list1 = arrayOf("Kotlin", "iOS") val list2 = arrayOf("Java", "Objective-c") val collections = arrayOf(list1, list2) Observable.from(collections) .concatMap &#123; it -&gt; Observable.from(it) &#125; .map &#123; it -&gt; "Hello $it" &#125; .subscribe&#123; p -&gt; println(p) &#125;&#125; 输出：1234Hello KotlinHello iOSHello JavaHello Objective-c scanscan 连续地对数据序列的每一项应用一个函数，然后连续发射结果。12345fun main(args: Array&lt;String&gt;) &#123; Observable.from(arrayOf(1, 2, 3, 4)) .scan &#123; p0, p1 -&gt; p0 + p1 &#125; .subscribe&#123; p -&gt; println(p) &#125;&#125; 输出：123413610 RxJava 可观察序列的过滤常用的操作符 filter() : 过滤数据； takeLast() : 只发射最后的 N 项数据； last() ： 只发射最后的一项数据； skip() : 跳过开始的 N 项数据； skipLast() : 跳过最后的 N 项数据； take() : 只发射开始的 N 项数据； elementAt() : 发射第 N 项数据。 filter12345fun main(args: Array&lt;String&gt;) &#123; Observable.from(arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) .filter &#123; it &gt; 5 &amp;&amp; it % 2 == 0 &#125; .subscribe&#123; println(it) &#125;&#125; 输出：1236810 takeLast12345fun main(args: Array&lt;String&gt;) &#123; Observable.from(arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) .takeLast(5) .subscribe&#123; println(it) &#125;&#125; 输出：12345678910 take12345fun main(args: Array&lt;String&gt;) &#123; Observable.from(arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) .take(5) .subscribe&#123; println(it) &#125;&#125; 输出：1234512345 skip12345fun main(args: Array&lt;String&gt;) &#123; Observable.from(arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) .skip(5) .subscribe&#123; println(it) &#125;&#125; 输出：12345678910 elementAt12345fun main(args: Array&lt;String&gt;) &#123; Observable.from(arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) .elementAt(5) .subscribe&#123; println(it) &#125;&#125; 输出：16 RxJava 可观察序列的组合常用的操作符 startWith() : 在数据序列的开头增加一项数据； merge() : 将多个 Observable 合并为一个； zip() ： 使用一个函数组合多个 Observable 发射的数据集合，然后再发射这个结果； switchOnNext() : 将一个发射 Observables 的 Observable 转换成另一个 Observable ，后者发射这些 Observables 最近发射的数据。 startWithstartWith 在数据序列的开头插入一条指定的项。12345fun main(args: Array&lt;String&gt;) &#123; Observable.from(arrayOf("Hello Java", "Hello RxJava")) .startWith("Hello Kotlin") .subscribe&#123; p -&gt; println(p) &#125;&#125; 输出：123Hello KotlinHello JavaHello RxJava mergemerge 合并多个 Observables 的发射物。123456fun main(args: Array&lt;String&gt;) &#123; val observable1 = Observable.from(arrayOf(1, 2, 3)) val observable2 = Observable.from(arrayOf(4, 5, 6, 7)) Observable.merge(observable1, observable2) .subscribe&#123; p -&gt; println(p) &#125;&#125; 输出：123Hello KotlinHello JavaHello RxJava zip zip 通过一个函数将多个 Observables 的发射物结合到一起，基于这个函数的结果为每个结合体发射单个数据项。12345678fun main(args: Array&lt;String&gt;) &#123; val observable1 = Observable.from(arrayOf(1, 2, 3)) val observable2 = Observable.from(arrayOf(4, 5, 6, 7)) Observable.zip(observable1, observable2) &#123; p0, p1 -&gt; p0 + p1 &#125;.subscribe&#123; println(it) &#125;&#125; 输出：123579]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RxJava for Kotlin 实践（一）]]></title>
      <url>%2F2017%2F06%2F13%2FRxJava-for-Kotlin-practice-Creating-Observable%2F</url>
      <content type="text"><![CDATA[从 RxJava 开始拆轮子 本篇是 RxJava for Kotlin 系列的开篇，本系列从可观察系列的创建、组合变换以及监听的实践入手，最后一直到 RxJava 的实现原理分析。本篇主要简单介绍 RxJava 以及可观察序列的创建方式 RxJava 简介Rx 是 Reactive Extensions 的缩写，最初是 LINQ （语言集成查询）的一个扩展，由微软的架构师 Erik Meijer 领导的团队开发，在 2012 年开源，Rx 是一个编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流， Rx 库支持 .NET 、 JavaScript 和 C++，比较流行的有 RxJava， RxJS ，以及 Rx.NET 。 Rx 是一个函数库，开发者可以用 Observables 表示异步数据流，用 LINQ 操作符查询异步数据流， 用 Schedulers 参数化异步数据流的并发处理， Rx 可以这样定义：Rx = Observables + LINQ + Schedulers 。 官方对 RxJava 的定义： Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.用于使用 Java VM 的可观察序列编写异步和基于事件的程序的库。 RxJava 同其他 Rx 系列一样，其使用过程可分为三步： 创建： 通过 RxJava API 创建可观察事件序列或者数据流； 组合变换： 通过 LINQ 式操作符对事件序列或者数据流进行组合以及变换操作，实现业务逻辑； 监听： 通过订阅可观察观察事件序列或者数据流，可以获取组合变换的结果或者执行其他的操作。 RxJava 设计模式RxJava 是基于观察者模式，在 RxJava 中有四种角色： Observable （被观察者），一般指可观察事件序列或者数据流； Observer （观察者），用于监听可观察事件序列或者数据流； Subscriber （订阅者），基于 Observer 进行扩展，可取消订阅； Subject （主题），即可作为观察者，也可作为被观察者。 对比一下 Observer 和 Subscriber 源码，它们之间的关系一目了然。 Observer: 1234567public interface Observer&lt;T&gt; &#123; void onCompleted(); void onError(Throwable var1); void onNext(T var1);&#125; Subscriber: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public abstract class Subscriber&lt;T&gt; implements Observer&lt;T&gt;, Subscription &#123; private static final long NOT_SET = -9223372036854775808L; private final SubscriptionList subscriptions; private final Subscriber&lt;?&gt; subscriber; private Producer producer; private long requested; protected Subscriber() &#123; this((Subscriber)null, false); &#125; protected Subscriber(Subscriber&lt;?&gt; subscriber) &#123; this(subscriber, true); &#125; protected Subscriber(Subscriber&lt;?&gt; subscriber, boolean shareSubscriptions) &#123; this.requested = -9223372036854775808L; this.subscriber = subscriber; this.subscriptions = shareSubscriptions &amp;&amp; subscriber != null?subscriber.subscriptions:new SubscriptionList(); &#125; public final void add(Subscription s) &#123; this.subscriptions.add(s); &#125; public final void unsubscribe() &#123; this.subscriptions.unsubscribe(); &#125; public final boolean isUnsubscribed() &#123; return this.subscriptions.isUnsubscribed(); &#125; public void onStart() &#123; &#125; protected final void request(long n) &#123; ... &#125; private void addToRequested(long n) &#123; ... &#125; public void setProducer(Producer p) &#123; ... &#125;&#125; Subscription:12345public interface Subscription &#123; void unsubscribe(); boolean isUnsubscribed();&#125; 创建可观察序列添加依赖 1compile 'io.reactivex:rxjava:1.3.0' Observable 有以下创建方式： just() ： 将一个或多个对象转换成发射这个或这些对象的一个 Observable ； from() ： 将一个 Iterable ，一个Future ，或者一个数组转换成一个 Observable ； repeat() ： 创建一个重复发射指定数据或数据序列的 Observable ； create() ： 使用一个函数从头创建一个 Observable ； repeatWhen() ： 创建一个重复发射指定数据或数据序列的 Observable ，它依赖于另一个 Observable 发射的数据； defer() ： 只有当订阅者订阅才创建 Observable ，为每个订阅创建一个新的 Observable ； range() ： 创建一个发射指定范围的整数序列的 Observable ； interval() ： 创建一个按照给定的时间间隔发射整数序列的 Observable ； timer() ： 创建一个在给定的延时之后发射单个数据的 Observable ； empty() ： 创建一个什么都不做直接通知完成的 Observable ； error() ： 创建一个什么都不做直接通知错误的 Observable ； never() ： 创建一个不发射任何数据的 Observable ； 接下来只介绍几种常用的方式。 justjust 将一个或多个对象转换成发射这个或这些对象的一个 Observable ,它接受一至九个参数，返回一个按参数列表顺序发射这些数据的 Observable 。 just 类似于from ，但是 from 会将数组或 Iterable 的数据取出然后逐个发射，而 just 只是简单的原样发射，将数组或 Iterable 当做单个数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849fun main(args: Array&lt;String&gt;) &#123; val observable = Observable.just("Hello Kotlin", "Hello RxJava", "Android") // 被观察者 val subscriber = object : Subscriber&lt;String&gt;()&#123; override fun onStart() &#123; super.onStart() &#125; override fun onError(p0: Throwable?) &#123; //当 Observable 遇到错误或者无法返回期望的数据时会调用这个方法， //这个调用会终止 Observable，后续不会再调用 onNext 和 onCompleted println("onError") &#125; override fun onCompleted() &#123; //数据发射正常终止 println("onCompleted") &#125; override fun onNext(p0: String?) &#123; //Observable 调用这个方法发射数据，方法的参数就是 Observable 发射的数据 println(p0) &#125; &#125; // 观察者 observable.subscribe(subscriber) // 订阅 // 或者用更简洁的方式 Observable.just("Hello Kotlin", "Hello RxJava", "Android") .subscribe(object : Subscriber&lt;String&gt;()&#123; override fun onError(p0: Throwable?) &#123; println("onError") &#125; override fun onCompleted() &#123; println("onCompleted") &#125; override fun onNext(p0: String?) &#123; println(p0) &#125; &#125;)&#125; 输出： 1234Hello KotlinHello RxJavaAndroidonCompleted fromfrom 将一个 Iterable, 一个 Future , 或者一个数组转换成一个 Observable 。1234567891011121314151617fun main(args: Array&lt;String&gt;) &#123; Observable.from(arrayOf("Hello Kotlin", "Hello RxJava", "Android")) .subscribe(object : Subscriber&lt;String&gt;() &#123; override fun onError(p0: Throwable?) &#123; &#125; override fun onNext(p0: String?) &#123; println(p0) &#125; override fun onCompleted() &#123; println("onCompleted") &#125; &#125;)&#125; 输出： 123Hello KotlinHello RxJavaAndroid repeatrepeat 创建一个重复发射指定数据或数据序列的 Observable 。 12345fun main(args: Array&lt;String&gt;) &#123; Observable.just("Hello Kotlin") .repeat(3) // 重复次数 .subscribe&#123; p -&gt; println(p) &#125;&#125; 输出： 123Hello KotlinHello KotlinHello Kotlin createcreate 使用一个函数从头创建一个 Observable 。建议你在传递给 create 方法的函数中检查观察者的 isUnsubscribed 状态，以便在没有观察者的时候，让你的 Observable 停止发射数据或者做昂贵的运算。 1234567891011121314151617181920212223242526fun main(args: Array&lt;String&gt;) &#123; Observable.create(Observable.OnSubscribe&lt;String&gt; &#123; observer -&gt; if (!observer.isUnsubscribed) &#123; observer.onNext("Hello RxJava") observer.onNext("Hello Kotlin") observer.onCompleted() &#125; else &#123; observer.onError(Throwable("No subscriber!")) &#125; &#125;).subscribe(object : Subscriber&lt;String&gt;()&#123; override fun onError(p0: Throwable?) &#123; println("onError") &#125; override fun onCompleted() &#123; println("onCompleted") &#125; override fun onNext(p0: String?) &#123; println(p0) &#125; &#125;)&#125; 输出： 123Hello RxJavaHello KotlinonCompleted rangerange 操作符发射一个一定范围内的有序整数序列，可以指定范围的起始和长度。1234fun main(args: Array&lt;String&gt;) &#123; Observable.range(0,10) .subscribe&#123; p -&gt; println(p) &#125;&#125; 输出： 123456789100123456789]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Design Pattern - flyweight pattern]]></title>
      <url>%2F2017%2F06%2F12%2FDesign-Pattern-flyweight-pattern%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 设计模式之观察者模式]]></title>
      <url>%2F2017%2F06%2F04%2FAndroid-design-pattern-observer-pattern%2F</url>
      <content type="text"><![CDATA[2017 下半年，决定虐自己一把！ 本篇开始将使用 Kotlin 代替 Java 来完成设计模式的示例，达到既学习了 Kotlin 语法，由复习了面向对象语言的设计模式。本文是 Android 设计模式的第四篇，接下来会陆续推出整个常用的设计模式系列。 观察者模式观察者模式 (Observer Pattern) ， 顾名思义，定义了对象间的一种一对多的关系，当被观察者对象发生改变，与其依赖的观察者对象都会得到通知，因此又叫做发布-订阅模式 (Publish/Subscribe) 模式。 需要注意的是观察者模式是一种对象行为模式。 模式结构 Subject： 目标（被观察者） ConcreteSubject： 具体目标（具体被观察者） Observer：观察者 ConcreteObserver：具体观察者 盗图 模式实现接下来在实例中我们以常见警匪电影中的坏蛋 (BadGuy) 作为 Observable ，以卧底警察 （Undercover）和普通警察 （PoliceMan）作为 Observer 。 SubjectJava 开发包中的 Observable 类，基本实现就是用一个 Vector 来接受所有的观察者，当被观察者的状态发生改变的时候，遍历 Vector 容器，通知每一个观察者。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Observable &#123; private boolean changed = false; private Vector&lt;Observer&gt; obs; /** Construct an Observable with zero Observers. */ public Observable() &#123; obs = new Vector&lt;&gt;(); &#125; public synchronized void addObserver(Observer o) &#123; if (o == null) throw new NullPointerException(); if (!obs.contains(o)) &#123; obs.addElement(o); &#125; &#125; public synchronized void deleteObserver(Observer o) &#123; obs.removeElement(o); &#125; public void notifyObservers() &#123; notifyObservers(null); &#125; public void notifyObservers(Object arg) &#123; Object[] arrLocal; synchronized (this) &#123; if (!changed) return; arrLocal = obs.toArray(); clearChanged(); &#125; for (int i = arrLocal.length-1; i&gt;=0; i--) ((Observer)arrLocal[i]).update(this, arg); &#125; public synchronized void deleteObservers() &#123; obs.removeAllElements(); &#125; protected synchronized void setChanged() &#123; changed = true; &#125; protected synchronized void clearChanged() &#123; changed = false; &#125; public synchronized boolean hasChanged() &#123; return changed; &#125; public synchronized int countObservers() &#123; return obs.size(); &#125;&#125; ConcreteSubject123456789101112131415class BadGuy : Observable() &#123; fun haveBreakfast() &#123; println("BadGuy: 开始吃饭了。。") super.setChanged() super.notifyObservers("坏蛋在吃饭") &#125; fun commitCrime() &#123; println("BadGuy: 开始犯罪了。。") super.setChanged() super.notifyObservers("坏蛋在犯罪，建议立即采取行动") &#125;&#125; Observer1234public interface Observer &#123; void update(Observable o, Object arg);&#125; ConcreteObserverUndercover.kt 卧底警察 123456789101112class UnderCover : Observer&#123; override fun update(o: Observable?, arg: Any?) &#123; println("卧底警察: 观察到疑犯活动了，赶紧报告队长！") reportLeader(arg.toString()) &#125; fun reportLeader(message: String?) &#123; println("报告队长: $message \n") &#125;&#125; PoliceMan.kt12345678910class PoliceMan : Observer&#123; override fun update(o: Observable?, arg: Any?) &#123; println("警察: 观察到疑犯活动了，赶紧报告队长！") reportLeader(arg.toString()) &#125; fun reportLeader(message: String?) &#123; println("报告队长: $message \n") &#125;&#125; Sample123456789101112fun main(args: Array&lt;String&gt;) &#123; var badGuy = BadGuy() val policeMan = PoliceMan() val underCover = UnderCover() badGuy.addObserver(policeMan) badGuy.addObserver(underCover) badGuy.haveBreakfast() badGuy.commitCrime()&#125; Running 1234567891011121314BadGuy: 开始吃饭了。。卧底警察: 观察到疑犯活动了，赶紧报告队长！报告队长: 坏蛋在吃饭 警察: 观察到疑犯活动了，赶紧报告队长！报告队长: 坏蛋在吃饭 BadGuy: 开始犯罪了。。卧底警察: 观察到疑犯活动了，赶紧报告队长！报告队长: 坏蛋在犯罪，建议立即采取行动 警察: 观察到疑犯活动了，赶紧报告队长！报告队长: 坏蛋在犯罪，建议立即采取行动 观察者模式在面向对象语言编程中应用十分广泛，如著的 Reactive Extensions (RX) 函数库，其中 RxJava ， RxAndroid 都是基于观察者模式。 在 Android 开发中，观察者模式也会被经常使用，如四大组件之一的 BroadcastReceiver 也是基于观察者模式。 观察者模式的优点和缺点优点 符合开闭原则 可以实现表示层与数据逻辑层的分离 观察者与被观察者之间的耦合是抽象的 缺点 若一个目标对象有很多观察者，遍历通知每一观察将会变得耗时太长 若目标对象与观察者对象存在循环依赖，可能会导致系统崩溃]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java to Kotlin 语法清单]]></title>
      <url>%2F2017%2F05%2F25%2FJava-to-Kotlin-Grammar-List%2F</url>
      <content type="text"><![CDATA[时刻对新事物保持好奇心 Google I/O 2017 宣布在 Android Studio 3.0 将默认支持 Kotlin 用于 Android 开发. 请注意 Google 只是宣布 Kotlin 作为 Android 开发的一级语言，并没有说要用其取代 Java ，这里很多无脑媒体进行了过度解读。作为一名合格的程序员，首先要理性看待技术迭代更新，同时要对新事物保持强烈的好奇心。 Kotlin 简介Kotlin 来自于捷克一家牛逼软件研发公司 JetBrains ，很多优秀的 IDE，如 IntelliJ IDEA、PyCharm、WebStorm 等都是它的杰作，包括 Google 官方的 Android IDE – Android Studio ，也是 IntelliJ IDEA 的插件版。 Kotlin 源于 JetBrains 的圣彼得堡团队，名称取自圣彼得堡附近的一个小岛 ( Kotlin Island ) ，JetBrains 在 2010 年首次推出 Kotlin 编程语言，并在次年将之开源。 Kotlin 的特点Kotlin 是一个基于 JVM 的编程语言，与 Java 有很深的渊源。它能与 Java 100% 互通，具备诸多 Java 尚不支持的新特性。Kotlin 可以编译成 Java 字节码，也可以编译成 JavaScript ，方便在没有 JVM 的设备上运行，可用于移动端以及 Web 开发，是一种全栈式开发语言。 Java to Kotlin下面是 Java to Kotlin 主要语法，以便于你快速认识 Kotlin 这门语言。 变量Java123String lan = "Hello Kotlin";final String lan = "Hello Kotlin"; Kotlin123var lan = "Hello Kotlin"val lan = "Hello Kotlin" 打印字符串Java123System.out.print("Hello Kotlin");System.out.println("Hello Kotlin"); Kotlin123print("Hello Kotlin");println("Hello Kotlin"); 字符串模板Java123456789String name = "haohao";int age = 25;String msg = "I am " + name + ", " + age + " years old.";String text = "Hello Kotlin\n" + "Hello Android\n" + "Hello TensorFlow"; Kotlin123456789101112var name = "haohao";var age = 25;var msg = "I am $name , $age years old.";var text = """ |Hello Kotlin |Hello Android |Hello TensorFlow """.trimMargin()// trimMargin() 去除连接符 `|` 空声明Java1String name = null; Kotlin1var name: String? = null // `?` 声明变量可为 null 判空Java1234if (name != null) &#123; int len = name.length;&#125; Kotlin1234name?.let&#123; val len = name.length&#125; 逻辑表达式Java1String y = x &gt; 6 ? "x &gt; 6" : "x &lt;= 6"; Kotlin123var y = if (x &gt; 6) "x &gt; 6" else "x &lt;= 6" 类型判断及转换Java1234if (obj instanceof Person) &#123; Person p = (Person) obj;&#125; Kotlin1234if (obj is Person) &#123; var p = obj //智能转换&#125; 区间Java123456789101112if (value &gt;= 0 &amp;&amp; value &lt;= 100) &#123;&#125;for (int i = 1; i &lt;= 100 ; i++) &#123;&#125;for (int i = 1; i &lt; 100 ; i++) &#123;&#125;for (int i = 100; i &gt;= 0 ; i--) &#123;&#125;for (int i = 1; i &lt;= 100 ; i+=2) &#123;&#125;for (int i = 100; i &gt;= 0 ; i-=2) &#123;&#125; Kotlin123456789101112if (value is 0..100) &#123;&#125;for (i in 1..100 ) &#123;&#125;for (i in 1 until 100) &#123;&#125; // 半开区间：不包含 100for (i in 100 downTo 0) &#123;&#125;for (i in 1..100 step 2) &#123;&#125;for (i in 100 donwTo 1 step 2) &#123;&#125; list 和 map ( 针对 Java 8 之前版本 )Java1234567891011121314151617181920212223242526List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4);for(Integer value : list) &#123; System.out.println(value);&#125;Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();map.put(1, "Java");map.put(2, "Kotlin");map.put(3, "iOS");map.put(4, "React Native");Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();while (iterator.hasNext()) &#123; Map.Entry&lt;Integer, String&gt; entry = iterator.next(); System.out.println(entry.getKey() + " , " + entry.getValue());&#125; Kotlin1234567891011121314151617181920var list = listOf(1, 2, 3, 4);list.forEach &#123; println(it)&#125;var map = mapOf(1 to "Java", 2 to "Kotlin", 3 to "iOS", 4 to "React Native")map.forEach &#123; key, value -&gt; println("$key, $value")&#125;// 或者for ((key, value) in map) &#123; println("$key, $value")&#125; 开关语句Java123456789101112131415161718192021222324int score = // some score;String result;switch (score) &#123; case 10: case 9: grade = "Excellent"; break; case 8: case 7: case 6: grade = "Good"; break; case 5: case 4: grade = "Ok"; break; case 3: case 2: case 1: grade = "Fail"; break; default: grade = "Fail"; &#125; Kotlin12345678910111213var score = // some scorevar grade = when (score) &#123; 9, 10 -&gt; "Excellent" in 6..8 -&gt; "Good" 4, 5 -&gt; "Ok" in 1..3 -&gt; "Fail" else -&gt; "Fail"&#125; 流水线Java1234567891011121314151617List&lt;String&gt; list = Arrays.asList("java", "c++", "Android", "Kotlin", "iOS");for(int i = 0; i &lt; list.size(); i++ ) &#123; list.set(i, "Hello " + list.get(i)); if (!list.get(i).contains("c")) &#123; System.out.println(list.get(i)); &#125;&#125;//输出：// Hello java// Hello Android// Hello Kotlin// Hello iOS Kotlin123456789101112131415161718192021var list = arrayOf("java", "c++", "Android", "Kotlin", "iOS")list.map &#123; "Hello $it"&#125;.filter &#123; !it.contains("c")&#125;.forEach &#123; println(it)&#125;//输出：// Hello java// Hello Android// Hello Kotlin// Hello iOS 函数Java123456public final void func() &#123;&#125;public final int func(int value) &#123; return 1 * value;&#125; Kotlin12345678910fun func() &#123;&#125;fun func(value: Int): Int &#123; return 1 * value&#125;// 或者fun func(value: Int): Int = 1 * value 类Java123456789101112131415public final class Person &#123; private String name = null; private int age = 25; private Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; Kotlin123456789101112class Person private constructor() &#123; private var name: String? = null private var age: Int = 25 constructor (name: String, age: Int): this() &#123; this.name = name this.age = age &#125;&#125; 静态方法（ 伴生对象 ）Java123456789public final class Manager &#123; private Manager() &#123;&#125; public static Manager getInstance () &#123; return new Manager(); &#125;&#125; Kotlin1234567class Manager private constructor() &#123; companion object &#123; fun getInstance(): Manager = Manager() &#125;&#125; 实体类Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Person &#123; public String name; public age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Person person = (Person) o; if (age != person.age) return false; return name != null ? name.equals(person.name) : person.name == null; &#125; @Override public int hashCode() &#123; int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; &#125; @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; Kotlin1data class Person(var name: String, var age: Int) 解构Java12345Person p = new Person("haohao", 25);String name = p.getName();String age = p.getAge(); Kotlin123var p = Person("name", 25)var (name, age) = p 接口Java 1234interface Readable &#123; String getContent();&#125; 12345678public final class Book implements Readable &#123; @override public String getContent() &#123; return "Hello"; &#125;&#125; Kotlin123456789// Kotlin 接口中可以设置抽象和非抽象方法,可以有属性但必须声明为抽象或提供访问器实现。interface Readable &#123; fun getContent(): String fun getVersion(): Int = 0 &#125; 123456789class Book(): Readable &#123; override fun getContent(): String = "Hello" override fun getVersion(): Int &#123; return super.getVersion() &#125;&#125; 继承Java 123456789101112131415161718public class Person &#123; private String name = null; public Person(String name) &#123; this.name = name; &#125; public void sayHello() &#123; System.out.println("Hello"); &#125; public final void sayGood() &#123; System.out.println("Good"); &#125;&#125; 1234567891011121314151617public final class Student extends Person &#123; private String school = null; public Student(String name, String school) &#123; this.school = school; super(name); &#125; @override public void sayHello() &#123; super.sayHello(); System.out.println("Hello Student"); &#125;&#125; Kotlin1234567open class Person(private var name: String? = null) &#123; open fun sayHello() = println("Hello") fun sayGood() = println("Good")&#125; 12345678class Student(private var school: String? = null, name: String): Person(name) &#123; override fun sayHello() &#123; super.sayHello() println("Hello Student") &#125; &#125; 静态与非静态内部类Java 12345678910111213141516171819202122232425public final class Outer &#123; private int bar = 100; public static class Nester &#123; public final String foo() &#123; return "Hello Kotlin!"; &#125; &#125; public final class Inner &#123; public final int foo() &#123; return bar; // 可以访问外部类成员 &#125; &#125; &#125;System.out.println(new Outer.Nester().foo()); // System.out.println(new Outer().Inner().foo()); 不能在其他类中实例化非静态内部类 Kotlin123456789101112131415161718192021class Outer &#123; private var bar: Int = 100 // 嵌套类 class Nester &#123; // 不能访问外部类成员 fun foo() = "Hello Kotlin!" &#125; // 内部类 inner class Inner &#123; // 可以访问外部类成员 fun foo() = bar &#125;&#125;println(Outer.Nested().foo())println(Outer().Inner().foo()) 匿名内部类Java12345678view.setOnClickListener(new OnClickListener() &#123; @override onClick(View view)&#123; // to do something. &#125; &#125;); Kotlin1234567891011121314151617interface OnClickListener &#123; fun onClick()&#125;class View()&#123; var listener: OnClickListener? = null fun setOnClickListener(listener: OnClickListener) &#123; this.listener = listener &#125;&#125;view.setOnClickListener(object : OnClickListener&#123; override fun onClick() &#123; TODO("not implemented") &#125;&#125;) 扩展Java1// Java 类不能直接进行扩展 Kotlin 12345678910// 一般扩展class MyClass &#123; fun foo() = println("member")&#125;fun MyClass.bar() = println("extension")MyClass().bar()//输出： extension 1234567891011121314151617// 扩展函数与成员函数相同class MyClass &#123; fun foo() = println("member")&#125;fun MyClass.foo() = println("extension") // 扩展函数与成员函数相同时, 成员函数优先fun MyClass.foo(para: Int) = println("extension")MyClass().foo()MyClass().foo(0)//输出： // member// extension Kotlin Call JavaJava123456789101112131415161718192021222324252627282930313233public class Person &#123; private String name = null; private int age = 0; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public Person() &#123; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "name : " + name + ", age : " + age; &#125;&#125; Kotlin 1234567var p = Person()p.name = "haohao"p.age = 25println(p.toString())// name : haohao, age : 25 Java Call KotlinKotlin 12345678// Example.ktpackage democlass MyClassfun func() &#123;&#125; Java123new demo.MyClass();demo.ExampleKt.func(); 泛型Java12345678910111213public final class Wrapper&lt;T&gt; &#123; private T item; public Wrapper(T item) &#123; this.item = item; &#125; public T getItem() &#123; return item; &#125;&#125;Wrapper&lt;String&gt; wrapper = new Wrapper&lt;&gt;("Hello Kotlin");System.out.println(wrapper.getItem()); Kotlin1234class Wrapper&lt;T&gt;(val item: T)var wrapper = Wrapper("Hello Kotlin")println(wrapper.item) 匿名函数 ( Lambda 表达式 )Java (Java 8)123456789101112131415161718new Thread(() -&gt; &#123; System.out.println("Hello Kotlin"); &#125;).start();// 同下new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("Hello Kotlin"); &#125; &#125;).start(); Kotlin123456789101112131415161718192021222324252627Thread(Runnable &#123; println("Hello Kotlin") &#125;).start()// Kotlin Lambda 表达式语法val sum = &#123;x: Int, y: Int -&gt; x + y &#125;val sum1: (Int, Int) -&gt; Int = &#123;x, y -&gt; x + y &#125;val sum2 = fun(x: Int, y: Int): Int &#123; return x + y&#125;println(sum(2,8))println(sum1(2,8))println(sum2(2,8))//输出：// 10// 10// 10// Hello Kotlin Kotlin 高阶函数Java1// Java 不能直接实现高阶函数 Kotlin12345678910111213141516171819202122// 高阶函数，即一个函数可作为高阶函数的参数fun superFunc(desc: String?, method: () -&gt; String) &#123; print(desc) println(method())&#125;fun argFun() = "我是高阶函数的参数"//使用高阶函数superFunc("这是一个高阶函数 ", ::argFun)superFunc("这是一个高阶函数 ", &#123; argFun() &#125;)superFunc("这是一个高阶函数 ") &#123; argFun() &#125;//输出：// 这是一个高阶函数 我是高阶函数的参数// 这是一个高阶函数 我是高阶函数的参数// 这是一个高阶函数 我是高阶函数的参数 简单异步Java (Java 8)1234567891011new Thread(() -&gt; &#123; data = DataSource.obtain(); //耗时操作 runOnUiThread(() -&gt; &#123; view.load(data); //更新 UI &#125;); &#125;).start(); Kotlin (Kotlin Anko)12345678async &#123; data = DataSource.obtain(); //耗时操作 uiThread &#123; view.load(data); //更新 UI &#125;&#125; 泛型函数Java1// Java 不能单独实现泛型函数 Kotlin12345fun &lt;T&gt; singletonList(item: T): List&lt;T&gt; &#123; return arrayListOf(item)&#125;val list = singletonList&lt;String&gt;("kotlin") Kotlin 内联具体化Kotlin1234567inline fun &lt;reified T ： Activity&gt; Activity.gotoActivity() &#123; val intent = Intent(this, T::class.java) this.startActivity(intent)&#125;gotoActivity&lt;NewActivity&gt;() Kotlin lazy 懒加载Kotlin1234567891011121314val lazyValue: String by lazy &#123; println("init") //第一次使用时才被初始化 "Hello Kotlin"&#125;fun main(args: Array&lt;String&gt;) &#123; println(lazyValue) println(lazyValue)&#125;//输出：// init// Hello Kotlin// Hello Kotlin Kotlin observable 观察者Kotlin12345678910111213141516171819class Person&#123; public var name: String by Delegates.observable("init .. ")&#123; property,oldValue,newValue -&gt; println("property : $property, oldValue : $oldValue, newValue : $newValue") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val person = Person() println(person.name) person.name = "haohao" person.name = "nannan"&#125;//输出：// init .. // property : var Person.name: kotlin.String, oldValue : init .. , newValue : haohao// property : var Person.name: kotlin.String, oldValue : haohao, newValue : nannan 持续更新中…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 设计模式之外观模式]]></title>
      <url>%2F2017%2F05%2F15%2FAndroid-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[打造个人品牌是现代职业规划的趋势 在当下互联网革命的时代，有这样一种说法，如果一个人到三十岁以后还是只有工资收入，那么它的职业规划是失败的。本文是 Android 设计模式的第三篇，接下来会陆续推出整个常用的设计模式系列。 外观模式外观模式 (Facade Pattern) ，又名门面模式，归类为对象结构型模式，外部对象与一个子系统通信必须通过一个统一的外观对象进行。 模式结构 Client 外部对象 Facade 外观对象 SubSystem 子系统对象 盗图 模式实现 电视遥控器是现实生活中一个比较好的外观模式的运用，遥控器可以控制电源 (Power) 的电源、声音 (Voice) 的调整、频道 (Channel) 的切换等。这个遥控器就是我们这里说的外观或者门面，而电源、声音、频道切换系统就是我们的子系统。 PowerSystem123456789public class PowerSystem &#123; public void powerOn() &#123; System.out.println("power on"); &#125; public void powerOff() &#123; System.out.println("power off"); &#125;&#125; VoiceSystem123456789public class VoiceSystem &#123; public void turnUp() &#123; System.out.println("voice increasing"); &#125; public void turnDown() &#123; System.out.println("voice reducing"); &#125;&#125; ChannelSystem123456789public class ChannelSystem &#123; public void next() &#123; System.out.println("next channel"); &#125; public void prev() &#123; System.out.println("prev channel"); &#125;&#125; Facade1234567891011121314151617181920212223242526272829public class Facade &#123; private PowerSystem mPowerSystem = new PowerSystem(); private VoiceSystem mVoiceSystem = new VoiceSystem(); private ChannelSystem mChannelSystem = new ChannelSystem(); public void powerOn() &#123; mPowerSystem.powerOn(); &#125; public void powerOff() &#123; mPowerSystem.powerOff(); &#125; public void turnUp() &#123; mVoiceSystem.turnUp(); &#125; public void turnDown() &#123; mVoiceSystem.turnDown(); &#125; public void nextChannel() &#123; mChannelSystem.next(); &#125; public void prevChannel() &#123; mChannelSystem.prev(); &#125;&#125; Client123456public static void main (String[] args) &#123; Facade facade = new Facade(); facade.powerOn(); facade.turnUp(); facade.nextChannel();&#125; Running power on voice increasing next channel Android 中的实现在 Activity 中可以进行很多重要的操作，如 startService() ，startActivity() ，sendBroadcast() ，bindService() 以及获取 System Service 。Activity 就可以简单地看作一个门面，但是这些工作实际上并不是 Activity 来实现的，而是委托 Activity 父类 ContextThemeWrapper 中的 mBase 对象，mBase 对象的实现类是 ContextImpl 。 看一下源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788class ContextImpl extends Context &#123; private final static String TAG = "ApplicationContext"; private final static boolean DEBUG = false; private final static boolean DEBUG_ICONS = false; private static final Object sSync = new Object(); private static AlarmManager sAlarmManager; private static PowerManager sPowerManager; private static ConnectivityManager sConnectivityManager; private AudioManager mAudioManager; LoadedApk mPackageInfo; private Resources mResources; private PackageManager mPackageManager; private NotificationManager mNotificationManager = null; private ActivityManager mActivityManager = null; ... @Override public boolean bindService(Intent service, ServiceConnection conn, int flags) &#123; warnIfCallingFromSystemProcess(); return bindServiceCommon(service, conn, flags, mMainThread.getHandler(), Process.myUserHandle()); &#125; @Override public Object getSystemService(String name) &#123; return SystemServiceRegistry.getSystemService(this, name); &#125; @Override public String getSystemServiceName(Class&lt;?&gt; serviceClass) &#123; return SystemServiceRegistry.getSystemServiceName(serviceClass); &#125; @Override public void sendBroadcast(Intent intent) &#123; String resolvedType = intent.resolveTypeIfNeeded(getContentResolver()); try &#123; ActivityManagerNative.getDefault().broadcastIntent( mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, false, false); &#125; catch (RemoteException e) &#123; &#125; &#125; @Override public void startActivity(Intent intent) &#123; if ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == 0) &#123; throw new AndroidRuntimeException( "Calling startActivity() from outside of an Activity " + " context requires the FLAG_ACTIVITY_NEW_TASK flag." + " Is this really what you want?"); &#125; mMainThread.getInstrumentation().execStartActivity( getOuterContext(), mMainThread.getApplicationThread(), null, null, intent, -1); &#125; @Override public ComponentName startService(Intent service) &#123; try &#123; ComponentName cn = ActivityManagerNative.getDefault().startService( mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(getContentResolver())); if (cn != null &amp;&amp; cn.getPackageName().equals("!")) &#123; throw new SecurityException( "Not allowed to start service " + service + " without permission " + cn.getClassName()); &#125; return cn; &#125; catch (RemoteException e) &#123; return null; &#125; &#125; @Override public String getPackageName() &#123; if (mPackageInfo != null) &#123; return mPackageInfo.getPackageName(); &#125; throw new RuntimeException("Not supported in system context"); &#125; ...&#125; ContextImpl 内部有很多 Manager 类的对象，也就是也就是子系统对象。 ContextImpl 内部封装了一些系统级别的操作以及提供了一些访问系统的接口，我们在开发过程中可以很方便地利用其访问子系统。 外观模式的优点与缺点优点 屏蔽了子系统内部细节，使子系统的使用更见便利 减少客户端所持对象的数目，降低了客户端与子系统的耦合度缺点 增加新的子系统可能需要修改外观类，违背了“开闭原则” 参考 https://github.com/simple-android-framework/android_design_patterns_analysis/tree/master/facade/elsdnwn]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 设计模式之 Builder 模式]]></title>
      <url>%2F2017%2F05%2F13%2FAndroid-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-Builder-%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[平坦的路往往只能带你到平凡的地方 最近在研究 Clean 和 Unidirectional （ Android Flux ）架构，回头放一个大招。本文是 Android 设计模式的第二篇，接下来会陆续推出整个常用的设计模式系列。 Builder 模式Builder 又名生成器模式，或建造（者）模式。它是一种对象构建模式，用于抽象复杂对象的构建过程，构造过程的不同实现方法可以构建出具有不同表示的对象。 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 模式结构 Product 产品，表示被构造的复杂对象。 Builder 抽象构建者，为创建一个 Product 对象的各个部件指定抽象方法（接口方法）。 ConcreteBuilder 具体构建者，实现 Builder 接口（抽象类）以及各个抽象方法。 Director 指挥者，构建实现（继承） Builder 接口（抽象类）的对象。 盗图 模式实现我们以生产手机为例，当我们拿到一个手机产品通常比较关注它的品牌 (Brand) ，CPU 核心数目 (CPU Core)，运行内存 (RAM) 以及操作系统 (OS)。 Product1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Phone &#123; private int mCPUCore = 1; private int mRam = 1; private String mOS = "Android"; private String mBrand = "Google"; public int getCPUCore() &#123; return mCPUCore; &#125; public int getRAM() &#123; return mRam; &#125; public String getOS() &#123; return mOS; &#125; public String getBrand() &#123; return mBrand; &#125; public void setCPUCore(int mCPUCore) &#123; this.mCPUCore = mCPUCore; &#125; public void setRAM(int mRam) &#123; this.mRam = mRam; &#125; public void setOS(String mOS) &#123; this.mOS = mOS; &#125; public void setBrand(String mBrand) &#123; this.mBrand = mBrand; &#125; @Override public String toString() &#123; return "Brand : " + getBrand() +", CPUCore : " + getCPUCore() + ", RAM : " + getRAM() + ", OS : " + getOS(); &#125;&#125; Builder 抽象类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public abstract class PhoneBuilder &#123; protected Phone mPhone; public void createPhone() &#123; mPhone = new Phone(); &#125; public Phone getPhone() &#123; return mPhone; &#125; public abstract void buildPhoneCpu(); public abstract void buildPhoneRam(); public abstract void buildPhoneOS();&#125;``` #### ConcreteBuilderXiaoMiPhoneBuilder```javapublic class XiaoMiPhoneBuilder extends PhoneBuilder &#123; public XiaoMiPhoneBuilder() &#123; createPhone(); mPhone.setBrand("XiaoMi"); &#125; @Override public void buildPhoneCpu() &#123; mPhone.setCPUCore(4); &#125; @Override public void buildPhoneRam() &#123; mPhone.setRAM(4); &#125; @Override public void buildPhoneOS() &#123; mPhone.setOS("MIUI Android"); &#125;&#125; GooglePhoneBuilder 123456789101112131415161718192021222324public class GooglePhoneBuilder extends PhoneBuilder &#123; public GooglePhoneBuilder() &#123; createPhone(); mPhone.setBrand("Google"); &#125; @Override public void buildPhoneCpu() &#123; mPhone.setCPUCore(8); &#125; @Override public void buildPhoneRam() &#123; mPhone.setRAM(6); &#125; @Override public void buildPhoneOS() &#123; mPhone.setOS("Android"); &#125;&#125; Director12345678910111213141516171819public class PhoneDirector &#123; private PhoneBuilder mPhoneBuilder; public PhoneDirector setPhoneBuilder(PhoneBuilder phoneBuilder) &#123; this.mPhoneBuilder = phoneBuilder; return this; &#125; public Phone getPhone() &#123; return mPhoneBuilder.getPhone(); &#125; public PhoneDirector constructPhone() &#123; mPhoneBuilder.buildPhoneCpu(); mPhoneBuilder.buildPhoneOS(); mPhoneBuilder.buildPhoneRam(); return this; &#125;&#125; Sample12345678910111213141516171819public class BuilderSample &#123; public static void main(String[] args) &#123; PhoneDirector phoneDirector = new PhoneDirector(); PhoneBuilder xiaomiphoneBuilder = new XiaoMiPhoneBuilder(); PhoneBuilder googlePhoneBuilder = new GooglePhoneBuilder(); Phone xiaoMiPhone = phoneDirector.setPhoneBuilder(xiaomiphoneBuilder) .constructPhone() .getPhone(); Phone googlePhone = phoneDirector.setPhoneBuilder(googlePhoneBuilder) .constructPhone() .getPhone(); System.out.println(xiaoMiPhone + "\n" + googlePhone); &#125;&#125; Running Brand : XiaoMi, CPUCore : 4, RAM : 4, OS : MIUI Android Brand : Google, CPUCore : 8, RAM : 6, OS : Android Android 中的实现在 Android 开发中我们最常用到的实现 Builder 的类是 AlertDialog.Builder ，Builder 是AlertDialog 的静态内部类。基本用法如下： 1234567891011121314151617181920212223AlertDialog.Builder builder = new AlertDialog.Builder(context);builder.setIcon(R.drawable.icon);builder.setTitle("Title");builder.setMessage("Message");builder.setPositiveButton("OK", new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int whichButton) &#123; setTitle("点击了对话框上的 OK 按钮"); &#125; &#125;);builder.setNeutralButton("Nothing", new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int whichButton) &#123; setTitle("点击了对话框上的 Nothing 按钮"); &#125; &#125;);builder.setNegativeButton("Cancel", new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int whichButton) &#123; setTitle("点击了对话框上的 Cancel 按钮"); &#125; &#125;);builder.create().show(); 我们看一下简化后的 AlertDialog 源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class AlertDialog extends Dialog implements DialogInterface &#123; // Controller, 接受 Builder 成员变量P中的各个参数 private AlertController mAlert; // 构造函数 protected AlertDialog(Context context, int theme) &#123; this(context, theme, true); &#125; // 构造 AlertDialog AlertDialog(Context context, int theme, boolean createContextWrapper) &#123; super(context, resolveDialogTheme(context, theme), createContextWrapper); mWindow.alwaysReadCloseOnTouchAttr(); mAlert = new AlertController(getContext(), this, getWindow()); &#125; @Override public void setTitle(CharSequence title) &#123; super.setTitle(title); mAlert.setTitle(title); &#125; public void setCustomTitle(View customTitleView) &#123; mAlert.setCustomTitle(customTitleView); &#125; public void setMessage(CharSequence message) &#123; mAlert.setMessage(message); &#125; // Builder内部类 public static class Builder &#123; // 存储 AlertDialog 的各个参数, 例如 title ， message ， icon 等. private final AlertController.AlertParams P; public Builder(Context context) &#123; this(context, resolveDialogTheme(context, 0)); &#125; public Builder(Context context, int theme) &#123; P = new AlertController.AlertParams(new ContextThemeWrapper( context, resolveDialogTheme(context, theme))); mTheme = theme; &#125; ...... public Builder setTitle(CharSequence title) &#123; P.mTitle = title; return this; &#125; public Builder setMessage(CharSequence message) &#123; P.mMessage = message; return this; &#125; public Builder setIcon(int iconId) &#123; P.mIconId = iconId; return this; &#125; public Builder setPositiveButton(CharSequence text, final OnClickListener listener) &#123; P.mPositiveButtonText = text; P.mPositiveButtonListener = listener; return this; &#125; public Builder setView(View view) &#123; P.mView = view; P.mViewSpacingSpecified = false; return this; &#125; // 构建 AlertDialog, 传递参数 public AlertDialog create() &#123; final AlertDialog dialog = new AlertDialog(P.mContext, mTheme, false); 将P中的参数应用的dialog中的mAlert对象中 P.apply(dialog.mAlert); dialog.setCancelable(P.mCancelable); if (P.mCancelable) &#123; dialog.setCanceledOnTouchOutside(true); &#125; dialog.setOnCancelListener(P.mOnCancelListener); if (P.mOnKeyListener != null) &#123; dialog.setOnKeyListener(P.mOnKeyListener); &#125; return dialog; &#125; &#125; &#125; 从源码中可以看到 AlertDialog.Builder 同时扮演了 Builder ， ConcreteBuilder 以及 Director 三个角色，是 Builder 模式的简化版。 我们从 AlertDialog 的构建和使用中，可以体会到运用 Builder 模式带来的简介性和高度的可定制性。 Builder 模式的优点和缺点优点 使用简单，可扩展性强，封装良好； 高度的可定制性，构造过程可精细化控制。 缺点 Builder 模式只适用于构建过程复杂的同一类 Product ，此外要考虑多余 Builder 和 Director 对象对内存的占用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 设计模式之单例模式]]></title>
      <url>%2F2017%2F05%2F06%2FAndroid-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[时刻尝试走出舒适区 最近在培养自己的广泛阅读习惯，感觉阅读中最重要的是动脑思考，阅读是接受讯息，思考是消化讯息。本文是 Android 设计模式的开篇，接下来会陆续推出整个常用的设计模式系列。 设计模式设计模式简而言之就是优秀的代码设计经验的总结。设计模式的产生是为了提高代码的可复用性，可扩展性以及可靠性，但是往往会降低可读性。 设计模式原则 单一职责原则: 一个类只负责一项职责; 里氏替换原则: 子类可以扩展父类的功能，但不能改变父类原有的功能; 依赖倒置原则: 面向接口编程，将依赖对象的共同特征抽象成接口； 接口隔离原则: 一个类不应该实现它不需要的接口方法，即建立单一接口，细化接口，尽量减少接口中的方法; 迪米特法则: 一个对象应该对其他对象保持最少的了解，即降低类与类之间的耦合； 开闭原则: 一个类对扩展开放，对修改关闭。 设计模式分类创建型设计模式设计对象的实例化，避免用户用 new 运算符创建对象。例如单例模式，Builder 模式，原型模式等。 行为型设计模式设计对象之间的通信交互。如观察者模式，迭代器模式，责任链模式等。 结构型设计模式设计如何组合类和对象以形成更大的结构。如适配器模式，代理模式，桥接模式等。 单例模式简单介绍常用的五种单例模式的写法。 饿汉式单例123456789101112public class Person &#123; private static final INSTANCE = new Person(); private Person()&#123; &#125; public static Person getInstance() &#123; return INSTANCE; &#125;&#125; 优点：线程安全。缺点：类加载的时候就进行初始化，对于初始化逻辑复杂的类，会导致类加载变慢。 (DCL) 懒汉式单例1234567891011121314151617181920public class Person &#123; private static volatile sInstance = null; private Person()&#123; &#125; public static Person getInstance() &#123; if (sInstance == null)&#123; synchronized (Person.class) &#123; if (sInstance == null) &#123; sInstance = new Person(); &#125; &#125; &#125; return sInstance; &#125;&#125; 优点：volatile 声明单例引用，可以防止并发时初始化成员变量和对象实例化顺序可能会被打乱，双重检查锁定解决了多余的同步问题。缺点：JVM 创建一个对象会执行 3 个原子操作，在高并发时仍存在极小的概率导致 DCL 失效。 静态内部类单例12345678910111213public class Person &#123; private Person()&#123; &#125; private static class Singleton &#123; private static final Person INSTANCE = new Person(); &#125; public static Person getInstance() &#123; return Singleton.INSTANCE; &#125;&#125; 优点：充分结合了懒汉式单例与饿汉式的优点，同时有效避开了它们的缺点，充分保证线程安全。推荐缺点：会有的！ 枚举型单例1234567891011public enum PersonEnum &#123; INSTANCE; private PersonEnum() &#123; &#125; public void fun() &#123; // do something &#125;&#125; 使用方法：1PersonEnum.INSTANCE.fun(); 优点：简洁，线程安全。《Effective Java》的作者在书中是这样夸枚举型单例： 这种写法在功能上与共有域方法相近，但是它更简洁，无偿地提供了序列化机制，绝对防止对此实例化，即使是在面对复杂的序列化或者反射攻击的时候。虽然这中方法还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。 缺点：Google 官方强烈建议尽量不要使用 enum ，它会增加额外的内存占用，同时增加可执行文件 .dex 的大小，也不适用继承场景。 容器型单例12345678910111213141516171819202122public class Person &#123; public Person () &#123; &#125;&#125;public class SingletonManager &#123; public static final KEY_SINGLETON = "singleton"; private static Map&lt;String, Object&gt; sInstanceMap = new HashMap&lt;&gt;(); public static void registerSingleton(String key, Object obj) &#123; if (!sInstanceMap.containsKey(key)) &#123; sInstanceMap.put(key, obj); &#125; &#125; public static Person getSingleton(String key) &#123; return (Person) sInstanceMap.get(key); &#125;&#125; 使用：12SingletonManager.registerSingleton(KEY_SINGLETON, new Person);Person person = SingletonManager.getSingleton(); 优点：可以将不同单例注册到一个容器中统一管理，隐藏了类的具体实现，降低了耦合度。推荐缺点：会有的！ 单例模式的优点与缺点优点：减少内存开销，避免资源重用。缺点：单例类的扩展性很差，持有外部引用时，非常容易造成内存泄漏。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 进程间通信方式]]></title>
      <url>%2F2017%2F04%2F27%2FAndroid-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[做好眼前的事，保持专注 我们的大脑是串行结构，而非并行结构，你永远无法真正将自己的注意力同时放在两个任务之中。 Android 中的 IPC 方式使用 Intent Activity，Service，Receiver 都支持在 Intent 中传递 Bundle 数据，而 Bundle 实现了 Parcelable 接口，可以在不同的进程间进行传输。 在一个进程中启动了另一个进程的 Acyivity，Service 和 Receiver ，可以在 Bundle 中附加要传递的数据通过 Intent 发送出去。 使用文件共享 Windows 上，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读和写；而 Android 系统基于 Linux ，使得其并发读取文件没有限制地进行，甚至允许两个线程同时对一个文件进行读写操作，尽管这样可能会出问题。 可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（注意：并不是同一个对象，只是内容相同。）。 SharedPreferences 是个特例，系统对它的读 / 写有一定的缓存策略，即内存中会有一份 ShardPreferences 文件的缓存，系统对他的读 / 写就变得不可靠，当面对高并发的读写访问，SharedPreferences 有很多大的几率丢失数据。因此，IPC 不建议采用 SharedPreferences。 使用 MessengerMessenger 是一种轻量级的 IPC 方案，它的底层实现是 AIDL ，可以在不同进程中传递 Message 对象，它一次只处理一个请求，在服务端不需要考虑线程同步的问题，服务端不存在并发执行的情形。 服务端进程：服务端创建一个 Service 来处理客户端请求，同时通过一个 Handler 对象来实例化一个 Messenger 对象，然后在 Service 的 onBind 中返回这个 Messenger 对象底层的 Binder 即可。 123456789101112131415161718192021222324252627282930313233343536373839404142public class MessengerService extends Service &#123; private static final String TAG = MessengerService.class.getSimpleName(); private class MessengerHandler extends Handler &#123; /** * @param msg */ @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case Constants.MSG_FROM_CLIENT: Log.d(TAG, "receive msg from client: msg = [" + msg.getData().getString(Constants.MSG_KEY) + "]"); Toast.makeText(MessengerService.this, "receive msg from client: msg = [" + msg.getData().getString(Constants.MSG_KEY) + "]", Toast.LENGTH_SHORT).show(); Messenger client = msg.replyTo; Message replyMsg = Message.obtain(null, Constants.MSG_FROM_SERVICE); Bundle bundle = new Bundle(); bundle.putString(Constants.MSG_KEY, "我已经收到你的消息，稍后回复你！"); replyMsg.setData(bundle); try &#123; client.send(replyMsg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; break; default: super.handleMessage(msg); &#125; &#125; &#125; private Messenger mMessenger = new Messenger(new MessengerHandler()); @Nullable @Override public IBinder onBind(Intent intent) &#123; return mMessenger.getBinder(); &#125;&#125; 客户端进程：首先绑定服务端 Service ，绑定成功之后用服务端的 IBinder 对象创建一个 Messenger ，通过这个 Messenger 就可以向服务端发送消息了，消息类型是 Message 。如果需要服务端响应，则需要创建一个 Handler 并通过它来创建一个 Messenger（和服务端一样），并通过 Message 的 replyTo 参数传递给服务端。服务端通过 Message 的 replyTo 参数就可以回应客户端了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class MainActivity extends AppCompatActivity &#123; private static final String TAG = MainActivity.class.getSimpleName(); private Messenger mGetReplyMessenger = new Messenger(new MessageHandler()); private Messenger mService; private class MessageHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case Constants.MSG_FROM_SERVICE: Log.d(TAG, "received msg form service: msg = [" + msg.getData().getString(Constants.MSG_KEY) + "]"); Toast.makeText(MainActivity.this, "received msg form service: msg = [" + msg.getData().getString(Constants.MSG_KEY) + "]", Toast.LENGTH_SHORT).show(); break; default: super.handleMessage(msg); &#125; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void bindService(View v) &#123; Intent mIntent = new Intent(this, MessengerService.class); bindService(mIntent, mServiceConnection, Context.BIND_AUTO_CREATE); &#125; public void sendMessage(View v) &#123; Message msg = Message.obtain(null,Constants.MSG_FROM_CLIENT); Bundle data = new Bundle(); data.putString(Constants.MSG_KEY, "Hello! This is client."); msg.setData(data); msg.replyTo = mGetReplyMessenger; try &#123; mService.send(msg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void onDestroy() &#123; unbindService(mServiceConnection); super.onDestroy(); &#125; private ServiceConnection mServiceConnection = new ServiceConnection() &#123; /** * @param name * @param service */ @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mService = new Messenger(service); Message msg = Message.obtain(null,Constants.MSG_FROM_CLIENT); Bundle data = new Bundle(); data.putString(Constants.MSG_KEY, "Hello! This is client."); msg.setData(data); // msg.replyTo = mGetReplyMessenger; try &#123; mService.send(msg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; /** * @param name */ @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;;&#125; 注意：客户端和服务端是通过拿到对方的 Messenger 来发送 Message 的。只不过客户端通过 bindService onServiceConnected 而服务端通过 message.replyTo 来获得对方的 Messenger 。Messenger 中有一个 Hanlder 以串行的方式处理队列中的消息。不存在并发执行，因此我们不用考虑线程同步的问题。 图片来自《Android 开发艺术探索》 使用 AIDLMessenger 是以串行的方式处理客户端发来的消息，如果大量消息同时发送到服务端，服务端只能一个一个处理，所以大量并发请求就不适合用 Messenger ，而且 Messenger 只适合传递消息，不能跨进程调用服务端的方法。AIDL 可以解决并发和跨进程调用方法的问题，要知道 Messenger 本质上也是 AIDL ，只不过系统做了封装方便上层的调用而已。 AIDL 文件支持的数据类型 基本数据类型； String 和 CharSequence ArrayList ，里面的元素必须能够被 AIDL 支持； HashMap ，里面的元素必须能够被 AIDL 支持； Parcelable ，实现 Parcelable 接口的对象；注意：如果 AIDL 文件中用到了自定义的 Parcelable 对象，必须新建一个和它同名的 AIDL 文件。 AIDL ，AIDL 接口本身也可以在 AIDL 文件中使用。 服务端服务端创建一个 Service 用来监听客户端的连接请求，然后创建一个 AIDL 文件，将暴露给客户端的接口在这个 AIDL 文件中声明，最后在 Service 中实现这个 AIDL 接口即可。 客户端绑定服务端的 Service ，绑定成功后，将服务端返回的 Binder 对象转成 AIDL 接口所属的类型，然后就可以调用 AIDL 中的方法了。客户端调用远程服务的方法，被调用的方法运行在服务端的 Binder 线程池中，同时客户端的线程会被挂起，如果服务端方法执行比较耗时，就会导致客户端线程长时间阻塞，导致 ANR 。客户端的 onServiceConnected 和 onServiceDisconnected 方法都在 UI 线程中。 服务端访问权限管理 使用 Permission 验证，在 manifest 中声明 123&lt;permission android:name="com.jc.ipc.ACCESS_BOOK_SERVICE" android:protectionLevel="normal"/&gt;&lt;uses-permission android:name="com.jc.ipc.ACCESS_BOOK_SERVICE"/&gt; 服务端 onBinder 方法中 123456789public IBinder onBind(Intent intent) &#123; //Permission 权限验证 int check = checkCallingOrSelfPermission("com.jc.ipc.ACCESS_BOOK_SERVICE"); if (check == PackageManager.PERMISSION_DENIED) &#123; return null; &#125; return mBinder;&#125; Pid Uid 验证 详细代码：1234// Book.aidlpackage com.jc.ipc.aidl;parcelable Book; 123456789101112131415161718192021// IBookManager.aidlpackage com.jc.ipc.aidl;import com.jc.ipc.aidl.Book;import com.jc.ipc.aidl.INewBookArrivedListener;// AIDL 接口中只支持方法，不支持静态常量，区别于传统的接口interface IBookManager &#123; List&lt;Book&gt; getBookList(); // AIDL 中除了基本数据类型，其他数据类型必须标上方向,in,out 或者 inout // in 表示输入型参数 // out 表示输出型参数 // inout 表示输入输出型参数 void addBook(in Book book); void registerListener(INewBookArrivedListener listener); void unregisterListener(INewBookArrivedListener listener);&#125; 123456789// INewBookArrivedListener.aidlpackage com.jc.ipc.aidl;import com.jc.ipc.aidl.Book;// 提醒客户端新书到来interface INewBookArrivedListener &#123; void onNewBookArrived(in Book newBook);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class BookManagerActivity extends AppCompatActivity &#123; private static final String TAG = BookManagerActivity.class.getSimpleName(); private static final int MSG_NEW_BOOK_ARRIVED = 0x10; private Button getBookListBtn,addBookBtn; private TextView displayTextView; private IBookManager bookManager; private Handler mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_NEW_BOOK_ARRIVED: Log.d(TAG, "handleMessage: new book arrived " + msg.obj); Toast.makeText(BookManagerActivity.this, "new book arrived " + msg.obj, Toast.LENGTH_SHORT).show(); break; default: super.handleMessage(msg); &#125; &#125; &#125;; private ServiceConnection mServiceConn = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; bookManager = IBookManager.Stub.asInterface(service); try &#123; bookManager.registerListener(listener); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; private INewBookArrivedListener listener = new INewBookArrivedListener.Stub() &#123; @Override public void onNewBookArrived(Book newBook) throws RemoteException &#123; mHandler.obtainMessage(MSG_NEW_BOOK_ARRIVED, newBook).sendToTarget(); &#125; &#125;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.book_manager); displayTextView = (TextView) findViewById(R.id.displayTextView); Intent intent = new Intent(this, BookManagerService.class); bindService(intent, mServiceConn, BIND_AUTO_CREATE); &#125; public void getBookList(View view) &#123; try &#123; List&lt;Book&gt; list = bookManager.getBookList(); Log.d(TAG, "getBookList: " + list.toString()); displayTextView.setText(list.toString()); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; public void addBook(View view) &#123; try &#123; bookManager.addBook(new Book(3, "天龙八部")); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void onDestroy() &#123; if (bookManager != null &amp;&amp; bookManager.asBinder().isBinderAlive()) &#123; Log.d(TAG, "unregister listener " + listener); try &#123; bookManager.unregisterListener(listener); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; unbindService(mServiceConn); super.onDestroy(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public class BookManagerService extends Service &#123; private static final String TAG = BookManagerService.class.getSimpleName(); // CopyOnWriteArrayList 支持并发读写，实现自动线程同步，他不是继承自 ArrayList private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;Book&gt;(); //对象是不能跨进程传输的，对象的跨进程传输本质都是反序列化的过程，Binder 会把客户端传递过来的对象重新转化生成一个新的对象 //RemoteCallbackList 是系统专门提供的用于删除系统跨进程 listener 的接口，利用底层的 Binder 对象是同一个 //RemoteCallbackList 会在客户端进程终止后，自动溢出客户端注册的 listener ，内部自动实现了线程同步功能。 private RemoteCallbackList&lt;INewBookArrivedListener&gt; mListeners = new RemoteCallbackList&lt;&gt;(); private AtomicBoolean isServiceDestroied = new AtomicBoolean(false); private Binder mBinder = new IBookManager.Stub() &#123; @Override public List&lt;Book&gt; getBookList() throws RemoteException &#123; return mBookList; &#125; @Override public void addBook(Book book) throws RemoteException &#123; Log.d(TAG, "addBook: " + book.toString()); mBookList.add(book); &#125; @Override public void registerListener(INewBookArrivedListener listener) throws RemoteException &#123; mListeners.register(listener); &#125; @Override public void unregisterListener(INewBookArrivedListener listener) throws RemoteException &#123; mListeners.unregister(listener); &#125; &#125;; @Override public void onCreate() &#123; super.onCreate(); mBookList.add(new Book(1, "老人与海")); mBookList.add(new Book(2, "哈姆雷特")); new Thread(new ServiceWorker()).start(); &#125; private void onNewBookArrived(Book book) throws RemoteException &#123; mBookList.add(book); int count = mListeners.beginBroadcast(); for (int i = 0; i &lt; count; i++) &#123; INewBookArrivedListener listener = mListeners.getBroadcastItem(i); if (listener != null) &#123; listener.onNewBookArrived(book); &#125; &#125; mListeners.finishBroadcast(); &#125; private class ServiceWorker implements Runnable &#123; @Override public void run() &#123; while (!isServiceDestroied.get()) &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; int bookId = mBookList.size() +1; Book newBook = new Book(bookId, "new book # " + bookId); try &#123; onNewBookArrived(newBook); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; //Permission 权限验证 int check = checkCallingOrSelfPermission("com.jc.ipc.ACCESS_BOOK_SERVICE"); if (check == PackageManager.PERMISSION_DENIED) &#123; return null; &#125; return mBinder; &#125; @Override public void onDestroy() &#123; isServiceDestroied.set(true); super.onDestroy(); &#125;&#125; 使用 ContentProvider用于不同应用间数据共享，和 Messenger 底层实现同样是 Binder 和 AIDL，系统做了封装，使用简单。系统预置了许多 ContentProvider ，如通讯录、日程表，需要跨进程访问。使用方法：继承 ContentProvider 类实现 6 个抽象方法，这六个方法均运行在 ContentProvider 进程中，除 onCreate 运行在主线程里，其他五个方法均由外界回调运行在 Binder 线程池中。 ContentProvider 的底层数据，可以是 SQLite 数据库，可以是文件，也可以是内存中的数据。 详见代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119public class BookProvider extends ContentProvider &#123; private static final String TAG = "BookProvider"; public static final String AUTHORITY = "com.jc.ipc.Book.Provider"; public static final Uri BOOK_CONTENT_URI = Uri.parse("content://" + AUTHORITY + "/book"); public static final Uri USER_CONTENT_URI = Uri.parse("content://" + AUTHORITY + "/user"); public static final int BOOK_URI_CODE = 0; public static final int USER_URI_CODE = 1; private static final UriMatcher sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH); static &#123; sUriMatcher.addURI(AUTHORITY, "book", BOOK_URI_CODE); sUriMatcher.addURI(AUTHORITY, "user", USER_URI_CODE); &#125; private Context mContext; private SQLiteDatabase mDB; @Override public boolean onCreate() &#123; mContext = getContext(); initProviderData(); return true; &#125; private void initProviderData() &#123; //不建议在 UI 线程中执行耗时操作 mDB = new DBOpenHelper(mContext).getWritableDatabase(); mDB.execSQL("delete from " + DBOpenHelper.BOOK_TABLE_NAME); mDB.execSQL("delete from " + DBOpenHelper.USER_TABLE_NAME); mDB.execSQL("insert into book values(3,'Android');"); mDB.execSQL("insert into book values(4,'iOS');"); mDB.execSQL("insert into book values(5,'Html5');"); mDB.execSQL("insert into user values(1,'haohao',1);"); mDB.execSQL("insert into user values(2,'nannan',0);"); &#125; @Nullable @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; Log.d(TAG, "query, current thread"+ Thread.currentThread()); String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException("Unsupported URI" + uri); &#125; return mDB.query(table, projection, selection, selectionArgs, null, null, sortOrder, null); &#125; @Nullable @Override public String getType(Uri uri) &#123; Log.d(TAG, "getType"); return null; &#125; @Nullable @Override public Uri insert(Uri uri, ContentValues values) &#123; Log.d(TAG, "insert"); String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException("Unsupported URI" + uri); &#125; mDB.insert(table, null, values); // 通知外界 ContentProvider 中的数据发生变化 mContext.getContentResolver().notifyChange(uri, null); return uri; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; Log.d(TAG, "delete"); String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException("Unsupported URI" + uri); &#125; int count = mDB.delete(table, selection, selectionArgs); if (count &gt; 0) &#123; mContext.getContentResolver().notifyChange(uri, null); &#125; return count; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; Log.d(TAG, "update"); String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException("Unsupported URI" + uri); &#125; int row = mDB.update(table, values, selection, selectionArgs); if (row &gt; 0) &#123; getContext().getContentResolver().notifyChange(uri, null); &#125; return row; &#125; private String getTableName(Uri uri) &#123; String tableName = null; switch (sUriMatcher.match(uri)) &#123; case BOOK_URI_CODE: tableName = DBOpenHelper.BOOK_TABLE_NAME; break; case USER_URI_CODE: tableName = DBOpenHelper.USER_TABLE_NAME; break; default: break; &#125; return tableName; &#125;&#125; 123456789101112131415161718192021222324252627282930313233public class DBOpenHelper extends SQLiteOpenHelper &#123; private static final String DB_NAME = "book_provider.db"; public static final String BOOK_TABLE_NAME = "book"; public static final String USER_TABLE_NAME = "user"; private static final int DB_VERSION = 1; private String CREATE_BOOK_TABLE = "CREATE TABLE IF NOT EXISTS " + BOOK_TABLE_NAME + "(_id INTEGER PRIMARY KEY," + "name TEXT)"; private String CREATE_USER_TABLE = "CREATE TABLE IF NOT EXISTS " + USER_TABLE_NAME + "(_id INTEGER PRIMARY KEY," + "name TEXT," + "sex INT)"; public DBOpenHelper(Context context) &#123; super(context, DB_NAME, null, DB_VERSION); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL(CREATE_BOOK_TABLE); db.execSQL(CREATE_USER_TABLE); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class ProviderActivity extends AppCompatActivity &#123; private static final String TAG = ProviderActivity.class.getSimpleName(); private TextView displayTextView; private Handler mHandler; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_provider); displayTextView = (TextView) findViewById(R.id.displayTextView); mHandler = new Handler(); getContentResolver().registerContentObserver(BookProvider.BOOK_CONTENT_URI, true, new ContentObserver(mHandler) &#123; @Override public boolean deliverSelfNotifications() &#123; return super.deliverSelfNotifications(); &#125; @Override public void onChange(boolean selfChange) &#123; super.onChange(selfChange); &#125; @Override public void onChange(boolean selfChange, Uri uri) &#123; Toast.makeText(ProviderActivity.this, uri.toString(), Toast.LENGTH_SHORT).show(); super.onChange(selfChange, uri); &#125; &#125;); &#125; public void insert(View v) &#123; ContentValues values = new ContentValues(); values.put("_id",1123); values.put("name", "三国演义"); getContentResolver().insert(BookProvider.BOOK_CONTENT_URI, values); &#125; public void delete(View v) &#123; getContentResolver().delete(BookProvider.BOOK_CONTENT_URI, "_id = 4", null); &#125; public void update(View v) &#123; ContentValues values = new ContentValues(); values.put("_id",1123); values.put("name", "三国演义新版"); getContentResolver().update(BookProvider.BOOK_CONTENT_URI, values , "_id = 1123", null); &#125; public void query(View v) &#123; Cursor bookCursor = getContentResolver().query(BookProvider.BOOK_CONTENT_URI, new String[]&#123;"_id", "name"&#125;, null, null, null); StringBuilder sb = new StringBuilder(); while (bookCursor.moveToNext()) &#123; Book book = new Book(bookCursor.getInt(0),bookCursor.getString(1)); sb.append(book.toString()).append("\n"); &#125; sb.append("--------------------------------").append("\n"); bookCursor.close(); Cursor userCursor = getContentResolver().query(BookProvider.USER_CONTENT_URI, new String[]&#123;"_id", "name", "sex"&#125;, null, null, null); while (userCursor.moveToNext()) &#123; sb.append(userCursor.getInt(0)) .append(userCursor.getString(1)).append(" ,") .append(userCursor.getInt(2)).append(" ,") .append("\n"); &#125; sb.append("--------------------------------"); userCursor.close(); displayTextView.setText(sb.toString()); &#125;&#125; 使用 Socket Socket起源于 Unix，而 Unix 基本哲学之一就是“一切皆文件”，都可以用“打开 open –读写 write/read –关闭 close ”模式来操作。Socket 就是该模式的一个实现，网络的 Socket 数据传输是一种特殊的 I/O，Socket 也是一种文件描述符。Socket 也具有一个类似于打开文件的函数调用： Socket()，该函数返回一个整型的Socket 描述符，随后的连接建立、数据传输等操作都是通过该 Socket 实现的。 常用的 Socket 类型有两种：流式 Socket（SOCK_STREAM）和数据报式 Socket（SOCK_DGRAM）。流式是一种面向连接的 Socket，针对于面向连接的 TCP 服务应用；数据报式 Socket 是一种无连接的 Socket ，对应于无连接的 UDP 服务应用。 Socket 本身可以传输任意字节流。 谈到Socket，就必须要说一说 TCP/IP 五层网络模型： 应用层：规定应用程序的数据格式，主要的协议 HTTP，FTP，WebSocket，POP3 等； 传输层：建立“端口到端口” 的通信，主要的协议：TCP，UDP； 网络层：建立”主机到主机”的通信，主要的协议：IP，ARP ，IP 协议的主要作用：一个是为每一台计算机分配 IP 地址，另一个是确定哪些地址在同一子网； 数据链路层：确定电信号的分组方式，主要的协议：以太网协议； 物理层：负责电信号的传输。 Socket 是连接应用层与传输层之间接口（API）。 图片来自网络 只实现 TCP Socket 。Client 端代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122public class TCPClientActivity extends AppCompatActivity implements View.OnClickListener&#123; private static final String TAG = "TCPClientActivity"; public static final int MSG_RECEIVED = 0x10; public static final int MSG_READY = 0x11; private EditText editText; private TextView textView; private PrintWriter mPrintWriter; private Socket mClientSocket; private Button sendBtn; private StringBuilder stringBuilder; private Handler mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_READY: sendBtn.setEnabled(true); break; case MSG_RECEIVED: stringBuilder.append(msg.obj).append("\n"); textView.setText(stringBuilder.toString()); break; default: super.handleMessage(msg); &#125; &#125; &#125;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.tcp_client_activity); editText = (EditText) findViewById(R.id.editText); textView = (TextView) findViewById(R.id.displayTextView); sendBtn = (Button) findViewById(R.id.sendBtn); sendBtn.setOnClickListener(this); sendBtn.setEnabled(false); stringBuilder = new StringBuilder(); Intent intent = new Intent(TCPClientActivity.this, TCPServerService.class); startService(intent); new Thread()&#123; @Override public void run() &#123; connectTcpServer(); &#125; &#125;.start(); &#125; private String formatDateTime(long time) &#123; return new SimpleDateFormat("(HH:mm:ss)").format(new Date(time)); &#125; private void connectTcpServer() &#123; Socket socket = null; while (socket == null) &#123; try &#123; socket = new Socket("localhost", 8888); mClientSocket = socket; mPrintWriter = new PrintWriter(new BufferedWriter( new OutputStreamWriter(socket.getOutputStream()) ), true); mHandler.sendEmptyMessage(MSG_READY); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // receive message BufferedReader bufferedReader = null; try &#123; bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; while (!isFinishing()) &#123; try &#123; String msg = bufferedReader.readLine(); if (msg != null) &#123; String time = formatDateTime(System.currentTimeMillis()); String showedMsg = "server " + time + ":" + msg + "\n"; mHandler.obtainMessage(MSG_RECEIVED, showedMsg).sendToTarget(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void onClick(View v) &#123; if (mPrintWriter != null) &#123; String msg = editText.getText().toString(); mPrintWriter.println(msg); editText.setText(""); String time = formatDateTime(System.currentTimeMillis()); String showedMsg = "self " + time + ":" + msg + "\n"; stringBuilder.append(showedMsg); &#125; &#125; @Override protected void onDestroy() &#123; if (mClientSocket != null) &#123; try &#123; mClientSocket.shutdownInput(); mClientSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; super.onDestroy(); &#125;&#125; Server 端代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class TCPServerService extends Service &#123; private static final String TAG = "TCPServerService"; private boolean isServiceDestroyed = false; private String[] mMessages = new String[]&#123; "Hello! Body!", "用户不在线！请稍后再联系！", "请问你叫什么名字呀？", "厉害了，我的哥！", "Google 不需要科学上网是真的吗？", "扎心了，老铁！！！" &#125;; @Override public void onCreate() &#123; new Thread(new TCPServer()).start(); super.onCreate(); &#125; @Override public void onDestroy() &#123; isServiceDestroyed = true; super.onDestroy(); &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125; private class TCPServer implements Runnable &#123; @Override public void run() &#123; ServerSocket serverSocket = null; try &#123; serverSocket = new ServerSocket(8888); &#125; catch (IOException e) &#123; e.printStackTrace(); return; &#125; while (!isServiceDestroyed) &#123; // receive request from client try &#123; final Socket client = serverSocket.accept(); Log.d(TAG, "=============== accept =================="); new Thread()&#123; @Override public void run() &#123; try &#123; responseClient(client); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;.start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; private void responseClient(Socket client) throws IOException &#123; //receive message BufferedReader in = new BufferedReader( new InputStreamReader(client.getInputStream())); //send message PrintWriter out = new PrintWriter( new BufferedWriter( new OutputStreamWriter( client.getOutputStream())),true); out.println("欢迎来到聊天室！"); while (!isServiceDestroyed) &#123; String str = in.readLine(); Log.d(TAG, "message from client: " + str); if (str == null) &#123; return; &#125; Random random = new Random(); int index = random.nextInt(mMessages.length); String msg = mMessages[index]; out.println(msg); Log.d(TAG, "send Message: " + msg); &#125; out.close(); in.close(); client.close(); &#125;&#125; 演示： UDP Socket 可以自己尝试着实现。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 多线程实现方式]]></title>
      <url>%2F2017%2F04%2F22%2FAndroid-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[只为初心 一个优秀的程序员，必须具备两种能力： 学习能力 时间管理能力 Android 多线程实现方式通常来说，一个应用至少有一个进程，而一个进程至少有一个线程。线程是 CPU 调度的基本单位，进程是系统资源分配的基本单位。进程独享内存资源，一个进程可以看作一个 JVM ，一个进程崩溃后，在保护模式下一般不会对其它进程产生影响。同一个进程中的线程共享内存资源，一个线程死掉就导致整个进程死掉。行了，进程和线程就扯嫩忙多。Android 提供了四种常用的多线程实现方式： AsyncTask 异步消息机制 IntentService ThreadPoolExcutor AsyncTask我们的老朋友 AsyncTask 类，它是封装好的线程池，操作 UI 线程极其方便。 瞅一眼，AsyncTask 的三个泛型参数： public abstract class AsyncTask&lt;Params, Progress, Result&gt; params ，传入参数类型，即 doInBackground() 方法中的参数类型; Progress ，异步任务执行过程中返回的任务执行进度类型，即 publishProgress() 和onProgressUpdate() 方法中传入的参数类型； Result ，异步任务执行完返回的结果类型，即 doInBackground() 方法中返回值的类型。 四个回调方法： onPreExecute()，在主线程执行，做一些准备工作。 doInBackground()，在线程池中执行，该方法是抽象方法，在此方法中可以调用 publishProgress() 更新任务进度。 onProgressUpdate()，在主线程中执行，在 publishProgress() 调用之后被回调，展示任务进度。 onPostExecute()，在主线程中执行，异步任务结束后，回调此方法，处理返回结果。 注意： 当 AsyncTask 任务被取消时，回调 onCanceled(obj) ，此时 onPostExecute()，不会被调用，AsyncTask 中的 cancel() 方法并不是真正去取消任务，只是设置这个任务为取消状态，需要在 doInBackground() 中通过 isCancelled() 判断终止任务。 AsyncTask 必须在主线程中创建实例，execute() 方法也必须在主线程中调用。 每个 AsyncTask 实例只能执行一次 execute() ，多次执行会报错，如需执行多次，则需创建多个实例。 Android 3.0 之后， AsyncTask 对象默认执行多任务是串行执行，即 mAsyncTask.execute() ，并发执行的话需要使用 executeOnExecutor() 。 AsyncTask 用的是线程池机制和异步消息机制（基于 ThreadPoolExecutor 和 Handler ）。Android 2.3 以前，AsyncTask 线程池容量是 128 ，全局线程池只有 5 个工作线程，如果运用 AsyncTask 对象来执行多个并发异步任务，那么同一时间最多只能有 5 个线程同时运行，其他线程将被阻塞。Android 3.0 之后 Google 又进行了调整，新增接口 executeOnExecutor() ，允许自定义线程池（那么核心线程数以及线程容量也可自定义），并提供了 SERIAL_EXECUTOR 和 THREAD_POOL_EXECUTOR 预定义线程池。后来 Google 又做了一些调整（任何事物都不完美），将线程池的容量与 CPU 的核心数联系起来，如目前 SDK 25 版本中，预定义的核心线程数量最少有 2 个，最多 4 个，线程池容量范围 5 ~ 9 。改动如下： 1234private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;private static final int KEEP_ALIVE_SECONDS = 30; 异步消息机制异步消息机制的三大主角： Handler ，Message 和 Looper 。Looper 负责创建 MessageQueue 消息对列，然后进入一个无限 for 循环中，不断地从消息队列中取消息，如果消息队列为空，当前线程阻塞，Handler 负责向消息队列中发送消息。 LooperLooper 有两个重要的方法： prepare() 和 loop()。 prepare() ， Looper 与当前线程绑定，一个线程只能有一个 Looper 实例和一个 MessageQueue 实例。 12345678910111213public static final void prepare() &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(true)); 保证 Looper 对象在当前线程唯一&#125;// Looper 的构造方法private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mRun = true; mThread = Thread.currentThread();&#125; loop ，进入一个无限 for 循环体中，不断地从消息队列中取消息，然后交给消息的 target 属性的 dispatchMessage 方法去处理。 123456789101112131415161718192021222324252627public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); // 无限循环体，有没有想过在 UI 线程里，有这样一个死循环，为什么界面没卡死？？ // 答案最后揭晓。 for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; msg.target.dispatchMessage(msg); msg.recycle(); &#125;&#125; HandlerHandler 负责向消息队列中发送消息。在 Activity 中我们直接可以 new Handler ，那是因为在 Activity 的启动代码中，已经在当前 UI 线程中调用了 Looper.prepare() 和 Looper.loop() 方法。 在子线程中 new Handler 必须要在当前线程（子线程）中创建好 Looper 对象和消息队列，代码如下 123456789101112//在子线程中Looper.prepare();handler = new Handler() &#123; public void handleMessage(Message msg) &#123; //处理消息 &#125;;&#125;;Looper.loop(); 之后，你拿着这个 Handler 对象就可以在其他线程中，往这个子线程的消息队列中发消息了。 HandlerThreadHandlerThread 可以看作在子线程中创建一个异步消息处理机制的简化版，HandlerThread 对象自动帮我们在工作线程里创建 Looper 对象和消息队列。 使用方法： 12345678910mHandlerThread = new HandlerThread("MyHandlerThread");mHandlerThread.start();mHandler = new Handler(mHandlerThread.getLooper())&#123; @Override public void handleMessage(Message msg) &#123; //处理消息 &#125;&#125;; 之后你就可以使用 Handler 对象往工作线程中的消息队列中发消息了。 看一下源码片段： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class HandlerThread extends Thread &#123; int mPriority; int mTid = -1; Looper mLooper; public HandlerThread(String name) &#123; super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT; &#125; protected void onLooperPrepared() &#123; &#125; @Override public void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; &#125; public Looper getLooper() &#123; if (!isAlive()) &#123; return null; &#125; // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper; &#125;&#125; 注意：handler 在 UI 线程中初始化的，looper 在一个子线程中执行，我们必须等 mLooper 创建完成之后，才能调用 getLooper ，源码中是通过 wait 和 notify 解决两个线程的同步问题。 IntentServiceIntentService 可以看成是 Service 和 HandlerThread 的合体。它继承自 Service ，并可以处理异步请求，其内部有一个 WorkerThread 来处理异步任务，当任务执行完毕后，IntentService 自动停止。 如果多次启动 IntentService 呢？ 看到 HandlerThread ，你就应该想到多次启动 IntentService ,就是将多个异步任务放到任务队列里面，然后在 onHandlerIntent 回调方法中串行执行，执行完毕后自动结束。 下面对源码进行简单的解析，IntentService 源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public abstract class IntentService extends Service &#123; private volatile Looper mServiceLooper; private volatile ServiceHandler mServiceHandler; private String mName; private boolean mRedelivery; private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; //onHandleIntent 方法在工作线程中执行，执行完调用 stopSelf() 结束服务。 onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125; &#125; /** * Creates an IntentService. Invoked by your subclass's constructor. * * @param name Used to name the worker thread, important only for debugging. */ public IntentService(String name) &#123; super(); mName = name; &#125; /** * enabled == true 时，如果任务没有执行完，当前进程就死掉了，那么系统就会令当前进程重启。 * 任务会被重新执行。 */ public void setIntentRedelivery(boolean enabled) &#123; mRedelivery = enabled; &#125; @Override public void onCreate() &#123; super.onCreate(); // 上面已经讲过，HandlerThread 对象 start 之后，会在工作线程里创建消息队列 和 Looper 对象。 HandlerThread thread = new HandlerThread("IntentService[" + mName + "]"); thread.start(); mServiceLooper = thread.getLooper(); // 获得 Looper 对象初始化 Handler 对象。 mServiceHandler = new ServiceHandler(mServiceLooper); &#125; @Override public void onStart(@Nullable Intent intent, int startId) &#123; // IntentService 每次启动都会往工作线程消息队列中添加消息，不会创建新的线程。 Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); &#125; // 官方建议 IntentService onStartCommand 方法不应该被重写，注意该方法会调用 onStart 。 @Override public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123; onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY; &#125; @Override public void onDestroy() &#123; //服务停止会清除消息队列中的消息，除了当前执行的任务外，后续的任务不会被执行。 mServiceLooper.quit(); &#125; /** * 不建议通过 bind 启动 IntentService ，如果通过 bind 启动 IntentService ，那么 onHandlerIntent 方法不会被回调。Activity 与 IntentService 之间的通信一般采用广播的方式。 */ @Override @Nullable public IBinder onBind(Intent intent) &#123; return null; &#125; /** * 子类必须要实现，执行具体的异步任务逻辑，由 IntentService 自动回调。 */ @WorkerThread protected abstract void onHandleIntent(@Nullable Intent intent);&#125; IntentService 源码很容易理解，你也可以就自己的应用场景封装自己的 IntentService 。 场景 正常情况下，启动 IntentService ，任务完成，服务停止； 异步任务完成前，停止 IntentService ，服务停止，但任务还会执行完成，完成后，工作线程结束； 多次启动 IntentService ，任务会被一次串行执行，执行结束后，服务停止； 多次启动 IntentService ，在所有任务执行结束之前，停止 IntentService ，服务停止，除了当前执行的任务外，后续的任务不会被执行； ThreadPoolExcutor 图片来自 Jakob Jenkov 博客 ThreadPool用来管理一组工作线程，任务队列（ BlockingQueue ）中持有的任务等待着被线程池中的空闲线程执行。 常用构造方法：1234567ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue); corePoolSize 核心线程池容量，即线程池中所维持线程的最低数量。corePoolSize 初始值为 0 ，当有新任务加入到任务队列中，新的线程将被创建，这个时候即使线程池中存在空闲线程，只要当前线程数小于 corePoolSize ，那么新的线程依然被创建。 maximumPoolSize 线程池中所维持线程的最大数量。 keepAliveTime 空闲线程在没有新任务到来时的存活时间。 unit 参数 keepAliveTime 的时间单位。 workQueue 任务队列，必须是 BlockingQueue 。 简单使用创建 ThreadFactory ，当然也可以自定义。1234567private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, "AsyncTask #" + mCount.getAndIncrement()); &#125;&#125;; 创建 ThreadPoolExecutor 。1234567891011// 根据 CPU 核心数确定线程池容量。public static final int NUMBER_OF_CORES = Runtime.getRuntime().availableProcessors(); mThreadPoolExecutor = new ThreadPoolExecutor( NUMBER_OF_CORES * 2, NUMBER_OF_CORES * 2 + 1, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), backgroundPriorityThreadFactory); 执行123456789101112131415161718192021222324252627282930313233343536373839404142mThreadPoolExecutor.execute(new Runnable() &#123; @Override public void run() &#123; //do something &#125; &#125;);Future future = mThreadPoolExecutor.submit(new Runnable() &#123; @Override public void run() &#123; //do something &#125; &#125;);//任务可取消future.cancel(true);Future&lt;Integer&gt; futureInt = mThreadPoolExecutor.submit(new Callable&lt;Integer&gt;() &#123; @override public Integer call() throws Exception &#123; return 0; &#125;&#125;);//获取执行结果futureInt.get();FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;()&#123; @override public Integer call() throws Exception &#123; return 0; &#125; &#125;);mThreadPoolExecutor.submit(task);task.get();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Clean 架构浅析]]></title>
      <url>%2F2017%2F04%2F15%2FAndroid-Clean-%E6%9E%B6%E6%9E%84%E6%B5%85%E6%9E%90%2F</url>
      <content type="text"><![CDATA[死磕 Android 架构也是一种娱乐 Android 常用的架构主要有 MVC，MVP，MVVM 以及 Clean 。以上架构设计模式没有绝对的优劣之分，关键要看具体的应用场景。更多关于 MVC，MVP 以及 MVVM 介绍可以参考MVC,MVP &amp; MVVM 什么是 Clean 架构？ Robert C. Martin (Uncle Bob) Clean 架构是由 Uncle Bob 在 2012 年发表的, 针对 Web App 的架构设计。 Bob大叔总结了各种系统架构的共通之处以及最终目标，并提出只需秉持分层与依赖规则的原则, 提出了 Clean 架构思想。 Clean 架构浅析单向依赖 图片来自 Robert C. Martin (Uncle Bob) Clean 架构各层之间的依赖是单向的，只能是外层依赖内层。 MVP VS Clean 图片来自 Google 从上图可以看到 Clean 架构的 Android 实现，实际上是对目前比较流行的 MVP 架构进行改造。 MVP 之 View 和 Presenter 层作为 Clean 架构的 Presentations Layer, 新增 Domain Layer 处理所有的业务逻辑。MVP 中的 Model 层功能被弱化，作为 Data Layer 对外只提供接口，不再有业务逻辑。 一般来说每一层都有独立的数据模型。 Clean 之 Presentation 层包含如下类： Presenter 和 View 层相关类，当然你也可以在 MVVP 架构基础之上进行改造。 Mapper 类，负责将 Domain 层的数据模型转换为 Presentation 的数据模型。 本层的异常封装类。 Clean 之 Domain 层Domain 层不依赖于 Android 类库和第三方库，可以独立做单元测试。 包含如下类： Use Cases (Interactor）类，负责完成对 Data 层的某一操作行为。（如获取 movie list ,获取某一 movie 的 detail info 可视为 2 个 Use Case 或 Interactor）。 Mapper 类，负责将 Data 层的数据模型转换为 Domain 层的数据模型。 本层的异常封装类。 Clean 之 Data 层 图片来自 Robert C. Martin (Uncle Bob) 这张图就足够说明一切了。 包含各种 API 接口，主要对应数据库操作，文件操作以及网络数据操作，一些异常封装类。Mapper 类，负责将网络数据模型转换为 Data 层的数据模型。 注意 Data 层只提供接口，没有业务逻辑。 Android Clean 架构实现一个基于 Clean 架构以及 Retrofit ， RxKotlin ， Dagger 框架实现的 Kotlin for Android App 。 更多 https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean/ https://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RecyclerView 加载与刷新功能实现]]></title>
      <url>%2F2017%2F04%2F13%2FRecyclerView-%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%88%B7%E6%96%B0%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[坚持就是进步 最近 Kotlin Android 开发貌似要火起来，Kotlin 具有脚本语言风格，能与 Java 无缝兼容，并且有 Google 有意栽培。 RecyclerView 加载与刷新功能实现RecyclerView 功能及灵活性强大到令人发指。在开发中，完全可以用它代替 ListView 和 GridView ，并且还具有瀑布流展示功能。 本文主要对 RecyclerView 进行简单的封装，来实现加载、刷新以及异常状态展示多种功能，实现及其简单，代码量很少。 效果展示 Demo 下载 源码地址: https://github.com/githubhaohao/JCRecyclerView 具体实现JCRecyclerView 继承 RecyclerView ，保留 RecyclerView 的所有特性。 内部类 JCAdapter 对外部的 RecyclerView Adapter 进行拦截改造，实现根据配置在 position = 0 的位置加载 Ad-Slot View （广告位），加载时在底部显示 Bottom View 表视加载正在进行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112private class JCAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; &#123; private RecyclerView.Adapter adapter; private static final int TYPE_ADSLOT = 0x10; private static final int TYPE_NORMAL = 0x11; private static final int TYPE_BOTTOM = 0x12; public JCAdapter(RecyclerView.Adapter adapter) &#123; this.adapter = adapter; &#125; @Override public void onViewAttachedToWindow(ViewHolder holder) &#123; super.onViewAttachedToWindow(holder); ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams(); if(layoutParams != null)&#123; if(adSlotView != null) &#123; if(layoutParams instanceof StaggeredGridLayoutManager.LayoutParams &amp;&amp; holder.getLayoutPosition() == 0)&#123; StaggeredGridLayoutManager.LayoutParams p = (StaggeredGridLayoutManager.LayoutParams) layoutParams; p.setFullSpan(true); &#125; &#125; if (bottomView != null &amp;&amp; isLoading) &#123; if(layoutParams instanceof StaggeredGridLayoutManager.LayoutParams &amp;&amp; holder.getLayoutPosition() == getItemCount() - 1)&#123; StaggeredGridLayoutManager.LayoutParams p = (StaggeredGridLayoutManager.LayoutParams) layoutParams; p.setFullSpan(true); &#125; &#125; &#125; if (layoutManager instanceof GridLayoutManager) &#123; final GridLayoutManager gridManager = ((GridLayoutManager) layoutManager); gridManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() &#123; @Override public int getSpanSize(int position) &#123; boolean spanResult = false; if(adSlotView != null &amp;&amp; bottomView != null) &#123; if (isLoading) &#123; spanResult = (position == 0 || position == getItemCount() - 1); &#125; else &#123; spanResult = (position == 0); &#125; &#125; else if (adSlotView != null) &#123; spanResult = (position==0); &#125; else if (bottomView != null &amp;&amp; isLoading) &#123; spanResult = (position == getItemCount() - 1); &#125; return spanResult ? gridManager.getSpanCount():1; &#125; &#125;); &#125; &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; if (viewType == TYPE_ADSLOT) &#123; return new JCViewHolder(adSlotView); &#125; else if (viewType == TYPE_BOTTOM) &#123; return new JCViewHolder(bottomView); &#125; return adapter.onCreateViewHolder(parent,viewType); &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; if (getItemViewType(0) == TYPE_ADSLOT) &#123; if (position == 0) return; int newPosition = --position; if (adapter != null) &#123; if (newPosition &lt; adapter.getItemCount()) &#123; adapter.onBindViewHolder(holder, newPosition); &#125; &#125; return; &#125; else if (getItemViewType(position) == TYPE_BOTTOM) &#123; return; &#125; adapter.onBindViewHolder(holder, position); &#125; @Override public int getItemCount() &#123; int count = adapter.getItemCount(); if (adSlotView != null) &#123; count ++; &#125; if (bottomView != null &amp;&amp; isLoading) &#123; count ++; &#125; return count; &#125; @Override public int getItemViewType(int position) &#123; if (position == 0) &#123; return adSlotView == null ? TYPE_NORMAL : TYPE_ADSLOT; &#125; else if (position == getItemCount() - 1 &amp;&amp; isLoading) &#123; return bottomView == null ? TYPE_NORMAL : TYPE_BOTTOM; &#125; else &#123; return TYPE_NORMAL; &#125; &#125;&#125; 向外暴露一个接口 OnLoadMoreListener ，完成加载时的回调。123public interface OnLoadMoreListener &#123; void onLoadMore();&#125; 整体思路就是这些，完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268public class JCRecyclerView extends RecyclerView &#123; private static final String TAG = JCRecyclerView.class.getSimpleName(); private LayoutManager layoutManager; private ViewGroup adSlotView; private ViewGroup stateView; private ViewGroup bottomView; private boolean isLoading = false; private JCAdapter jcAdapter; private OnLoadMoreListener onLoadMoreListener; public void addOnLoadMoreListener(OnLoadMoreListener listener) &#123; this.onLoadMoreListener = listener; this.addOnScrollListener(new OnScrollListener() &#123; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; if (recyclerView.getLayoutManager() instanceof StaggeredGridLayoutManager) &#123; StaggeredGridLayoutManager layoutManager = (StaggeredGridLayoutManager) recyclerView.getLayoutManager(); int totalItemCount = recyclerView.getAdapter().getItemCount(); int[] lastVisibleItemPositions = new int[layoutManager.getSpanCount()]; layoutManager.findLastVisibleItemPositions(lastVisibleItemPositions); int visibleItemCount = recyclerView.getChildCount(); int lastVisibleItemPosition = findMaxPosition(lastVisibleItemPositions); if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; lastVisibleItemPosition == totalItemCount - 1 &amp;&amp; visibleItemCount &gt; 0) &#123; if (bottomView == null || isLoading || stateView != null) return; isLoading = true; jcAdapter.notifyDataSetChanged(); onLoadMoreListener.onLoadMore(); scrollToPosition(jcAdapter.getItemCount() - 1); &#125; &#125; else &#123; LinearLayoutManager lm = (LinearLayoutManager) recyclerView.getLayoutManager(); int totalItemCount = recyclerView.getAdapter().getItemCount(); int lastVisibleItemPosition = lm.findLastVisibleItemPosition(); int visibleItemCount = recyclerView.getChildCount(); if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; lastVisibleItemPosition == totalItemCount - 1 &amp;&amp; visibleItemCount &gt; 0) &#123; if (bottomView == null || isLoading || stateView != null) return; isLoading = true; jcAdapter.notifyDataSetChanged(); onLoadMoreListener.onLoadMore(); scrollToPosition(jcAdapter.getItemCount() - 1); &#125; &#125; &#125; &#125;); &#125; private int findMaxPosition(int[] positions) &#123; int max = positions[0]; for (int index = 1; index &lt; positions.length; index++) &#123; if (positions[index] &gt; max) &#123; max = positions[index]; &#125; &#125; return max; &#125; public void setBottomView(ViewGroup view) &#123; if (bottomView == null) &#123; this.bottomView = view; &#125; &#125; public void setLoading(boolean flag) &#123; if (!flag) &#123; isLoading = false; jcAdapter.notifyDataSetChanged(); scrollToPosition(jcAdapter.getItemCount() - 1); &#125; &#125; public void setAdSlotView(ViewGroup view) &#123; if (adSlotView == null) &#123; adSlotView = view; if (jcAdapter != null) &#123; jcAdapter.notifyItemInserted(0); scrollToPosition(0); &#125; &#125; &#125; public void setStateView(ViewGroup view) &#123; if (stateView != null) return; if (view == null) return; if (adSlotView != null) &#123; scrollToPosition(0); stateView = view; Rect rect = new Rect(); getGlobalVisibleRect(rect); LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, rect.bottom - rect.top - adSlotView.getHeight()); adSlotView.addView(stateView, layoutParams); &#125; else &#123; showToast("You should set the ad-slot view at first."); &#125; &#125; public void removeAdSlotView() &#123; if (adSlotView != null &amp;&amp; jcAdapter != null) &#123; adSlotView = null; jcAdapter.notifyItemRemoved(0); &#125; &#125; public void removeStateView() &#123; if (adSlotView != null &amp;&amp; stateView != null &amp;&amp; jcAdapter != null) &#123; adSlotView.removeView(stateView); stateView = null; &#125; &#125; @Override public void setAdapter(Adapter adapter) &#123; this.jcAdapter = new JCAdapter(adapter); super.setAdapter(this.jcAdapter); &#125; public JCRecyclerView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public void setLayoutManager(LayoutManager layoutManager) &#123; this.layoutManager = layoutManager; super.setLayoutManager(layoutManager); &#125; private class JCAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; &#123; private RecyclerView.Adapter adapter; private static final int TYPE_ADSLOT = 0x10; private static final int TYPE_NORMAL = 0x11; private static final int TYPE_BOTTOM = 0x12; public JCAdapter(RecyclerView.Adapter adapter) &#123; this.adapter = adapter; &#125; @Override public void onViewAttachedToWindow(ViewHolder holder) &#123; super.onViewAttachedToWindow(holder); ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams(); if(layoutParams != null)&#123; if(adSlotView != null) &#123; if(layoutParams instanceof StaggeredGridLayoutManager.LayoutParams &amp;&amp; holder.getLayoutPosition() == 0)&#123; StaggeredGridLayoutManager.LayoutParams p = (StaggeredGridLayoutManager.LayoutParams) layoutParams; p.setFullSpan(true); &#125; &#125; if (bottomView != null &amp;&amp; isLoading) &#123; if(layoutParams instanceof StaggeredGridLayoutManager.LayoutParams &amp;&amp; holder.getLayoutPosition() == getItemCount() - 1)&#123; StaggeredGridLayoutManager.LayoutParams p = (StaggeredGridLayoutManager.LayoutParams) layoutParams; p.setFullSpan(true); &#125; &#125; &#125; if (layoutManager instanceof GridLayoutManager) &#123; final GridLayoutManager gridManager = ((GridLayoutManager) layoutManager); gridManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() &#123; @Override public int getSpanSize(int position) &#123; boolean spanResult = false; if(adSlotView != null &amp;&amp; bottomView != null) &#123; if (isLoading) &#123; spanResult = (position == 0 || position == getItemCount() - 1); &#125; else &#123; spanResult = (position == 0); &#125; &#125; else if (adSlotView != null) &#123; spanResult = (position==0); &#125; else if (bottomView != null &amp;&amp; isLoading) &#123; spanResult = (position == getItemCount() - 1); &#125; return spanResult ? gridManager.getSpanCount():1; &#125; &#125;); &#125; &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; if (viewType == TYPE_ADSLOT) &#123; return new JCViewHolder(adSlotView); &#125; else if (viewType == TYPE_BOTTOM) &#123; return new JCViewHolder(bottomView); &#125; return adapter.onCreateViewHolder(parent,viewType); &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; if (getItemViewType(0) == TYPE_ADSLOT) &#123; if (position == 0) return; int newPosition = --position; if (adapter != null) &#123; if (newPosition &lt; adapter.getItemCount()) &#123; adapter.onBindViewHolder(holder, newPosition); &#125; &#125; return; &#125; else if (getItemViewType(position) == TYPE_BOTTOM) &#123; return; &#125; adapter.onBindViewHolder(holder, position); &#125; @Override public int getItemCount() &#123; int count = adapter.getItemCount(); if (adSlotView != null) &#123; count ++; &#125; if (bottomView != null &amp;&amp; isLoading) &#123; count ++; &#125; return count; &#125; @Override public int getItemViewType(int position) &#123; if (position == 0) &#123; return adSlotView == null ? TYPE_NORMAL : TYPE_ADSLOT; &#125; else if (position == getItemCount() - 1 &amp;&amp; isLoading) &#123; return bottomView == null ? TYPE_NORMAL : TYPE_BOTTOM; &#125; else &#123; return TYPE_NORMAL; &#125; &#125; &#125; private class JCViewHolder extends RecyclerView.ViewHolder &#123; public JCViewHolder(View itemView) &#123; super(itemView); &#125; &#125; private void showToast(String msg) &#123; Toast.makeText(getContext(),msg,Toast.LENGTH_SHORT).show(); &#125; public interface OnLoadMoreListener &#123; void onLoadMore(); &#125;&#125; 200 多行代码，轻松实现 RecyclerView 刷新、加载以及异常状态的展示功能。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android jar 与 aar]]></title>
      <url>%2F2017%2F04%2F01%2FAndroid-jar-%E4%B8%8E-aar%2F</url>
      <content type="text"><![CDATA[愚人节不愚人 最近开始搞机器学习，同时项目也不停的维护着！嘿嘿，明天就是小长假了。 Android jar 与 aarjar (Java Application Resource) 是一种归档文件，以 ZIP 格式构建，以 .jar 为文件扩展名。用户可以使用JDK自带的 jar 命令创建或提取 JAR 文件。jar 文件只包含 class 文件和 配置文件。 aar (Android Application Resource) 是 android 中特有的归档文件，既包含 class 文件也包含 android 的 res 资源文件。 Android Studio 生成 jar 和 aar 文件新建一个 ModuleAndroid studio 菜单 File -&gt; New -&gt; New Module -&gt; Android Module 。 创建名为 mylibrary 的 module。 在 mylibrary 下新建一个类 Person ,等会在 app module 下访问它。 生成 jar 和 aar 文件直接 Rebuild 或者运行 mylibrary task 如下图： Build Successful 之后可在下图的目录下找到 jar 和 arr 文件。 引入 jar 将 jar 文件拷贝到 app 的 lib 文件夹下； 右击 jar 文件，选择 Add As Library ，添加到 app module 下，然后 Android Studio 会自动编译。 引入 aar 将 aar 文件拷贝到 app 的 lib 文件夹下 (可以修改 aar 文件名字，本例中修改为 mylibrary )； 修改 build.gradle 配置文件：12345678910111213android &#123; ...... repositories &#123; flatDir &#123; dirs 'libs' &#125; &#125;&#125;dependencies &#123; ...... compile(name: 'mylibrary', ext: 'aar') &#125; Async Project 大工告成。 同样，你也可以在其他工程中引入 jar 或 aar 文件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 四大组件之 Activity]]></title>
      <url>%2F2017%2F03%2F01%2FAndroid-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8B-Activity%2F</url>
      <content type="text"><![CDATA[唉！最近拖延症又犯了 最近真的是越来越懒了，总是找各种理由不写博客。虽然最近各种事，又搞论文，又搞项目的，再拖下去实在是对不住 “不忘初心” 这一句话。惭愧！虽然关于 Activity 已经被写烂了，但是从本篇文章里，你一定会发现不同的东西。 Activity 生命周期一般情况下 12345678910111213public class Activity extends ApplicationContext &#123; protected void onCreate(Bundle savedInstanceState); protected void onStart(); protected void onResume(); protected void onPause(); protected void onStop(); protected void onDestroy();&#125; 异常情况下系统配置变化导致Activity销毁重建 旋转屏幕，Activity 销毁并重新创建，在异常情况下系统会在 onStop 之前调用 onSaveInstanceState 来保存状态。Activity 重新创建后，会在 onStart 之后调用 onRestoreInstanceState 恢复之前保存的数据。 系统只在 Activity 异常终止的时候才会调用 onSaveInstanceState 和 onRestoreInstanceState 方法。其他情况不会触发。 资源内存不足导致低优先级的 Activity 被回收 前台- 可见非前台（被对话框遮挡的 Activity ）-后台，这三种 Activity 优先级从高到低。 android:configChanges=&quot;orientation&quot; 在 manifest 中指定 configChanges 在系统配置变化后不重新创建 Activity，也不会执行onSaveInstanceState 和 onRestoreInstanceState 方法，而是调用 onConfigurationChnaged 方法。 configChanges 一般常用三个选项： locale 系统语言变化 keyborardHidden 键盘的可访问性发生了变化，比如用户调出了键盘 orientation 屏幕方向变化 场景首次启动 Activity123MainActivity onCreateMainActivity onStartMainActivity onResume 跳转到 SecondActivity12345MainActivity onPauseSecondActivity onCreateSecondActivity onStartSecondActivity onResumeMainActivity onStop Back 返回 MainActivity123456SecondActivity onPauseMainActivity onRestartMainActivity onStartMainActivity onResumeSecondActivity onStopSecondActivity onDestroy Home 回退桌面12MainActivity onPauseMainActivity onStop 桌面返回可见123MainActivity onRestartMainActivity onStartMainActivity onResume 锁屏12MainActivity onPauseMainActivity onStop 解锁屏123MainActivity onRestartMainActivity onStartMainActivity onResume 注意onStart 开始到 onStop 之前， Activity 可见。onResume 开始到 onPause 之前， Activity 可接受用户交互。在新Activity启动之前，栈顶的Activity需要先onPause后，新Activity才能启动。所以不能在onPause执行耗时操作。 Activity 数据传递Activity 传递数据一般有以下几种方式： Intent 传递数据MainActivity 123456Intent intent=new Intent(); intent.setClass(MainActivity.this, OtherActivity.class); Bundle bundle = new Bundle(); bundle.putString(KEY, VALUE);intent.putExtras(bundle); startActivity（intent）; OtherActivity 123Intent intent = getIntent(); Bundle bundle = intent.getEtras(); String value = bundle.getString(KEY); 利用 Intent 对象在 Activity 之间传递数据是 Android 开发最常用的方式。利用 Intent 对象可以传递基本数据类型，以及一些可序列化的对象。 public 型的静态变量public 型的静态变量，在类被加载的时候，就被创建在静态存储区，不依赖于对象。 Application 对象在整个应用程序中就一个Application单例，它的生命周期贯穿整个程序，堆内存中只存在一个对象实例，所以程序内所有它的引用指向的是同一块堆内存，所以可以在不同activity对application实例变量进行值的存取。不推荐。 Clipboard 剪切板ClipboardManager：该类是系统剪切板服务的接口，用来放入或取出全局剪切板中的文本。 1234ClipboardManager clipboardManager = (ClipboardManager)getSystemService(Context.CLIPBOARD_SERVICE);clipboardManager.setText(DATA.toString());&#125; 12ClipboardManager clipboardManager = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE); String data = clipboardManager.getText().toString(); Clipboard 也可以传递可序列化对象。 文件传值通过向本地文件写入和读取来传递数据。常用的如 SharedPrefrences 对象等。 数据库你自己想吧！ Activity 启动模式启动模式,简单地说就是 Activity 启动时的策略，在AndroidManifest.xml 中的标签的 android:launchMode 属性设置； 启动模式有4种，分别为 standard、singleTop、singleTask、singleInstance； standard 模式每次 startActivity 时，都创建 Activity 实例，并放入任务栈，该任务栈中，可以有多个同类 Activity 的实例。 应用场景：Your idea。 singleTop 模式栈顶不是该类型的 Activity，则创建一个新的 Activity。否则，回调该 Activity 实例的 onNewIntent 方法。 应用场景：接收通知消息启动的页面。 例如，对于推送比较频繁的应用，如果收到多个推送，每次都打开一个页面显示内容是不妥的。 singleTask 模式任务栈中不存在启动 Activity 的实例，则创建 Activity 放入任务栈。否则，回调该 Activity 的 onNewIntent 方法，并将该 Activity 置于栈顶，其以上的 Activity 都被弹出 (pop)。[onNewIntent + clearTop] 应用场景：作为应用的入口点。 例如，对于浏览器的主界面，不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走 onNewIntent ，并且会清空主界面上面的其他页面。 singleInstance 模式回退栈中，只有这一个Activity，没有其他Activity。 应用场景：闹铃的响铃界面。正在进行 QQ 聊天室时，闹铃响了，弹出一个对话形式的（以 SingleInstance 加载模式打开的）AlarmActivity，按了返回键之后回到 QQ 聊天界面，这是因为 Alarm Activity 所在的任务栈只有它一个元素， 因此退出之后这个任务栈空了。如果是以 SingleTask 打开 AlarmActivity，那么当闹铃响了的时候，按返回键应该进入闹铃设置界面。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 主题切换和多主题实现]]></title>
      <url>%2F2017%2F02%2F17%2FAndroid%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2%E5%92%8C%E5%A4%9A%E4%B8%BB%E9%A2%98%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[又是一个周末 白天和夜间模式Android官方在Support包从23.2版本开始提供支持白天夜间模式的主题 Theme.AppCompat.DayNight，也就是 DayNight Mode ，轻松实现主体无缝切换。 Theme.AppCompat.DayNight 可以根据系统时间切换 Theme.AppCompat (暗色) 和 Theme.AppCompat.Light ( 亮色 ) 两种主题。这将大大提高了阅读类应用的用户体验 同时还支持 Material Design。 需要注意的是，这个特性只支持 API v14 及以上的 Android 设备，在 API v14 以下的设备则会默认使用亮色的主题。 效果预览 具体过程1. 引入 support-v7:23.2+ 版本的依赖1compile 'com.android.support:appcompat-v7:25.1.1' 为保证主题风格的统一，所有的 Activity 类应继承 AppCompatActivity 。 2. 自定义实现 DayNight 主题 res 目录下新建 values-night 文件，拷贝修改 colors.xml 和 styles.xml 文件到 values-night，为 Night Model 下系统加载的 color资源，同样地也可以指定 Night Model 下加载的 drawable 资源在 drawable-night 文件夹中，同理 layout mipmap 资源加载也是如此。 123456&lt;style name="MyApp.DayNight.NoActionBar.Theme" parent="Theme.AppCompat.DayNight.NoActionBar"&gt; &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt; &lt;item name="android:textColorPrimary"&gt;@color/colorAccent&lt;/item&gt;&lt;/style&gt; 具体位置颜色设置看图： 在 AndroidManifest.xml 中声明，单个 Activity 的主题。 1234567891011121314151617&lt;application android:name=".MyApplication" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true"&gt; &lt;activity android:name=".MainActivity" android:label="@string/app_name" android:theme="@style/MyApp.DayNight.NoActionBar.Theme"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt;&lt;/application&gt; 或者整个 App 的主题 12345678910111213141516171819&lt;application android:name=".MyApplication" android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/MyApp.DayNight.NoActionBar.Theme"&gt; &lt;activity android:name=".MainActivity" android:label="@string/app_name" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt;&lt;/application&gt; 3 设置 DayNight 主题初始化主题: 1234567891011private void initAppTheme() &#123; if (getThemeSharedPref().getBoolean(KEY_NIGHT_THEME, false)) &#123; getDelegate().setLocalNightMode(AppCompatDelegate.MODE_NIGHT_YES); &#125; else &#123; getDelegate().setLocalNightMode(AppCompatDelegate.MODE_NIGHT_NO); &#125;&#125;private SharedPreferences getThemeSharedPref() &#123; return getSharedPreferences("APP_THEME", Context.MODE_PRIVATE);&#125; 初始化主题应该在 super.onCreate() 之前执行，不然 Activity 会启动 2 次,下图为证： 切换主题： 1234567if (id == R.id.set_day_theme) &#123; getDelegate().setLocalNightMode(AppCompatDelegate.MODE_NIGHT_NO); getThemeSharedPref().edit().putBoolean(KEY_NIGHT_THEME,false).apply();&#125; else if (id == R.id.set_night_theme) &#123; getDelegate().setLocalNightMode(AppCompatDelegate.MODE_NIGHT_YES); getThemeSharedPref().edit().putBoolean(KEY_NIGHT_THEME, true).apply();&#125; 切换主题会重启 Activity。 DayNight Theme 有 4 种 Model ，分别是： MODE_NIGHT_NO. 使用 Day 主题 MODE_NIGHT_YES. 使用暗色 Night 主题 MODE_NIGHT_AUTO. 根据系统时间自动切换 MODE_NIGHT_FOLLOW_SYSTEM(默认选项). 设置为跟随系统 多主题实现介绍几种换肤的第三方库。 MultipleTheme 真正的支持无缝换肤／夜间模式的Android框架，配合theme和换肤控件框架可以做到无缝切换换肤（无需重启应用和当前页面）。 该应用框架可以实现无缝换肤／切换夜间模式的需求，需要在换肤／切换夜间模式的界面只需要使用框架里的自封装控件，其他界面的控件使用原生android控件即可。 缺陷：各种控件都需要重定义。优势：扩展性强，无需重启 Activity。 Colorful [推荐] Colorful is a dynamic theme library allowing you to change your apps’ color schemes easily. 缺陷：主题颜色可定制性差，不支持 Material Design 风格。优势：使用方便。 Prism Prism 下含有三个库： prsim 库含有一些核心功能； prism-viewpager 库实现了核心库与 ViewPager 的对接； prism-palette 库实现了核心库与 Palette 的对接。 分成三个库是为了区分依赖条件：核心库不依赖外部条件，它能够很容易地添加到你的工程之中；但是 prism-viewpager 和 prism-palette 需要依赖相应的support库。所以当你的程序不使用这些依赖库时，你可以只使用 prism 库来省去不必要的依赖条件。不过当你的程序中使用了 ViewPager 时，即已经对相关的support库有了依赖，那么添加 prism-viewpager 库就不需要额外的依赖条件。 但是，作者已停止更新。 Android-Skin-Loader [推荐]看效果 项目目录： Android-Skin-Loader├── android-skin-loader-lib // 皮肤加载库├── android-skin-loader-sample // 皮肤库应用实例├── android-skin-loader-skin // 皮肤包生成demo└── skin-package // 皮肤包输出目录 可以将皮肤文件打包分离，支持在线换肤，皮肤共享，不会重启 Activity 或 Fragment 。皮肤包（ 后缀名为.skin ）的本质是一个apk文件，该apk文件不包含代码，只包含资源文件。 缺陷：每个换肤的 View 都要设置 skin:enable=&quot;true&quot; 繁琐 ( 反正我感觉挺烦的 )，不支持 Material Design 风格。 不过，还好 ThemeSkinning 进行了优化，支持 Material Design 和字体的切换。 示例：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MVVM，RxJava 和 Retrofit 的一次实践]]></title>
      <url>%2F2017%2F02%2F12%2FMVVM%EF%BC%8CRxJava%E5%92%8CRetrofit%E7%9A%84%E4%B8%80%E6%AC%A1%E5%AE%9E%E8%B7%B5%2F</url>
      <content type="text"><![CDATA[春节后的第一篇博客 本文已授权微信公众号：鸿洋（hongyangAndroid）原创首发。原创文章，转载请注明出处:haohaochang.cn 效果预览 Demo 下载 准备知识MVC 视图层（View）：用户界面。 控制器层（Controller）：业务逻辑 模型层（Model）：数据保存 View 层传送指令到 Controller 层 Controller 层完成业务逻辑后，要求 Model 层改变状态 Model 层将新的数据发送到 View层，使用户得到反馈 缺陷:View 层和 Model 层是相互可知，耦合性大，像 Activity 或者 Fragment 既在 Controller 层，又在 View 层，造成工程的可扩展性可维护性非常差。 MVP 在 MVP 架构模式中，Controller 层变成了 Presenter 层。 MVP 模式各层之间的通信，都是双向的。 View 层与 Model 层不直接发生联系，都通过 Presenter 层进行间接通信。 Model 层与 Presenter 层，Presenter 层与 View 层之间通过接口建立联系。 采用 MVP 架构，Activity，Fragment 以及自定义 View 只位于 View 层。View 层：负责数据展示和用户交互；Presenter 层：充当中间人的角色，用来隔离 Model 层和 View 层，负责将 View 层的请求分发给 Model 处理，将 Model 层的反馈传递给 View 层；Model 层：封装数据来源，如网络数据，本地数据库数据。 MVP 的优势: 易于维护，测试，功能扩展； 易于分工协作编程； MVP 的缺陷: 由于我们使用了接口的方式去连接 View 层和 Presenter 层，这样就导致了特定场景下的一些问题，当你的页面逻辑很复杂的时候，你的 View 层实现的接口会有很多，如果你的 App 中有很多个这样复杂的页面，维护接口的成本就会变的非常的大。 增加代码类的数量，可读性差。 MVVM MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。区别在于: View 层与 ViewModel 层通过 DataBinding 相互绑定，View 层的变动，自动反映在 ViewModel 层，反之亦然。 Clean本篇只着重讲基于 RxJava 和 Retrofit 框架实现 MVVM 架构设计，想要了解 Clean 架构的同学，移步Android Clean 架构浅析。 另外这里有一个基于 Kotlin 实现的 Android 架构的例子 – 一个基于 Clean 架构以及 Retrofit ， RxKotlin ， Dagger 框架实现的 Kotlin for Android App。 RxJava Rx 是微软 .Net 的一个响应式扩展，Rx 借助可观测的序列提供一种简单的方式来创建异步的，基于事件驱动的程序。2012 年 Netflix 为了应对不断增长的业务需求开始将 .NET Rx 迁移到 JVM 上面。并于 13 年二月份正式向外展示了 RxJava 。 从语义的角度来看， RxJava 就是 .NET Rx 。从语法的角度来看， Netflix 考虑到了对应每个 Rx 方法,保留了 Java 代码规范和基本的模式。 RxJava 在 GitHub 主页的介绍是： RxJava is a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences. 一个在 Java VM 上使用可观测的序列来组成异步的、基于事件程序的库。 RxJava 本质上是一个异步操作库，是一个能让你用极其简洁的逻辑去处理繁琐复杂任务的异步事件库。 简而言之，RxJava 可以用几个关键字概括：简洁，队列化，异步。 Retrofit 一个 Android 和 Java 上 HTTP 库（利用注解和 OKHttp 来实现和服务器的数据交互）。 Retrofit 基于 OKHttp 并引入注解，使用简单，易扩展，易维护。 Retrofit 官方文档:http://square.github.io/retrofit/ DataBinding 在Google IO 2015 中，Google 在 support-v7 中新增了 Data Binding，使用 Data Binding可以直接在布局的 xml 中绑定布局与数据，从而简化代码，Android Data Binding是Android 的 MVVM 框架。因为 Data Binding 是包含在 support-v7 包里面的，所以可以向下兼容到最低 Android 2.1 (API level 7+). Data Binding 是实现 xml 文件与 java 代码交互的工具类库，通过观察者模式 Observable 变量集实现 ViewModel 层和 View 层的相互监听，自动交互。 实践直接上代码。 依赖的第三方类库123456compile 'io.reactivex:rxjava:1.1.0'compile 'io.reactivex:rxandroid:1.1.0'compile 'com.squareup.retrofit2:retrofit:2.0.0-beta4'compile 'com.squareup.retrofit2:converter-gson:2.0.0-beta4'compile 'com.squareup.retrofit2:adapter-rxjava:2.0.0-beta4'compile 'com.github.bumptech.glide:glide:3.7.0' API https://api.douban.com/v2/movie/top250?start=0&amp;count=20 引入DataBinding1234567android &#123; ...... dataBinding &#123; enabled = true &#125;&#125; 工程目录结构 详细源码：https://github.com/githubhaohao/MVVMRxJavaRetrofitSample MVVM 之 ViewMainActivity.java 1getFragmentManager().beginTransaction().add(R.id.movie_fragment, MovieFragment.getInstance()).commit(); MovieFragment.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MovieFragment extends Fragment implements CompletedListener,SwipeRefreshLayout.OnRefreshListener&#123; private static String TAG = MovieFragment.class.getSimpleName(); private MainViewModel viewModel; private MovieFragmentBinding movieFragmentBinding; private MovieAdapter movieAdapter; public static MovieFragment getInstance() &#123; return new MovieFragment(); &#125; @Nullable @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View contentView = inflater.inflate(R.layout.movie_fragment, container, false); movieFragmentBinding = MovieFragmentBinding.bind(contentView); initData(); return contentView; &#125; private void initData() &#123; movieAdapter = new MovieAdapter(); movieFragmentBinding.recyclerView.setLayoutManager(new LinearLayoutManager(getActivity(), LinearLayoutManager.VERTICAL, false)); movieFragmentBinding.recyclerView.setItemAnimator(new DefaultItemAnimator()); movieFragmentBinding.recyclerView.setAdapter(movieAdapter); movieFragmentBinding.swipeRefreshLayout.setColorSchemeResources(R.color.colorAccent, R.color.colorPrimary, R.color.colorPrimaryDark); movieFragmentBinding.swipeRefreshLayout.setOnRefreshListener(this); viewModel = new MainViewModel(movieAdapter,this); movieFragmentBinding.setViewModel(viewModel); &#125; @Override public void onRefresh() &#123; movieAdapter.clearItems(); viewModel.refreshData(); &#125; @Override public void onCompleted() &#123; if (movieFragmentBinding.swipeRefreshLayout.isRefreshing()) &#123; movieFragmentBinding.swipeRefreshLayout.setRefreshing(false); &#125; &#125;&#125; activity_main.xml 1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true" tools:context=".view.MainActivity"&gt; &lt;!-- ... --&gt; &lt;FrameLayout android:layout_marginTop="?attr/actionBarSize" android:layout_width="match_parent" android:layout_height="match_parent" android:id="@+id/movie_fragment"/&gt; &lt;!-- ... --&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; movie_fragment.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;data&gt; &lt;variable name="viewModel" type="com.jc.mvvmrxjavaretrofitsample.viewModel.MainViewModel"/&gt; &lt;/data&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v4.widget.SwipeRefreshLayout android:visibility="@&#123;viewModel.contentViewVisibility&#125;" android:id="@+id/swipe_refresh_layout" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/recycler_view" android:background="#ddd" android:layout_width="match_parent" android:layout_height="match_parent" android:padding="8dp"&gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;/android.support.v4.widget.SwipeRefreshLayout&gt; &lt;ProgressBar style="?android:attr/progressBarStyleLarge" android:id="@+id/progress_bar" android:visibility="@&#123;viewModel.progressBarVisibility&#125;" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true"/&gt; &lt;LinearLayout android:layout_width="match_parent" android:id="@+id/error_info_layout" android:visibility="@&#123;viewModel.errorInfoLayoutVisibility&#125;" android:orientation="vertical" android:layout_height="match_parent"&gt; &lt;TextView android:layout_gravity="center" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;viewModel.exception&#125;"/&gt; &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt;&lt;/layout&gt; movie_item.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/tools"&gt; &lt;data&gt; &lt;variable name="viewModel" type="com.jc.mvvmrxjavaretrofitsample.viewModel.MovieViewModel"/&gt; &lt;/data&gt; &lt;android.support.v7.widget.CardView xmlns:card_view="http://schemas.android.com/apk/res-auto" android:id="@+id/card_view" android:layout_width="match_parent" android:layout_height="wrap_content" card_view:cardCornerRadius="4dp" card_view:cardBackgroundColor="@color/background" card_view:cardUseCompatPadding="true"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;ImageView android:layout_margin="8dp" android:layout_width="60dp" android:layout_height="100dp" android:src="@drawable/cover" app:imageUrl="@&#123;viewModel.imageUrl&#125;" android:id="@+id/cover"/&gt; &lt;LinearLayout android:layout_width="wrap_content" android:layout_height="match_parent" android:layout_margin="8dp" android:orientation="vertical"&gt; &lt;TextView android:textColor="@android:color/black" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;viewModel.title&#125;" android:textSize="12sp"/&gt; &lt;LinearLayout android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="4dp" android:orientation="horizontal"&gt; &lt;android.support.v7.widget.AppCompatRatingBar android:id="@+id/ratingBar" style="?android:attr/ratingBarStyleSmall" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:isIndicator="true" android:max="10" android:numStars="5" android:rating="@&#123;viewModel.rating&#125;" /&gt; &lt;TextView android:id="@+id/rating_text" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:layout_marginLeft="6dp" android:text="@&#123;viewModel.ratingText&#125;" android:textColor="?android:attr/textColorSecondary" android:textSize="10sp" /&gt; &lt;/LinearLayout&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:textColor="?android:attr/textColorSecondary" android:textSize="10sp" android:text="@&#123;viewModel.movieType&#125;" android:id="@+id/movie_type_text" android:layout_marginTop="6dp" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:textColor="?android:attr/textColorSecondary" android:textSize="10sp" android:text="@&#123;viewModel.year&#125;" android:id="@+id/year_text" android:layout_marginTop="6dp" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/android.support.v7.widget.CardView&gt;&lt;/layout&gt; MovieAdapter.java 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MovieAdapter extends RecyclerView.Adapter&lt;MovieAdapter.BindingHolder&gt; &#123; private List&lt;Movie&gt; movies; public MovieAdapter() &#123; movies = new ArrayList&lt;&gt;(); &#125; @Override public BindingHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; MovieItemBinding itemBinding = DataBindingUtil.inflate(LayoutInflater.from(parent.getContext()), R.layout.movie_item, parent, false); return new BindingHolder(itemBinding); &#125; @Override public void onBindViewHolder(BindingHolder holder, int position) &#123; MovieViewModel movieViewModel = new MovieViewModel(movies.get(position)); holder.itemBinding.setViewModel(movieViewModel); &#125; @Override public int getItemCount() &#123; return movies.size(); &#125; public void addItem(Movie movie) &#123; movies.add(movie); notifyItemInserted(movies.size() - 1); &#125; public void clearItems() &#123; movies.clear(); notifyDataSetChanged(); &#125; public static class BindingHolder extends RecyclerView.ViewHolder &#123; private MovieItemBinding itemBinding; public BindingHolder(MovieItemBinding itemBinding) &#123; super(itemBinding.cardView); this.itemBinding = itemBinding; &#125; &#125;&#125; 回调接口 CompletedListener.java 123public interface CompletedListener &#123; void onCompleted();&#125; MVVM 之 ViewModelMainViewModel.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class MainViewModel &#123; public ObservableField&lt;Integer&gt; contentViewVisibility; public ObservableField&lt;Integer&gt; progressBarVisibility; public ObservableField&lt;Integer&gt; errorInfoLayoutVisibility; public ObservableField&lt;String&gt; exception; private Subscriber&lt;Movie&gt; subscriber; private MovieAdapter movieAdapter; private CompletedListener completedListener; public MainViewModel(MovieAdapter movieAdapter,CompletedListener completedListener) &#123; this.movieAdapter = movieAdapter; this.completedListener = completedListener; initData(); getMovies(); &#125; private void getMovies() &#123; subscriber = new Subscriber&lt;Movie&gt;() &#123; @Override public void onCompleted() &#123; Log.d("[MainViewModel]", "onCompleted"); hideAll(); contentViewVisibility.set(View.VISIBLE); completedListener.onCompleted(); &#125; @Override public void onError(Throwable e) &#123; hideAll(); errorInfoLayoutVisibility.set(View.VISIBLE); exception.set(e.getMessage()); &#125; @Override public void onNext(Movie movie) &#123; movieAdapter.addItem(movie); &#125; &#125;; RetrofitHelper.getInstance().getMovies(subscriber, 0, 20); &#125; public void refreshData() &#123; getMovies(); &#125; private void initData() &#123; contentViewVisibility = new ObservableField&lt;&gt;(); progressBarVisibility = new ObservableField&lt;&gt;(); errorInfoLayoutVisibility = new ObservableField&lt;&gt;(); exception = new ObservableField&lt;&gt;(); contentViewVisibility.set(View.GONE); errorInfoLayoutVisibility.set(View.GONE); progressBarVisibility.set(View.VISIBLE); &#125; private void hideAll()&#123; contentViewVisibility.set(View.GONE); errorInfoLayoutVisibility.set(View.GONE); progressBarVisibility.set(View.GONE); &#125;&#125; MovieViewModel.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MovieViewModel extends BaseObservable &#123; private Movie movie; public MovieViewModel(Movie movie) &#123; this.movie = movie; &#125; public String getCoverUrl() &#123; return movie.getImages().getSmall(); &#125; public String getTitle() &#123; return movie.getTitle(); &#125; public float getRating() &#123; return movie.getRating().getAverage(); &#125; public String getRatingText()&#123; return String.valueOf(movie.getRating().getAverage()); &#125; public String getYear() &#123; return movie.getYear(); &#125; public String getMovieType() &#123; StringBuilder builder = new StringBuilder(); for (String s : movie.getGenres()) &#123; builder.append(s + " "); &#125; return builder.toString(); &#125; public String getImageUrl() &#123; return movie.getImages().getSmall(); &#125; @BindingAdapter(&#123;"app:imageUrl"&#125;) public static void loadImage(ImageView imageView,String url) &#123; Glide.with(imageView.getContext()) .load(url) .placeholder(R.drawable.cover) .error(R.drawable.cover) .into(imageView); &#125;&#125; MVVM 之 ModelDouBanMovieService.java 123456public interface DouBanMovieService &#123; String BASE_URL = "https://api.douban.com/v2/movie/"; @GET("top250") Observable&lt;Response&lt;List&lt;Movie&gt;&gt;&gt; getMovies(@Query("start") int start, @Query("count") int count);&#125; RetrofitHelper.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class RetrofitHelper &#123; private static final int DEFAULT_TIMEOUT = 10; private Retrofit retrofit; private DouBanMovieService movieService; OkHttpClient.Builder builder; /** * 获取RetrofitHelper对象的单例 * */ private static class Singleton &#123; private static final RetrofitHelper INSTANCE = new RetrofitHelper(); &#125; public static RetrofitHelper getInstance() &#123; return Singleton.INSTANCE; &#125; public RetrofitHelper() &#123; builder = new OkHttpClient.Builder(); builder.connectTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS); retrofit = new Retrofit.Builder() .client(builder.build()) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .baseUrl(DouBanMovieService.BASE_URL) .build(); movieService = retrofit.create(DouBanMovieService.class); &#125; public void getMovies(Subscriber&lt;Movie&gt; subscriber, int start, int count) &#123; movieService.getMovies(start, count) .map(new Func1&lt;Response&lt;List&lt;Movie&gt;&gt;, List&lt;Movie&gt;&gt;() &#123; @Override public List&lt;Movie&gt; call(Response&lt;List&lt;Movie&gt;&gt; listResponse) &#123; return listResponse.getSubjects(); &#125; &#125;) .flatMap(new Func1&lt;List&lt;Movie&gt;, Observable&lt;Movie&gt;&gt;() &#123; @Override public Observable&lt;Movie&gt; call(List&lt;Movie&gt; movies) &#123; return Observable.from(movies); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(subscriber); &#125;&#125; 还有 entity 类，这里就不贴出来了。 详细源码：https://github.com/githubhaohao/MVVMRxJavaRetrofitSample]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6入门: 需要掌握的基本语法]]></title>
      <url>%2F2017%2F01%2F25%2FES6%E5%85%A5%E9%97%A8-%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[ES6是什么1. ES (ECMAScript) 和JavaScript的关系 ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现（另外的ECMAScript方言还有Jscript和ActionScript）。日常场合，这两个词是可以互换的。 2. ES6和ECMAScript 2015的关系ES6，一般是指ECMAScript 2015标准，但有时也表示一种泛指，是指JavaScript语言的下一代标准。涵盖了ECMAScript 2015，2016，2017等版本，而ECMAScript 2015则是正式名称，特指该年发布的正式版本的语言标准。 Babel转码器 Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。去官网选择自己习惯的工具来使用使用Babel吧！ let和const命令let和const与var类似都是用来声明变量的，但又有各自不同的用途。let与var对比，看代码： 12345678var name = 'haohao';if(true)&#123; var name = 'jack'; console.log(name) //jack&#125; console.log(name) //jack ES5只有全局作用域和块级作用域，导致内层变量覆盖外层变量，使得两次输出的都是jack。而let为JS新增了块级作用域，因此它声明的变量只在let命令所在的代码块有效，具体看代码： 12345678let name = 'haohao';if(true)&#123; let name = 'jack'; console.log(name) //jack&#125; console.log(name) //haohao const用来声明常量，一旦声明就不能改变。当我们尝试改变const声明的常量时，浏览器就会报错。 123const PI = Math.PI PI = 23 //Module build failed: SyntaxError: /es6/app.js: "PI" is read-only 引用其他Module中声明的变量，用const来声明可以避免对其重命名而导致出现BUG。 1const &#123;width, height&#125; = window.get('Dimension'); 解构 (Destructuring)解构 (Destructuring) 是指按照某种模式，从对象或数组中提取值对指定的变量进行赋值。 ES6之前为变量赋值： 123let name = 'jack';let addr = 'cn';let sex = 'male'; ES6可以这样： 12345let [name,addr,sex] = ['jack','cn','male'];name //jackaddr //cnsex //male 默认值: 12345let [name,addr,sex = 'male'] = ['jack','cn'];name //jackaddr //cnsex //male 关于对象以前这样： 1234567let name = 'jack';let addr = 'cn';let sex = 'male';let student = &#123; name:name, addr:addr, sex:sex &#125;console.log(student);//Object &#123; name:'jack', addr:'cn', sex:'male' &#125; ES6可以这样： 1234567let name = 'jack';let addr = 'cn';let sex = 'male';let student = &#123; name, addr, sex &#125;console.log(student);//Object &#123; name:'jack', addr:'cn', sex:'male' &#125; 还有这样: 123456let student = &#123; name:'kene', addr:'us', sex:'male' &#125;let &#123; name, sex &#125; = student;let &#123; addr &#125; = student;console.log(name, addr, sex);//kene us male 模板字符串 (template string)传统模板字符串： 12345$('#showId').append( "Hello，everyone!" + "I am Jack."+ "I like eat " + fruits + "!" ); ES6模板字符串： 12345$('#showId').append(` Hello，everyone! I am Jack. I like eat $&#123;fruits&#125;! `); 反引号标识起始，${}引入变量，所有的空格缩进保存输出。 箭头函数 (arrow functions)ES6允许使用“箭头”（=&gt;）定义函数。 12var func = i =&gt; i + 1;var func = (a, b) =&gt; &#123;a++; b++; return a + b;&#125; 上面的箭头函数等同于： 123456789var func = function(i) &#123; return i + 1;&#125;;var func = function(a, b) &#123; a++; b++; return a + b;&#125; 当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。有一种使用场景： 123456789101112131415class Person &#123; constructor()&#123; this.name = 'person'; &#125; sayHello()&#123; setTimeout(function()&#123; console.log(this.name + 'says hello.'); &#125;); &#125;&#125;let p = new Person();p.sayHello();//undefined says hello. 运行上面的代码会报错，这是因为setTimeout中的this指向的是全局对象。有了箭头函数上述问题便可迎刃而解： 123456789101112131415class Person &#123; constructor()&#123; this.name = 'person'; &#125; sayHello()&#123; setTimeout(() =&gt; &#123; console.log(this.name + 'says hello.'); &#125;); &#125;&#125;let p = new Person();p.sayHello();//person says hello. 类 (Class)ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。 123456789101112131415class Person &#123; constructor()&#123; this.name = 'person'; &#125; sayHello()&#123; setTimeout(() =&gt; &#123; console.log(this.name + 'says hello.'); &#125;); &#125;&#125;let p = new Person();p.sayHello();//person says hello. 上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。 ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 1234567891011class Student extends Person &#123; constructor()&#123; super(); this.name = 'student'; &#125;&#125;let s = new Student();s.sayHello();//student says hello. 上面定义了一个Student类，该类通过extends关键字，继承了Person类的所有属性和方法。 子类Student必须在constructor方法中调用super方法，否则新建实例时会报错,子类就得不到this对象。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。 export和importES6的模块化功能。以前这样写： 12345678//content.jsmodule.exports = 'apple';//index.jsvar fruits = require('./content.js');console.log(fruits);//apple ES6这样： 12345678//content.jsexport default 'apple';//index.jsimport fruits from './content.js';console.log(fruits);//apple 深入点，看代码： 12345678910111213141516171819//content.jsexport const KIND = 'Thailand Apple';export default 'apple';export function say()&#123; return 'I like apple!';&#125; //index.jsimport fruits, &#123; say, KIND &#125; from './content.js';//如果只导入say //import &#123; say &#125; from './content.js';console.log(fruits);console.log(KIND);say();//apple //Thailand Apple//I like apple! 修改变量名。 123456789101112131415161718//content.jsexport const KIND = 'Thailand Apple';export default 'apple';export function say()&#123; return 'I like apple!';&#125; //index.jsimport fruits, &#123; say, KIND as type &#125; from './content.js';console.log(fruits);console.log(type);say();//apple //Thailand Apple//I like apple! 整体加载,*为指定的一个对象。 123456789101112131415161718//content.jsexport const KIND = 'Thailand Apple';export default 'apple';export function say()&#123; return 'I like apple!';&#125; //index.jsimport fruits, * as content from './content.js';console.log(fruits);console.log(content.type);content.say();//apple //Thailand Apple//I like apple!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[分分钟接入Tinker]]></title>
      <url>%2F2017%2F01%2F18%2F%E5%88%86%E5%88%86%E9%92%9F%E6%8E%A5%E5%85%A5Tinker%2F</url>
      <content type="text"><![CDATA[Tinker是什么 Tinker是微信官方的Android热补丁解决方案，它支持动态下发代码、So库以及资源，让应用能够在不需要重新安装的情况下实现更新。当然，你也可以使用Tinker来更新你的插件。它主要包括以下几个部分： 1.gradle编译插件: tinker-patch-gradle-plugin 2.核心sdk库: tinker-android-lib 3.非gradle编译用户的命令行版本: tinker-patch-cli.jar 引入依赖和插件在你项目根目录下的 build.gradle 文件中添加: 12345buildscript &#123; dependencies &#123; classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.7.6') &#125;&#125; 在 app/build.gradle 文件中添加依赖和插件： 1234567891011dependencies &#123; //optional, help to generate the final application provided('com.tencent.tinker:tinker-android-anno:1.7.6') //tinker's main Android lib compile('com.tencent.tinker:tinker-android-lib:1.7.6') compile "com.android.support:multidex:1.0.1"&#125;......apply plugin: 'com.tencent.tinker.patch' 添加task添加task tinkerPatch 在 app/build.gradle 文件中,其中 oldApk 路径为出现BUG的APK路径（自定义），添加完之后Async Project。 123456789101112131415161718192021222324252627282930313233343536373839404142tinkerPatch &#123; oldApk = "J://tinkerSample/app-debug.apk" ignoreWarning = true useSign = true buildConfig &#123; applyMapping = null applyResourceMapping = null tinkerId = "tinkerId" &#125; dex &#123; dexMode = "jar" usePreGeneratedPatchDex = false pattern = ["classes*.dex", "assets/secondary-dex-?.jar"] loader = ["com.tencent.tinker.loader.*", "com.jc.tinkersample.SimpleApp", "com.jc.tinkersample.BaseBuildInfo" ] &#125; lib &#123; pattern = ["lib/armeabi/*.so"] &#125; res &#123; pattern = ["res/*", "assets/*", "resources.arsc", "AndroidManifest.xml"] ignoreChange = ["assets/sample_meta.txt"] largeModSize = 100 &#125; packageConfig &#123; configField("patchMessage", "tinker is sample to use") configField("platform", "all") configField("patchVersion", "1.0") &#125; sevenZip &#123; zipArtifact = "com.tencent.mm:SevenZip:1.1.10" &#125;&#125; 接入Tinker自定义Application继承 DefaultApplicationLike 类，也可以自定义扩展。 12345678910111213141516171819202122@DefaultLifeCycle( application = "com.jc.tinkersample.SimpleApp", flags = ShareConstants.TINKER_ENABLE_ALL, loadVerifyFlag = false)public class SimpleAppLike extends DefaultApplicationLike &#123; public SimpleAppLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag, long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent, Resources[] resources, ClassLoader[] classLoader, AssetManager[] assetManager) &#123; super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent, resources, classLoader, assetManager); &#125; @Override public void onBaseContextAttached(Context base) &#123; super.onBaseContextAttached(base); MultiDex.install(base); TinkerInstaller.install(this); &#125; @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) public void registerActivityLifecycleCallbacks(Application.ActivityLifecycleCallbacks callback) &#123; getApplication().registerActivityLifecycleCallbacks(callback); &#125;&#125; 运行安装到你的手机里，然后把 app-debug.apk 放到 oldApk 对应的路径下，用于生成 patch.apk。 然后，修复你项目的bug（这里只是象征性地修改了一下Text），打开Android Studio 右侧的gradle project 运行 tinkerPatchDebug task生成patch.apk。 找到patch_signed_7zip.apk 文件。 复制 patch_signed_7zip.apk 文件把它放到手机外部存储目录下 （这里为根目录）。 12345678String path = Environment.getExternalStorageDirectory().getAbsolutePath() + "/patch_signed_7zip.apk";File file = new File(path);if (file.exists())&#123; Toast.makeText(this, "patch.apk is existing.", Toast.LENGTH_SHORT).show(); TinkerInstaller.onReceiveUpgradePatch(getApplicationContext(), path);&#125;else&#123; Toast.makeText(this,"patch.apk is inexistent.", Toast.LENGTH_SHORT).show();&#125; 调用Tinker API TinkerInstaller.onReceiveUpgradePatch(getApplicationContext(), path); 进行热修复，重启app热修复完成。 详细代码https://github.com/githubhaohao/TinkerSample 更多 微信Android热补丁实践演进之路 Android N混合编译与对热补丁影响深度解析 微信Tinker的一切都在这里，包括源码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F12%2F01%2FHello-World%2F</url>
      <content type="text"><![CDATA[合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。 不忘初心，不惧未来。haohao2017/01/14]]></content>
    </entry>

    
  
  
</search>
