<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[ES6入门: 需要掌握的基本语法]]></title>
      <url>%2F2017%2F01%2F25%2FES6%E5%85%A5%E9%97%A8-%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[ES6是什么1. ES (ECMAScript) 和JavaScript的关系ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现（另外的ECMAScript方言还有Jscript和ActionScript）。日常场合，这两个词是可以互换的。 阮一峰ECMAScript 2. ES6和ECMAScript 2015的关系ES6，一般是指ECMAScript 2015标准，但有时也表示一种泛指，是指JavaScript语言的下一代标准。涵盖了ECMAScript 2015，2016，2017等版本，而ECMAScript 2015则是正式名称，特指该年发布的正式版本的语言标准。 Babel转码器 Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。去官网选择自己习惯的工具来使用使用Babel吧！ let和const命令let和const与var类似都是用来声明变量的，但又有各自不同的用途。let与var对比，看代码： 12345678var name = 'haohao';if(true)&#123; var name = 'jack'; console.log(name) //jack&#125; console.log(name) //jack ES5只有全局作用域和块级作用域，导致内层变量覆盖外层变量，使得两次输出的都是jack。而let为JS新增了块级作用域，因此它声明的变量只在let命令所在的代码块有效，具体看代码： 12345678let name = 'haohao';if(true)&#123; let name = 'jack'; console.log(name) //jack&#125; console.log(name) //haohao const用来声明常量，一旦声明就不能改变。当我们尝试改变const声明的常量时，浏览器就会报错。 123const PI = Math.PI PI = 23 //Module build failed: SyntaxError: /es6/app.js: "PI" is read-only 引用其他Module中声明的变量，用const来声明可以避免对其重命名而导致出现BUG。 1const &#123;width, height&#125; = window.get('Dimension'); 解构 (Destructuring)解构 (Destructuring) 是指按照某种模式，从对象或数组中提取值对指定的变量进行赋值。 ES6之前为变量赋值： 123let name = 'jack';let addr = 'cn';let sex = 'male'; ES6可以这样： 12345let [name,addr,sex] = ['jack','cn','male'];name //jackaddr //cnsex //male 默认值: 12345let [name,addr,sex = 'male'] = ['jack','cn'];name //jackaddr //cnsex //male 关于对象以前这样： 1234567let name = 'jack';let addr = 'cn';let sex = 'male';let student = &#123; name:name, addr:addr, sex:sex &#125;console.log(student);//Object &#123; name:'jack', addr:'cn', sex:'male' &#125; ES6可以这样： 1234567let name = 'jack';let addr = 'cn';let sex = 'male';let student = &#123; name, addr, sex &#125;console.log(student);//Object &#123; name:'jack', addr:'cn', sex:'male' &#125; 还有这样: 123456let student = &#123; name:'kene', addr:'us', sex:'male' &#125;let &#123; name, sex &#125; = student;let &#123; addr &#125; = student;console.log(name, addr, sex);//kene us male 模板字符串 (template string)传统模板字符串： 12345$('#showId').append( "Hello，everyone!" + "I am Jack."+ "I like eat " + fruits + "!" ); ES6模板字符串： 12345$('#showId').append(` Hello，everyone! I am Jack. I like eat $&#123;fruits&#125;! `); 反引号标识起始，${}引入变量，所有的空格缩进保存输出。 箭头函数 (arrow functions)ES6允许使用“箭头”（=&gt;）定义函数。 12var func = i =&gt; i + 1;var func = (a, b) =&gt; &#123;a++; b++; return a + b;&#125; 上面的箭头函数等同于： 123456789var func = function(i) &#123; return i + 1;&#125;;var func = function(a, b) &#123; a++; b++; return a + b;&#125; 当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。有一种使用场景： 123456789101112131415class Person &#123; constructor()&#123; this.name = 'person'; &#125; sayHello()&#123; setTimeout(function()&#123; console.log(this.name + 'says hello.'); &#125;); &#125;&#125;let p = new Person();p.sayHello();//undefined says hello. 运行上面的代码会报错，这是因为setTimeout中的this指向的是全局对象。有了箭头函数上述问题便可迎刃而解： 123456789101112131415class Person &#123; constructor()&#123; this.name = 'person'; &#125; sayHello()&#123; setTimeout(() =&gt; &#123; console.log(this.name + 'says hello.'); &#125;); &#125;&#125;let p = new Person();p.sayHello();//person says hello. 类 (Class)ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。 123456789101112131415class Person &#123; constructor()&#123; this.name = 'person'; &#125; sayHello()&#123; setTimeout(() =&gt; &#123; console.log(this.name + 'says hello.'); &#125;); &#125;&#125;let p = new Person();p.sayHello();//person says hello. 上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。 ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 1234567891011class Student extends Person &#123; constructor()&#123; super(); this.name = 'student'; &#125;&#125;let s = new Student();s.sayHello();//student says hello. 上面定义了一个Student类，该类通过extends关键字，继承了Person类的所有属性和方法。 子类Student必须在constructor方法中调用super方法，否则新建实例时会报错,子类就得不到this对象。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。 export和importES6的模块化功能。以前这样写： 12345678//content.jsmodule.exports = 'apple';//index.jsvar fruits = require('./content.js');console.log(fruits);//apple ES6这样： 12345678//content.jsexport default 'apple';//index.jsimport fruits from './content.js';console.log(fruits);//apple 深入点，看代码： 12345678910111213141516171819//content.jsexport const KIND = 'Thailand Apple';export default 'apple';export function say()&#123; return 'I like apple!';&#125; //index.jsimport fruits, &#123; say, KIND &#125; from './content.js';//如果只导入say //import &#123; say &#125; from './content.js';console.log(fruits);console.log(KIND);say();//apple //Thailand Apple//I like apple! 修改变量名。 123456789101112131415161718//content.jsexport const KIND = 'Thailand Apple';export default 'apple';export function say()&#123; return 'I like apple!';&#125; //index.jsimport fruits, &#123; say, KIND as type &#125; from './content.js';console.log(fruits);console.log(type);say();//apple //Thailand Apple//I like apple! 整体加载,*为指定的一个对象。 123456789101112131415161718//content.jsexport const KIND = 'Thailand Apple';export default 'apple';export function say()&#123; return 'I like apple!';&#125; //index.jsimport fruits, * as content from './content.js';console.log(fruits);console.log(content.type);content.say();//apple //Thailand Apple//I like apple!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[分分钟接入Tinker]]></title>
      <url>%2F2017%2F01%2F18%2F%E5%88%86%E5%88%86%E9%92%9F%E6%8E%A5%E5%85%A5Tinker%2F</url>
      <content type="text"><![CDATA[Tinker是什么Tinker是微信官方的Android热补丁解决方案，它支持动态下发代码、So库以及资源，让应用能够在不需要重新安装的情况下实现更新。当然，你也可以使用Tinker来更新你的插件。它主要包括以下几个部分： 1.gradle编译插件: tinker-patch-gradle-plugin 2.核心sdk库: tinker-android-lib 3.非gradle编译用户的命令行版本: tinker-patch-cli.jar Tencenttinker 引入依赖和插件在你项目根目录下的 build.gradle 文件中添加: 12345buildscript &#123; dependencies &#123; classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.7.6') &#125;&#125; 在 app/build.gradle 文件中添加依赖和插件： 1234567891011dependencies &#123; //optional, help to generate the final application provided('com.tencent.tinker:tinker-android-anno:1.7.6') //tinker's main Android lib compile('com.tencent.tinker:tinker-android-lib:1.7.6') compile "com.android.support:multidex:1.0.1"&#125;......apply plugin: 'com.tencent.tinker.patch' 添加task添加task tinkerPatch 在 app/build.gradle 文件中,其中 oldApk 路径为出现BUG的APK路径（自定义），添加完之后Async Project。 123456789101112131415161718192021222324252627282930313233343536373839404142tinkerPatch &#123; oldApk = "J://tinkerSample/app-debug.apk" ignoreWarning = true useSign = true buildConfig &#123; applyMapping = null applyResourceMapping = null tinkerId = "tinkerId" &#125; dex &#123; dexMode = "jar" usePreGeneratedPatchDex = false pattern = ["classes*.dex", "assets/secondary-dex-?.jar"] loader = ["com.tencent.tinker.loader.*", "com.jc.tinkersample.SimpleApp", "com.jc.tinkersample.BaseBuildInfo" ] &#125; lib &#123; pattern = ["lib/armeabi/*.so"] &#125; res &#123; pattern = ["res/*", "assets/*", "resources.arsc", "AndroidManifest.xml"] ignoreChange = ["assets/sample_meta.txt"] largeModSize = 100 &#125; packageConfig &#123; configField("patchMessage", "tinker is sample to use") configField("platform", "all") configField("patchVersion", "1.0") &#125; sevenZip &#123; zipArtifact = "com.tencent.mm:SevenZip:1.1.10" &#125;&#125; 接入Tinker自定义Application继承 DefaultApplicationLike 类，也可以自定义扩展。 12345678910111213141516171819202122@DefaultLifeCycle( application = "com.jc.tinkersample.SimpleApp", flags = ShareConstants.TINKER_ENABLE_ALL, loadVerifyFlag = false)public class SimpleAppLike extends DefaultApplicationLike &#123; public SimpleAppLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag, long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent, Resources[] resources, ClassLoader[] classLoader, AssetManager[] assetManager) &#123; super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent, resources, classLoader, assetManager); &#125; @Override public void onBaseContextAttached(Context base) &#123; super.onBaseContextAttached(base); MultiDex.install(base); TinkerInstaller.install(this); &#125; @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) public void registerActivityLifecycleCallbacks(Application.ActivityLifecycleCallbacks callback) &#123; getApplication().registerActivityLifecycleCallbacks(callback); &#125;&#125; 运行安装到你的手机里，然后把 app-debug.apk 放到 oldApk 对应的路径下，用于生成 patch.apk。 然后，修复你项目的bug（这里只是象征性地修改了一下Text），打开Android Studio 右侧的gradle project 运行 tinkerPatchDebug task生成patch.apk。 找到patch_signed_7zip.apk 文件。 复制 patch_signed_7zip.apk 文件把它放到手机外部存储目录下 （这里为根目录）。 12345678String path = Environment.getExternalStorageDirectory().getAbsolutePath() + "/patch_signed_7zip.apk";File file = new File(path);if (file.exists())&#123; Toast.makeText(this, "patch.apk is existing.", Toast.LENGTH_SHORT).show(); TinkerInstaller.onReceiveUpgradePatch(getApplicationContext(), path);&#125;else&#123; Toast.makeText(this,"patch.apk is inexistent.", Toast.LENGTH_SHORT).show();&#125; 调用Tinker API TinkerInstaller.onReceiveUpgradePatch(getApplicationContext(), path); 进行热修复，重启app热修复完成。 详细代码https://github.com/githubhaohao/TinkerSample 更多 微信Android热补丁实践演进之路 Android N混合编译与对热补丁影响深度解析 微信Tinker的一切都在这里，包括源码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F01%2F12%2Fcover%2F</url>
      <content type="text"><![CDATA[合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。 老子 不忘初心，不惧未来。haohao2017/01/14]]></content>
    </entry>

    
  
  
</search>
