<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>haohao</title>
  <subtitle>不忘初心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://githubhaohao.github.io/"/>
  <updated>2017-05-25T12:52:35.222Z</updated>
  <id>https://githubhaohao.github.io/</id>
  
  <author>
    <name>haohao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java to Kotlin 语法清单</title>
    <link href="https://githubhaohao.github.io/2017/05/25/Java-to-Kotlin-%E8%AF%AD%E6%B3%95%E6%B8%85%E5%8D%95/"/>
    <id>https://githubhaohao.github.io/2017/05/25/Java-to-Kotlin-语法清单/</id>
    <published>2017-05-25T07:25:36.000Z</published>
    <updated>2017-05-25T12:52:35.222Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><img src="http://i1.piimg.com/588795/9c8514f7c56bb889.jpg" alt="Markdown"></p>

<p align="center">Today, at the Google I/O keynote, the Android team announced first-class support for Kotlin.</p>

<blockquote>
<p>Google IO 2017 宣布在 Android Studio 3.0 将默认支持 Kotlin 用于 Android . 请注意 Google 只是宣布 Kotlin 作为 Android 开发的一级语言，并没有说要用其取代 Java ，这里很多无脑媒体进行了过度解读。作为一名合格的程序员，首先要理性看待技术迭代更新，同时要对新事物保持强烈的好奇心。</p>
</blockquote>
<h2 id="Kotlin-简介"><a href="#Kotlin-简介" class="headerlink" title="Kotlin 简介"></a>Kotlin 简介</h2><p>Kotlin 来自于捷克一家牛逼软件研发公司 JetBrains ，很多优秀的 IDE，如 IntelliJ IDEA、Pycharm、WebStorm 等都是它的杰作，包括 Google 官方的 Android 开发 IDE – Android Studio ，也是 IntelliJ IDEA 的插件版。</p>
<p>Kotlin 源于 JetBrains 的圣彼得堡团队，名称取自圣彼得堡附近的一个小岛 ( Kotlin Island ) 。JetBrains 在 2010 年首次推出 Kotlin 编程语言，并在次年将之开源。</p>
<h2 id="Kotlin-的特点"><a href="#Kotlin-的特点" class="headerlink" title="Kotlin 的特点"></a>Kotlin 的特点</h2><p>Kotlin 是一个基于 JVM 的编程语言，与 Java 有很深的渊源。它能与 Java 100% 互通，具备诸多 Java 尚不支持的新特性。Kotlin 可以编译成 Java 字节码，也可以编译成 JavaScript ，方便在没有 JVM 的设备上运行，可用于移动端以及 Web 开发，是一种全栈式开发语言。</p>
<h2 id="Java-to-Kotlin"><a href="#Java-to-Kotlin" class="headerlink" title="Java to Kotlin"></a>Java to Kotlin</h2><p>下面是这几天整理出来的 Java to Kotlin 主要语法，以便于你快速认识 Kotlin 这门语言。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>Java</strong></p>
<pre><code class="java">String lan = &quot;Hello Kotlin&quot;;

final String lan = &quot;Hello Kotlin&quot;;
</code></pre>
<p><strong>Kotlin</strong></p>
<pre><code class="kotlin">var lan = &quot;Hello Kotlin&quot;

val lan = &quot;Hello Kotlin&quot;
</code></pre>
<h3 id="打印字符串"><a href="#打印字符串" class="headerlink" title="打印字符串"></a>打印字符串</h3><p><strong>Java</strong></p>
<pre><code class="java">System.out.print(&quot;Hello Kotlin&quot;);

System.out.println(&quot;Hello Kotlin&quot;);
</code></pre>
<p><strong>Kotlin</strong></p>
<pre><code class="kotlin">print(&quot;Hello Kotlin&quot;);

println(&quot;Hello Kotlin&quot;);
</code></pre>
<h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p><strong>Java</strong></p>
<pre><code class="java">String name = &quot;haohao&quot;;

int age = 25;

String msg = &quot;I am &quot; + name + &quot;, &quot; + age + &quot; years old.&quot;;

String text = &quot;Hello Kotlin\n&quot; +
              &quot;Hello Android\n&quot; +
              &quot;Hello TensorFlow&quot;;
</code></pre>
<p><strong>Kotlin</strong></p>
<pre><code class="kotlin">var name = &quot;haohao&quot;;

var age = 25;

var msg = &quot;I am $name , $age years old.&quot;;

var text = &quot;&quot;&quot;
    |Hello Kotlin    
    |Hello Android
    |Hello TensorFlow
    &quot;&quot;&quot;.trimMargin()
// trimMargin() 去除连接符 `|`
</code></pre>
<h3 id="空声明"><a href="#空声明" class="headerlink" title="空声明"></a>空声明</h3><p><strong>Java</strong></p>
<pre><code class="java">String name = null;
</code></pre>
<p><strong>Kotlin</strong></p>
<pre><code class="kotlin">var name: String? = null // `?` 声明变量可为 null
</code></pre>
<h3 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h3><p><strong>Java</strong></p>
<pre><code class="java">if (name != null) {

    int len = name.length;
}
</code></pre>
<p><strong>Kotlin</strong></p>
<pre><code class="kotlin">name?.let{

    val len = name.length
}
</code></pre>
<h3 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h3><p><strong>Java</strong></p>
<pre><code class="java">String y = x &gt; 6 ? &quot;x &gt; 6&quot; : &quot;x &lt;= 6&quot;;
</code></pre>
<p><strong>Kotlin</strong></p>
<pre><code class="kotlin">var y = if (x &gt; 6)
            &quot;x &gt; 6&quot;
        else &quot;x &lt;= 6&quot;
</code></pre>
<h3 id="类型判断及转换"><a href="#类型判断及转换" class="headerlink" title="类型判断及转换"></a>类型判断及转换</h3><p><strong>Java</strong></p>
<pre><code class="java">if (obj instanceof Person) {

    Person p = (Person) obj;
}
</code></pre>
<p><strong>Kotlin</strong></p>
<pre><code class="kotlin">if (obj is Person) {

    var p = obj //智能转换
}
</code></pre>
<h3 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h3><p><strong>Java</strong></p>
<pre><code class="java">if (value &gt;= 0 &amp;&amp; value &lt;= 100) {
}

for (int i = 1; i &lt;= 100 ; i++) {}

for (int i = 1; i &lt; 100 ; i++) {}

for (int i = 100; i &gt;= 0 ; i--) {}

for (int i = 1; i &lt;= 100 ; i+=2) {}

for (int i = 100; i &gt;= 0 ; i-=2) {}
</code></pre>
<p><strong>Kotlin</strong></p>
<pre><code class="kotlin">if (value is 0..100) {
}

for (i in 1..100 ) {}

for (i in 1 until 100) {} // 半开区间：不包含 100

for (i in 100 downTo 0) {}

for (i in 1..100 step 2) {}

for (i in 100 donwTo 1 step 2) {}
</code></pre>
<h3 id="list-和-map-针对-Java-8-之前版本"><a href="#list-和-map-针对-Java-8-之前版本" class="headerlink" title="list 和 map ( 针对 Java 8 之前版本 )"></a>list 和 map ( 针对 Java 8 之前版本 )</h3><p><strong>Java</strong></p>
<pre><code class="java">List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4);

for(Integer value : list) {

   System.out.println(value);
}

Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();

map.put(1, &quot;Java&quot;);

map.put(2, &quot;Kotlin&quot;);

map.put(3, &quot;iOS&quot;);

map.put(4, &quot;React Native&quot;);


Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();

while (iterator.hasNext()) {

    Map.Entry&lt;Integer, String&gt; entry = iterator.next();

    System.out.println(entry.getKey() + &quot; , &quot; + entry.getValue());
}
</code></pre>
<p><strong>Kotlin</strong></p>
<pre><code class="kotlin">var list = listOf(1, 2, 3, 4);

list.forEach {

   println(it)
}

var map = mapOf(&quot;a&quot; to 1, &quot;b&quot; to 2, &quot;c&quot; to 3)

map.forEach { key, value -&gt;

    println(&quot;$t, $u&quot;)
}

// 或者

for ((key, value) in map) {

    println(&quot;$key, $value&quot;)
}
</code></pre>
<h3 id="开关语句"><a href="#开关语句" class="headerlink" title="开关语句"></a>开关语句</h3><p><strong>Java</strong></p>
<pre><code class="java">int score = // some score;
String result;
switch (score) {
    case 10:
    case 9:
        grade = &quot;Excellent&quot;;
        break;
    case 8:
    case 7:
    case 6:
        grade = &quot;Good&quot;;
        break;
    case 5:
    case 4:
        grade = &quot;Ok&quot;;
        break;
    case 3:
    case 2:
    case 1:
        grade = &quot;Fail&quot;;
        break;
    default:
        grade = &quot;Fail&quot;;                
}
</code></pre>
<p><strong>Kotlin</strong></p>
<pre><code class="kotlin">var score = // some score
var grade = when (score) {

    9, 10 -&gt; &quot;Excellent&quot; 

    in 6..8 -&gt; &quot;Good&quot;

    4, 5 -&gt; &quot;Ok&quot;

    in 1..3 -&gt; &quot;Fail&quot;

    else -&gt; &quot;Fail&quot;
}
</code></pre>
<h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><p><strong>Java</strong></p>
<pre><code class="java">List&lt;String&gt; list = Arrays.asList(&quot;java&quot;, &quot;c++&quot;, &quot;Android&quot;, &quot;Kotlin&quot;, &quot;iOS&quot;);

for(int i = 0; i &lt; list.size(); i++ ) {

    list.set(i, &quot;Hello &quot; + list.get(i));

    if (!list.get(i).contains(&quot;c&quot;)) {

        System.out.println(list.get(i));
    }
}
</code></pre>
<p><strong>Kotlin</strong></p>
<pre><code class="kotlin">var list = arrayOf(&quot;java&quot;, &quot;c++&quot;, &quot;Android&quot;, &quot;Kotlin&quot;, &quot;iOS&quot;)

list.map {

    &quot;Hello $it&quot;

}.filter {

    !it.contains(&quot;c&quot;)

}.forEach {

    println(it)

}
</code></pre>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><strong>Java</strong></p>
<pre><code class="java">public final void func() {}

public final int func(int value) {

    return 1 * value;
}
</code></pre>
<p><strong>Kotlin</strong></p>
<pre><code class="kotlin">fun func() {}

fun func(value: Int): Int {

    return 1 * value
}

// 或者

fun func(value: Int): Int = 1 * value
</code></pre>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p><strong>Java</strong></p>
<pre><code class="java">public final class Person {

    private String name = null;

    private int age = 25;

    private Person() {
    }

    public Person(String name, int age) {

        this.name = name;
        this.age = age;
    }
}
</code></pre>
<p><strong>Kotlin</strong></p>
<pre><code class="kotlin">class Person private constructor() {

    private var name: String? = null

    private var age: Int = 25

    constructor (name: String, age: Int): this() {

        this.name = name
        this.age = age
    }
}
</code></pre>
<h3 id="静态方法（-伴生对象-）"><a href="#静态方法（-伴生对象-）" class="headerlink" title="静态方法（ 伴生对象 ）"></a>静态方法（ 伴生对象 ）</h3><p><strong>Java</strong></p>
<pre><code class="java">public final class Manager {

    private Manager() {}

    public static Manager getInstance () {

        return new Manager();
    }
}
</code></pre>
<p><strong>Kotlin</strong></p>
<pre><code class="kotlin">class Manager private constructor() {

    companion object {

        fun getInstance(): Manager = Manager()
    }
}
</code></pre>
<h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><p><strong>Java</strong></p>
<pre><code class="java">public class Person {

    public String name;

    public age;

    public Person(String name, int age) {

        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Person person = (Person) o;

        if (age != person.age) return false;
        return name != null ? name.equals(person.name) : person.name == null;

    }

    @Override
    public int hashCode() {
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + age;
        return result;
    }

    @Override
    public String toString() {
        return &quot;Person{&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;}&#39;;
    }
}
</code></pre>
<p><strong>Kotlin</strong></p>
<pre><code class="kotlin">data class Person(var name: String, var age: Int)
</code></pre>
<h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><p><strong>Java</strong></p>
<pre><code class="java">Person p = new Person(&quot;haohao&quot;, 35);

String name = p.getName();

String age = p.getAge();
</code></pre>
<p><strong>Kotlin</strong></p>
<pre><code class="kotlin">var p = Person(&quot;name&quot;, 25)

var (name, age) = p
</code></pre>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><strong>Java</strong></p>
<pre><code class="java">interface Readable {

    String getContent();
}
</code></pre>
<pre><code class="java">public final class Book implements Readable {

    @override
    public String getContent() {

        return &quot;Hello&quot;;
    }
}
</code></pre>
<p><strong>Kotlin</strong></p>
<pre><code class="kotlin">
// Kotlin 接口中可以设置抽象和非抽象方法,可以有属性但必须声明为抽象或提供访问器实现。
interface Readable {

   fun getContent(): String

   fun getVersion(): Int = 0 

}
</code></pre>
<pre><code class="kotlin">class Book(): Readable {

   override fun getContent(): String = &quot;Hello&quot;

   override fun getVersion(): Int {

       return super.getVersion()
   }
}
</code></pre>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>Java</strong></p>
<pre><code class="java">public class Person {

    private String name = null;

    public Person(String name) {
        this.name = name;

    }

    public void sayHello() {
        System.out.println(&quot;Hello&quot;);
    }

    public final void sayGood() {
        System.out.println(&quot;Good&quot;);
    }

}
</code></pre>
<pre><code class="java">public final class Student extends Person {

    private String school = null;

    public Student(String name, String school) {
        this.school = school;
        super(name);
    }

    @override
    public void sayHello() {
        super.sayHello();
        System.out.println(&quot;Hello Student&quot;);
    }


}
</code></pre>
<p><strong>Kotlin</strong></p>
<pre><code class="kotlin">open class Person(private var name: String? = null) {

    open fun sayHello() = println(&quot;Hello&quot;)

    fun sayGood() = println(&quot;Good&quot;)

}
</code></pre>
<pre><code class="kotlin">class Student(private var school: String? = null, name: String): Person(name) {

   override fun sayHello() {
       super.sayHello()
       println(&quot;Hello Student&quot;)
   }

}
</code></pre>
<h3 id="静态与非静态内部类"><a href="#静态与非静态内部类" class="headerlink" title="静态与非静态内部类"></a>静态与非静态内部类</h3><p><strong>Java</strong></p>
<pre><code class="java">public final class Outer {

    private int bar = 100;

    public static class Nester {

        public final String foo() {
            return &quot;Hello Kotlin!&quot;;
        }
    }

    public final class Inner {

        public final int foo() {
            return bar; // 可以访问外部类成员
        }

    }

}


System.out.println(new Outer.Nester().foo()); 

// System.out.println(new Outer().Inner().foo()); 不能在其他类中实例化非静态内部类
</code></pre>
<p><strong>Kotlin</strong></p>
<pre><code class="kotlin">class Outer {
    private var bar: Int = 100

    // 嵌套类
    class Nester {
        // 不能访问外部类成员
        fun foo() = &quot;Hello Kotlin!&quot;
    }

    // 内部类
    inner class Inner {
        // 可以访问外部类成员
        fun foo() = bar
    }
}



println(Outer.Nested().foo())

println(Outer().Inner().foo())
</code></pre>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p><strong>Java</strong></p>
<pre><code class="java">view.setOnClickListener(new OnClickListener() {

    @override
    onClick(View view){
        // to do something.
    }

});
</code></pre>
<p><strong>Kotlin</strong></p>
<pre><code class="kotlin">interface OnClickListener {
    fun onClick()
}

class View(){
    var listener: OnClickListener? = null

    fun setOnClickListener(listener: OnClickListener) {
        this.listener = listener
    }
}

view.setOnClickListener(object : OnClickListener{
    override fun onClick() {
        TODO(&quot;not implemented&quot;)
    }
})
</code></pre>
<h2 id="持续更新中。。。"><a href="#持续更新中。。。" class="headerlink" title="持续更新中。。。"></a>持续更新中。。。</h2>]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://i1.piimg.com/588795/9c8514f7c56bb889.jpg&quot; alt=&quot;Markdown&quot;&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;Today, at the Google I/O
    
    </summary>
    
      <category term="Kotlin" scheme="https://githubhaohao.github.io/categories/Kotlin/"/>
    
    
      <category term="Java to Kotlin" scheme="https://githubhaohao.github.io/tags/Java-to-Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android 设计模式之外观模式</title>
    <link href="https://githubhaohao.github.io/2017/05/15/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://githubhaohao.github.io/2017/05/15/Android-设计模式之外观模式/</id>
    <published>2017-05-15T02:05:07.000Z</published>
    <updated>2017-05-15T03:18:15.488Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><img src="http://i1.piimg.com/588795/f87081d597c610a1.jpg" alt="Markdown"></p>

<p align="center">打造个人品牌是现代职业规划的趋势</p>

<blockquote>
<p>在当下互联网革命的时代，有这样一种说法，如果一个人到三十岁以后还是只有工资收入，那么它的职业规划是失败的。<br>本文是 Android 设计模式的第三篇，接下来会陆续推出整个常用的设计模式系列。</p>
</blockquote>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式 (Facade Pattern) ，又名门面模式，归类为对象结构型模式，外部对象与一个子系统通信必须通过一个统一的外观对象进行。</p>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><ul>
<li>Client 外部对象</li>
<li>Facade 外观对象</li>
<li>SubSystem 子系统对象</li>
</ul>
<p align="center"><img src="https://github.com/simple-android-framework/android_design_patterns_analysis/raw/master/facade/elsdnwn/images/facade.png" alt="Markdown"></p><br><p align="center">盗图</p>

<h3 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h3><blockquote>
<p>电视遥控器是现实生活中一个比较好的外观模式的运用，遥控器可以控制电源 (Power) 的电源、声音 (Voice) 的调整、频道 (Channel) 的切换等。这个遥控器就是我们这里说的外观或者门面，而电源、声音、频道切换系统就是我们的子系统。</p>
</blockquote>
<h4 id="PowerSystem"><a href="#PowerSystem" class="headerlink" title="PowerSystem"></a>PowerSystem</h4><pre><code class="java">public class PowerSystem {
    public void powerOn() {
        System.out.println(&quot;power on&quot;);
    }

    public void powerOff() {
        System.out.println(&quot;power off&quot;);
    }
}
</code></pre>
<h4 id="VoiceSystem"><a href="#VoiceSystem" class="headerlink" title="VoiceSystem"></a>VoiceSystem</h4><pre><code class="java">public class VoiceSystem {
    public void turnUp() {
        System.out.println(&quot;voice increasing&quot;);
    }

    public void turnDown() {
        System.out.println(&quot;voice reducing&quot;);
    }
}
</code></pre>
<h4 id="ChannelSystem"><a href="#ChannelSystem" class="headerlink" title="ChannelSystem"></a>ChannelSystem</h4><pre><code class="java">public class ChannelSystem {
    public void next() {
        System.out.println(&quot;next channel&quot;);
    }

    public void prev() {
        System.out.println(&quot;prev channel&quot;);
    }
}
</code></pre>
<h4 id="Facade"><a href="#Facade" class="headerlink" title="Facade"></a>Facade</h4><pre><code class="java">public class Facade {
    private PowerSystem mPowerSystem = new PowerSystem();
    private VoiceSystem mVoiceSystem = new VoiceSystem();
    private ChannelSystem mChannelSystem = new ChannelSystem();

    public void powerOn() {
        mPowerSystem.powerOn();
    }

    public void powerOff() {
        mPowerSystem.powerOff();
    }

    public void turnUp() {
        mVoiceSystem.turnUp();
    }

    public void turnDown() {
        mVoiceSystem.turnDown();
    }

    public void nextChannel() {
        mChannelSystem.next();
    }

    public void prevChannel() {
        mChannelSystem.prev();
    }
}
</code></pre>
<h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><pre><code class="java">public static void main (String[] args) {
    Facade facade = new Facade();
    facade.powerOn();
    facade.turnUp();
    facade.nextChannel();
}
</code></pre>
<h4 id="Running"><a href="#Running" class="headerlink" title="Running"></a>Running</h4><blockquote>
<p>power on</p>
<p>voice increasing</p>
<p>next channel</p>
</blockquote>
<h3 id="Android-中的实现"><a href="#Android-中的实现" class="headerlink" title="Android 中的实现"></a>Android 中的实现</h3><p>在 Activity 中可以进行很多重要的操作，如 startService() ，startActivity() ，sendBroadcast() ，bindService() 以及获取 System Service 。Activity 就可以简单地看作一个门面，但是这些工作实际上并不是 Activity 来实现的，而是委托 Activity 父类 ContextThemeWrapper 中的 mBase 对象，mBase 对象的实现类是 ContextImpl 。</p>
<p>看一下源码：</p>
<pre><code class="java">class ContextImpl extends Context {
    private final static String TAG = &quot;ApplicationContext&quot;;
    private final static boolean DEBUG = false;
    private final static boolean DEBUG_ICONS = false;

    private static final Object sSync = new Object();
    private static AlarmManager sAlarmManager;
    private static PowerManager sPowerManager;
    private static ConnectivityManager sConnectivityManager;
    private AudioManager mAudioManager;
    LoadedApk mPackageInfo;
    private Resources mResources;
    private PackageManager mPackageManager;
    private NotificationManager mNotificationManager = null;
    private ActivityManager mActivityManager = null;

    ...

    @Override
    public boolean bindService(Intent service, ServiceConnection conn,
            int flags) {
        warnIfCallingFromSystemProcess();
        return bindServiceCommon(service, conn, flags, mMainThread.getHandler(),
                Process.myUserHandle());
    }

    @Override
    public Object getSystemService(String name) {
        return SystemServiceRegistry.getSystemService(this, name);
    }

    @Override
    public String getSystemServiceName(Class&lt;?&gt; serviceClass) {
        return SystemServiceRegistry.getSystemServiceName(serviceClass);
    }

    @Override
    public void sendBroadcast(Intent intent) {
        String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
        try {
            ActivityManagerNative.getDefault().broadcastIntent(
                mMainThread.getApplicationThread(), intent, resolvedType, null,
                Activity.RESULT_OK, null, null, null, false, false);
        } catch (RemoteException e) {
        }
    }


    @Override
    public void startActivity(Intent intent) {
        if ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == 0) {
            throw new AndroidRuntimeException(
                    &quot;Calling startActivity() from outside of an Activity &quot;
                    + &quot; context requires the FLAG_ACTIVITY_NEW_TASK flag.&quot;
                    + &quot; Is this really what you want?&quot;);
        }
        mMainThread.getInstrumentation().execStartActivity(
            getOuterContext(), mMainThread.getApplicationThread(), null, null, intent, -1);
    }


    @Override
    public ComponentName startService(Intent service) {
        try {
            ComponentName cn = ActivityManagerNative.getDefault().startService(
                mMainThread.getApplicationThread(), service,
                service.resolveTypeIfNeeded(getContentResolver()));
            if (cn != null &amp;&amp; cn.getPackageName().equals(&quot;!&quot;)) {
                throw new SecurityException(
                        &quot;Not allowed to start service &quot; + service
                        + &quot; without permission &quot; + cn.getClassName());
            }
            return cn;
        } catch (RemoteException e) {
            return null;
        }
    }

    @Override
    public String getPackageName() {
        if (mPackageInfo != null) {
            return mPackageInfo.getPackageName();
        }
        throw new RuntimeException(&quot;Not supported in system context&quot;);
    }

    ...
}
</code></pre>
<p>ContextImpl 内部有很多 Manager 类的对象，也就是也就是子系统对象。 ContextImpl 内部封装了一些系统级别的操作以及提供了一些访问系统的接口，我们在开发过程中可以很方便地利用其访问子系统。</p>
<h3 id="外观模式的优点与缺点"><a href="#外观模式的优点与缺点" class="headerlink" title="外观模式的优点与缺点"></a>外观模式的优点与缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>屏蔽了子系统内部细节，使子系统的使用更见便利</li>
<li>减少客户端所持对象的数目，降低了客户端与子系统的耦合度<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li>
<li>增加新的子系统可能需要修改外观类，违背了“开闭原则”</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://github.com/simple-android-framework/android_design_patterns_analysis/tree/master/facade/elsdnwn" target="_blank" rel="external">https://github.com/simple-android-framework/android_design_patterns_analysis/tree/master/facade/elsdnwn</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://i1.piimg.com/588795/f87081d597c610a1.jpg&quot; alt=&quot;Markdown&quot;&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;打造个人品牌是现代职业规划的趋势&lt;/p&gt;

&lt;b
    
    </summary>
    
      <category term="Android" scheme="https://githubhaohao.github.io/categories/Android/"/>
    
      <category term="设计模式" scheme="https://githubhaohao.github.io/categories/Android/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="外观模式" scheme="https://githubhaohao.github.io/tags/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android 设计模式之 Builder 模式</title>
    <link href="https://githubhaohao.github.io/2017/05/13/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B-Builder-%E6%A8%A1%E5%BC%8F/"/>
    <id>https://githubhaohao.github.io/2017/05/13/Android-设计模式之-Builder-模式/</id>
    <published>2017-05-13T05:28:00.000Z</published>
    <updated>2017-05-13T08:56:06.815Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><img src="http://i1.piimg.com/588795/85663beb3ea340b0.jpg" alt="Markdown"></p>

<p align="center">平坦的路往往只能带你到平凡的地方</p>

<blockquote>
<p>最近在研究 Clean 和 Unidirectional （ Android Flux ）架构，回头放一个大招。<br>本文是 Android 设计模式的第二篇，接下来会陆续推出整个常用的设计模式系列。</p>
</blockquote>
<h2 id="Builder-模式"><a href="#Builder-模式" class="headerlink" title="Builder 模式"></a>Builder 模式</h2><p>Builder 又名生成器模式，或建造（者）模式。它是一种对象构建模式，用于抽象复杂对象的构建过程，构造过程的不同实现方法可以构建出具有不同表示的对象。</p>
<blockquote>
<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
</blockquote>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><ul>
<li>Product 产品，表示被构造的复杂对象。</li>
<li>Builder 抽象构建者，为创建一个 Product 对象的各个部件指定抽象方法（接口方法）。</li>
<li>ConcreteBuilder 具体构建者，实现 Builder 接口（抽象类）以及各个抽象方法。</li>
<li>Director 指挥者，构建实现（继承） Builder 接口（抽象类）的对象。</li>
</ul>
<p align="center"><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/Builder.jpg" alt=""><br></p><br><p align="center">盗图</p>

<h3 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h3><p>我们以生产手机为例，当我们拿到一个手机产品通常比较关注它的品牌 (Brand) ，CPU 核心数目 (CPU Core)，运行内存 (RAM) 以及操作系统 (OS)。</p>
<h4 id="Product"><a href="#Product" class="headerlink" title="Product"></a>Product</h4><pre><code class="java">public class Phone {
    private int mCPUCore = 1;
    private int mRam = 1;
    private String mOS = &quot;Android&quot;;
    private String mBrand = &quot;Google&quot;;

    public int getCPUCore() {
        return mCPUCore;
    }

    public int getRAM() {
        return mRam;
    }

    public String getOS() {
        return mOS;
    }

    public String getBrand() {
        return mBrand;
    }

    public void setCPUCore(int mCPUCore) {
        this.mCPUCore = mCPUCore;
    }

    public void setRAM(int mRam) {
        this.mRam = mRam;
    }

    public void setOS(String mOS) {
        this.mOS = mOS;
    }

    public void setBrand(String mBrand) {
        this.mBrand = mBrand;
    }

    @Override
    public String toString() {
        return &quot;Brand : &quot; + getBrand() +&quot;, CPUCore : &quot; + getCPUCore() +
                &quot;, RAM : &quot; + getRAM() + &quot;, OS : &quot; + getOS();
    }
}
</code></pre>
<h4 id="Builder-抽象类"><a href="#Builder-抽象类" class="headerlink" title="Builder 抽象类"></a>Builder 抽象类</h4><pre><code class="java">
public abstract class PhoneBuilder {
    protected Phone mPhone;
    public void createPhone() {
        mPhone = new Phone();
    }

    public Phone getPhone() {
        return mPhone;
    }

    public abstract void buildPhoneCpu();

    public abstract void buildPhoneRam();

    public abstract void buildPhoneOS();

}
</code></pre>
<h4 id="ConcreteBuilder"><a href="#ConcreteBuilder" class="headerlink" title="ConcreteBuilder"></a>ConcreteBuilder</h4><p>XiaoMiPhoneBuilder</p>
<pre><code class="java">public class XiaoMiPhoneBuilder extends PhoneBuilder {

    public XiaoMiPhoneBuilder() {
        createPhone();
        mPhone.setBrand(&quot;XiaoMi&quot;);
    }


    @Override
    public void buildPhoneCpu() {
        mPhone.setCPUCore(4);

    }

    @Override
    public void buildPhoneRam() {
        mPhone.setRAM(4);
    }

    @Override
    public void buildPhoneOS() {
        mPhone.setOS(&quot;MIUI Android&quot;);
    }
}
</code></pre>
<p>GooglePhoneBuilder</p>
<pre><code class="java">public class GooglePhoneBuilder extends PhoneBuilder {

    public GooglePhoneBuilder() {
        createPhone();
        mPhone.setBrand(&quot;Google&quot;);
    }

    @Override
    public void buildPhoneCpu() {
        mPhone.setCPUCore(8);

    }

    @Override
    public void buildPhoneRam() {
        mPhone.setRAM(6);

    }

    @Override
    public void buildPhoneOS() {
        mPhone.setOS(&quot;Android&quot;);
    }
}
</code></pre>
<h4 id="Director"><a href="#Director" class="headerlink" title="Director"></a>Director</h4><pre><code class="java">public class PhoneDirector {
    private PhoneBuilder mPhoneBuilder;

    public PhoneDirector setPhoneBuilder(PhoneBuilder phoneBuilder) {
        this.mPhoneBuilder = phoneBuilder;
        return this;
    }

    public Phone getPhone() {
        return mPhoneBuilder.getPhone();
    }

    public PhoneDirector constructPhone() {
        mPhoneBuilder.buildPhoneCpu();
        mPhoneBuilder.buildPhoneOS();
        mPhoneBuilder.buildPhoneRam();
        return this;
    }
}
</code></pre>
<h4 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h4><pre><code class="java">public class BuilderSample {
    public static void main(String[] args) {
        PhoneDirector phoneDirector = new PhoneDirector();

        PhoneBuilder xiaomiphoneBuilder = new XiaoMiPhoneBuilder();
        PhoneBuilder googlePhoneBuilder = new GooglePhoneBuilder();


        Phone xiaoMiPhone = phoneDirector.setPhoneBuilder(xiaomiphoneBuilder)
                .constructPhone()
                .getPhone();

        Phone googlePhone = phoneDirector.setPhoneBuilder(googlePhoneBuilder)
                .constructPhone()
                .getPhone();
        System.out.println(xiaoMiPhone + &quot;\n&quot; + googlePhone);

    }
}
</code></pre>
<p>Running</p>
<blockquote>
<p>Brand : XiaoMi, CPUCore : 4, RAM : 4, OS : MIUI Android</p>
<p>Brand : Google, CPUCore : 8, RAM : 6, OS : Android</p>
</blockquote>
<h3 id="Android-中的实现"><a href="#Android-中的实现" class="headerlink" title="Android 中的实现"></a>Android 中的实现</h3><p>在 Android 开发中我们最常用到的实现 Builder 的类是 AlertDialog.Builder ，Builder 是AlertDialog 的静态内部类。基本用法如下：</p>
<pre><code class="java">AlertDialog.Builder builder = new AlertDialog.Builder(context);
builder.setIcon(R.drawable.icon);
builder.setTitle(&quot;Title&quot;);
builder.setMessage(&quot;Message&quot;);
builder.setPositiveButton(&quot;OK&quot;,
        new DialogInterface.OnClickListener() {
            public void onClick(DialogInterface dialog, int whichButton) {
                setTitle(&quot;点击了对话框上的 OK 按钮&quot;);
            }
        });
builder.setNeutralButton(&quot;Nothing&quot;,
        new DialogInterface.OnClickListener() {
            public void onClick(DialogInterface dialog, int whichButton) {
                setTitle(&quot;点击了对话框上的 Nothing 按钮&quot;);
            }
        });
builder.setNegativeButton(&quot;Cancel&quot;,
        new DialogInterface.OnClickListener() {
            public void onClick(DialogInterface dialog, int whichButton) {
                setTitle(&quot;点击了对话框上的 Cancel 按钮&quot;);
            }
        });
builder.create().show();
</code></pre>
<p>我们看一下简化后的 AlertDialog 源码：</p>
<pre><code class="java">public class AlertDialog extends Dialog implements DialogInterface {
    // Controller, 接受 Builder 成员变量P中的各个参数
    private AlertController mAlert;

    // 构造函数
    protected AlertDialog(Context context, int theme) {
        this(context, theme, true);
    }

    // 构造 AlertDialog
    AlertDialog(Context context, int theme, boolean createContextWrapper) {
        super(context, resolveDialogTheme(context, theme), createContextWrapper);
        mWindow.alwaysReadCloseOnTouchAttr();
        mAlert = new AlertController(getContext(), this, getWindow());
    }

    @Override
    public void setTitle(CharSequence title) {
        super.setTitle(title);
        mAlert.setTitle(title);
    }

    public void setCustomTitle(View customTitleView) {
        mAlert.setCustomTitle(customTitleView);
    }

    public void setMessage(CharSequence message) {
        mAlert.setMessage(message);
    }



   // Builder内部类
    public static class Builder {
        // 存储 AlertDialog 的各个参数, 例如 title ， message ， icon 等.
        private final AlertController.AlertParams P;

        public Builder(Context context) {
            this(context, resolveDialogTheme(context, 0));
        }


        public Builder(Context context, int theme) {
            P = new AlertController.AlertParams(new ContextThemeWrapper(
                    context, resolveDialogTheme(context, theme)));
            mTheme = theme;
        }

        ......

        public Builder setTitle(CharSequence title) {
            P.mTitle = title;
            return this;
        }


        public Builder setMessage(CharSequence message) {
            P.mMessage = message;
            return this;
        }

        public Builder setIcon(int iconId) {
            P.mIconId = iconId;
            return this;
        }

        public Builder setPositiveButton(CharSequence text, final OnClickListener listener) {
            P.mPositiveButtonText = text;
            P.mPositiveButtonListener = listener;
            return this;
        }


        public Builder setView(View view) {
            P.mView = view;
            P.mViewSpacingSpecified = false;
            return this;
        }

        // 构建 AlertDialog, 传递参数
        public AlertDialog create() {

            final AlertDialog dialog = new AlertDialog(P.mContext, mTheme, false);

            将P中的参数应用的dialog中的mAlert对象中
            P.apply(dialog.mAlert);
            dialog.setCancelable(P.mCancelable);
            if (P.mCancelable) {
                dialog.setCanceledOnTouchOutside(true);
            }
            dialog.setOnCancelListener(P.mOnCancelListener);
            if (P.mOnKeyListener != null) {
                dialog.setOnKeyListener(P.mOnKeyListener);
            }
            return dialog;
        }
    }

}
</code></pre>
<p>从源码中可以看到 AlertDialog.Builder 同时扮演了 Builder ， ConcreteBuilder 以及 Director 三个角色，是 Builder 模式的简化版。</p>
<p>我们从 AlertDialog 的构建和使用中，可以体会到运用 Builder 模式带来的简介性和高度的可定制性。</p>
<h3 id="Builder-模式的优点和缺点"><a href="#Builder-模式的优点和缺点" class="headerlink" title="Builder 模式的优点和缺点"></a>Builder 模式的优点和缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>使用简单，可扩展性强，封装良好；</li>
<li>高度的可定制性，构造过程可精细化控制。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>Builder 模式只适用于构建过程复杂的同一类 Product ，此外要考虑多余 Builder 和 Director 对象对内存的占用。 </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://i1.piimg.com/588795/85663beb3ea340b0.jpg&quot; alt=&quot;Markdown&quot;&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;平坦的路往往只能带你到平凡的地方&lt;/p&gt;

&lt;b
    
    </summary>
    
      <category term="Android" scheme="https://githubhaohao.github.io/categories/Android/"/>
    
      <category term="设计模式" scheme="https://githubhaohao.github.io/categories/Android/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Builder 模式" scheme="https://githubhaohao.github.io/tags/Builder-%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android 设计模式之单例模式</title>
    <link href="https://githubhaohao.github.io/2017/05/06/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://githubhaohao.github.io/2017/05/06/Android-设计模式之单例模式/</id>
    <published>2017-05-06T05:53:52.000Z</published>
    <updated>2017-05-13T08:09:15.382Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><img src="http://i4.buimg.com/588795/9d67959bff9222b9.jpg" alt="Markdown"></p>

<p align="center">时刻尝试走出舒适区</p>


<blockquote>
<p>最近在培养自己的广泛阅读习惯，感觉阅读中最重要的是动脑思考，阅读是接受讯息，思考是消化讯息。<br>本文是 Android 设计模式的开篇，接下来会陆续推出整个常用的设计模式系列。</p>
</blockquote>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式简而言之就是优秀的代码设计经验的总结。设计模式的产生是为了提高代码的可复用性，可扩展性，可靠性以及可读性。</p>
<h2 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h2><ul>
<li>单一职责原则: 一个类只负责一项职责;</li>
<li>里氏替换原则: 子类可以扩展父类的功能，但不能改变父类原有的功能;</li>
<li>依赖倒置原则: 面向接口编程，将依赖对象的共同特征抽象成接口；</li>
<li>接口隔离原则: 一个类不应该实现它不需要的接口方法，即建立单一接口，细化接口，尽量减少接口中的方法;</li>
<li>迪米特法则: 一个对象应该对其他对象保持最少的了解，即降低类与类之间的耦合；</li>
<li>开闭原则: 一个类对扩展开放，对修改关闭。</li>
</ul>
<h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><h3 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h3><p>设计对象的实例化，避免用户用 new 运算符创建对象。例如单例模式，Builder 模式，原型模式等。</p>
<h3 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h3><p>设计对象之间的通信交互。如观察者模式，迭代器模式，责任链模式等。</p>
<h3 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h3><p>设计如何组合类和对象以形成更大的结构。如适配器模式，代理模式，桥接模式等。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>简单介绍常用的五种单例模式的写法。</p>
<h3 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h3><pre><code class="java">public class Person {

    private static final INSTANCE = new Person();

    private Person(){

    }

    public static Person getInstance() {
      return INSTANCE;
    }
}
</code></pre>
<p>优点：线程安全。<br>缺点：类加载的时候就进行初始化，对于初始化逻辑复杂的类，会导致类加载变慢。</p>
<h3 id="DCL-懒汉式单例"><a href="#DCL-懒汉式单例" class="headerlink" title="(DCL) 懒汉式单例"></a>(DCL) 懒汉式单例</h3><pre><code class="java">public class Person {
    private static volatile sInstance = new Person();

    private Person(){

    }

    public static Person getInstance() {
        if (sInstance == null){
            synchronized (Person.class) {
                if (sInstance == null) {
                    sInstance = new Person();

                }
            }
        }

        return sInstance;
    }
}
</code></pre>
<p>优点：volatile 声明单例引用，可以防止并发时初始化成员变量和对象实例化顺序可能会被打乱，双重校验锁定解决了多余的同步问题。<br>缺点：并发时存在极小的概率导致 DCL 失效，据说是百万分之一。</p>
<h3 id="静态内部类单例"><a href="#静态内部类单例" class="headerlink" title="静态内部类单例"></a>静态内部类单例</h3><pre><code class="java">public class Person {

    private Person(){

    }

    private static class Singleton {
        private static final Person INSTANCE = new Person();
    }

    public static Person getInstance() {
        return Singleton.INSTANCE;
    }
}
</code></pre>
<p>优点：充分结合了懒汉式单例与饿汉式的优点，同时有效避开了它们的缺点，充分保证线程安全。<strong><em>推荐</em></strong><br>缺点：会有的！</p>
<h3 id="枚举型单例"><a href="#枚举型单例" class="headerlink" title="枚举型单例"></a>枚举型单例</h3><pre><code class="java">public enum PersonEnum {
    INSTANCE;

    private PersonEnum() {

    }

    public void fun() {
         // do something
    }
}
</code></pre>
<p>使用方法：</p>
<pre><code class="java">PersonEnum.INSTANCE.fun();
</code></pre>
<p>优点：简洁，线程安全。<br>《Effective Java》的作者在书中是这样夸枚举型单例：</p>
<blockquote>
<p>这种写法在功能上与共有域方法相近，但是它更简洁，无偿地提供了序列化机制，绝对防止对此实例化，即使是在面对复杂的序列化或者反射攻击的时候。<br>虽然这中方法还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。</p>
</blockquote>
<p>缺点：Google 官方强烈建议尽量不要使用 enum ，它会增加额外的内存占用，同时增加可执行文件 .dex 的大小，也不适用继承场景。</p>
<h3 id="容器型单例"><a href="#容器型单例" class="headerlink" title="容器型单例"></a>容器型单例</h3><pre><code class="java">public class Person {

    public Person () {

    }
}

public class SingletonManager {

    public static final KEY_SINGLETON = &quot;singleton&quot;;

    private static Map&lt;String, Object&gt; sInstanceMap = new HashMap&lt;&gt;();

    public static void registerSingleton(String key, Object obj) { 
        if (!sInstanceMap.containsKey(key)) {
            sInstanceMap.put(key, obj);     
        }
    }

    public static Person getSingleton(String key) {
        return (Person) sInstanceMap.get(key);   
    }
}
</code></pre>
<p>使用：</p>
<pre><code class="java">SingletonManager.registerSingleton(KEY_SINGLETON, new Person);
Person person = SingletonManager.getSingleton();
</code></pre>
<p>优点：可以将不同单例注册到一个容器中统一管理，隐藏了类的具体实现，降低了耦合度。<strong><em>推荐</em></strong><br>缺点：会有的！</p>
<h2 id="单例模式的优点与缺点"><a href="#单例模式的优点与缺点" class="headerlink" title="单例模式的优点与缺点"></a>单例模式的优点与缺点</h2><p>优点：减少内存开销，避免资源重用。<br>缺点：单例类的扩展性很差，持有外部引用时，非常容易造成内存泄漏。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://i4.buimg.com/588795/9d67959bff9222b9.jpg&quot; alt=&quot;Markdown&quot;&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;时刻尝试走出舒适区&lt;/p&gt;


&lt;blockqu
    
    </summary>
    
      <category term="Android" scheme="https://githubhaohao.github.io/categories/Android/"/>
    
      <category term="设计模式" scheme="https://githubhaohao.github.io/categories/Android/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="单例模式" scheme="https://githubhaohao.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android 进程间通信方式</title>
    <link href="https://githubhaohao.github.io/2017/04/27/Android-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <id>https://githubhaohao.github.io/2017/04/27/Android-进程间通信方式/</id>
    <published>2017-04-27T11:05:29.000Z</published>
    <updated>2017-05-06T09:13:23.781Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><img src="http://i4.buimg.com/588795/ecd70e1824f1dc35.jpg" alt="Markdown"></p>

<p align="center">做好眼前的事，保持专注</p>

<blockquote>
<p>我们的大脑是串行结构，而非并行结构，你永远无法真正将自己的注意力<br>同时放在两个任务之中。</p>
</blockquote>
<h2 id="Android-中的-IPC-方式"><a href="#Android-中的-IPC-方式" class="headerlink" title="Android 中的 IPC 方式"></a>Android 中的 IPC 方式</h2><h3 id="使用-Intent"><a href="#使用-Intent" class="headerlink" title="使用 Intent"></a>使用 Intent</h3><ol>
<li>Activity，Service，Receiver 都支持在 Intent 中传递 Bundle 数据，而 Bundle 实现了 Parcelable 接口，可以在不同的进程间进行传输。</li>
<li>在一个进程中启动了另一个进程的 Acyivity，Service 和 Receiver ，可以在 Bundle 中附加要传递的数据通过 Intent 发送出去。</li>
</ol>
<h3 id="使用文件共享"><a href="#使用文件共享" class="headerlink" title="使用文件共享"></a>使用文件共享</h3><ol>
<li>Windows 上，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读和写；而 Android 系统基于 Linux ，使得其并发读取文件没有限制地进行，甚至允许两个线程同时对一个文件进行读写操作，尽管这样可能会出问题。</li>
<li>可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（<strong>注意</strong>：并不是同一个对象，只是内容相同。）。</li>
<li>SharedPreferences 是个特例，系统对它的读 / 写有一定的缓存策略，即内存中会有一份 ShardPreferences 文件的缓存，系统对他的读 / 写就变得不可靠，当面对高并发的读写访问，SharedPreferences 有很多大的几率丢失数据。因此，IPC 不建议采用 SharedPreferences。</li>
</ol>
<h3 id="使用-Messenger"><a href="#使用-Messenger" class="headerlink" title="使用 Messenger"></a>使用 Messenger</h3><p>Messenger 是一种轻量级的 IPC 方案，它的底层实现是 AIDL ，可以在不同进程中传递 Message 对象，它一次只处理一个请求，在服务端不需要考虑线程同步的问题，服务端不存在并发执行的情形。</p>
<ul>
<li>服务端进程：服务端创建一个 Service 来处理客户端请求，同时通过一个 Handler 对象来实例化一个 Messenger 对象，然后在 Service 的 onBind 中返回这个 Messenger 对象底层的 Binder 即可。</li>
</ul>
<pre><code class="java">public class MessengerService extends Service {

    private static final String TAG = MessengerService.class.getSimpleName();

    private class MessengerHandler extends Handler {

        /**
         * @param msg
         */
        @Override
        public void handleMessage(Message msg) {

            switch (msg.what) {
                case Constants.MSG_FROM_CLIENT:
                    Log.d(TAG, &quot;receive msg from client: msg = [&quot; + msg.getData().getString(Constants.MSG_KEY) + &quot;]&quot;);
                    Toast.makeText(MessengerService.this, &quot;receive msg from client: msg = [&quot; + msg.getData().getString(Constants.MSG_KEY) + &quot;]&quot;, Toast.LENGTH_SHORT).show();
                    Messenger client = msg.replyTo;
                    Message replyMsg = Message.obtain(null, Constants.MSG_FROM_SERVICE);
                    Bundle bundle = new Bundle();
                    bundle.putString(Constants.MSG_KEY, &quot;我已经收到你的消息，稍后回复你！&quot;);
                    replyMsg.setData(bundle);
                    try {
                        client.send(replyMsg);
                    } catch (RemoteException e) {
                        e.printStackTrace();
                    }
                    break;
                default:
                    super.handleMessage(msg);
            }
        }
    }

    private Messenger mMessenger = new Messenger(new MessengerHandler());


    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return mMessenger.getBinder();
    }
}
</code></pre>
<ul>
<li>客户端进程：首先绑定服务端 Service ，绑定成功之后用服务端的 IBinder 对象创建一个 Messenger ，通过这个 Messenger 就可以向服务端发送消息了，消息类型是 Message 。如果需要服务端响应，则需要创建一个 Handler 并通过它来创建一个 Messenger（和服务端一样），并通过 Message 的 replyTo 参数传递给服务端。服务端通过 Message 的 replyTo 参数就可以回应客户端了。</li>
</ul>
<pre><code class="java">public class MainActivity extends AppCompatActivity {
    private static final String TAG = MainActivity.class.getSimpleName();
    private Messenger mGetReplyMessenger = new Messenger(new MessageHandler());
    private Messenger mService;

    private class MessageHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case Constants.MSG_FROM_SERVICE:
                    Log.d(TAG, &quot;received msg form service: msg = [&quot; + msg.getData().getString(Constants.MSG_KEY) + &quot;]&quot;);
                    Toast.makeText(MainActivity.this, &quot;received msg form service: msg = [&quot; + msg.getData().getString(Constants.MSG_KEY) + &quot;]&quot;, Toast.LENGTH_SHORT).show();
                    break;
                default:
                    super.handleMessage(msg);
            }
        }
    }



    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

    }

    public void bindService(View v) {
        Intent mIntent = new Intent(this, MessengerService.class);
        bindService(mIntent, mServiceConnection, Context.BIND_AUTO_CREATE);
    }

    public void sendMessage(View v) {
        Message msg = Message.obtain(null,Constants.MSG_FROM_CLIENT);
        Bundle data = new Bundle();
        data.putString(Constants.MSG_KEY, &quot;Hello! This is client.&quot;);
        msg.setData(data);
        msg.replyTo = mGetReplyMessenger;
        try {
            mService.send(msg);
        } catch (RemoteException e) {
            e.printStackTrace();
        }

    }

    @Override
    protected void onDestroy() {
        unbindService(mServiceConnection);
        super.onDestroy();
    }

    private ServiceConnection mServiceConnection = new ServiceConnection() {
        /**
         * @param name
         * @param service
         */
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            mService = new Messenger(service);
            Message msg = Message.obtain(null,Constants.MSG_FROM_CLIENT);
            Bundle data = new Bundle();
            data.putString(Constants.MSG_KEY, &quot;Hello! This is client.&quot;);
            msg.setData(data);
            //
            msg.replyTo = mGetReplyMessenger;
            try {
                mService.send(msg);
            } catch (RemoteException e) {
                e.printStackTrace();
            }

        }

        /**
         * @param name
         */
        @Override
        public void onServiceDisconnected(ComponentName name) {


        }
    };
}
</code></pre>
<p><strong>注意：</strong>客户端和服务端是通过拿到对方的 Messenger 来发送 Message 的。只不过客户端通过   bindService onServiceConnected 而服务端通过 message.replyTo 来获得对方的 Messenger 。Messenger 中有一个 Hanlder 以串行的方式处理队列中的消息。不存在并发执行，因此我们不用考虑线程同步的问题。</p>
<p align="center"><img src="http://i1.piimg.com/588795/e7bed224f80f5dad.png" alt="Markdown"></p><br><p align="center">图片来自《Android 开发艺术探索》</p>

<h3 id="使用-AIDL"><a href="#使用-AIDL" class="headerlink" title="使用 AIDL"></a>使用 AIDL</h3><p>Messenger 是以串行的方式处理客户端发来的消息，如果大量消息同时发送到服务端，服务端只能一个一个处理，所以大量并发请求就不适合用 Messenger ，而且 Messenger 只适合传递消息，不能跨进程调用服务端的方法。AIDL 可以解决并发和跨进程调用方法的问题，要知道 Messenger 本质上也是 AIDL ，只不过系统做了封装方便上层的调用而已。</p>
<h4 id="AIDL-文件支持的数据类型"><a href="#AIDL-文件支持的数据类型" class="headerlink" title="AIDL 文件支持的数据类型"></a>AIDL 文件支持的数据类型</h4><ul>
<li><em>基本数据类型</em>；</li>
<li><p><em>String</em> 和 <em>CharSequence</em><br><img src="http://images.cnitblog.com/blog/497634/201311/08083111-591e2833f8a34264b0dad417f4188e35.jpg" alt="String"></p>
</li>
<li><p><em>ArrayList</em> ，里面的元素必须能够被 AIDL 支持；</p>
</li>
<li><em>HashMap</em> ，里面的元素必须能够被 AIDL 支持；</li>
<li><em>Parcelable</em> ，实现 Parcelable 接口的对象；<br><strong>注意：如果 AIDL 文件中用到了自定义的 Parcelable 对象，必须新建一个和它同名的 AIDL 文件。</strong></li>
<li><em>AIDL</em> ，AIDL 接口本身也可以在 AIDL 文件中使用。</li>
</ul>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>服务端创建一个 Service 用来监听客户端的连接请求，然后创建一个 AIDL 文件，将暴露给客户端的接口在这个 AIDL 文件中声明，最后在 Service 中实现这个 AIDL 接口即可。</p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>绑定服务端的 Service ，绑定成功后，将服务端返回的 Binder 对象转成 AIDL 接口所属的类型，然后就可以调用 AIDL 中的方法了。客户端调用远程服务的方法，被调用的方法运行在服务端的 Binder 线程池中，同时客户端的线程会被挂起，如果服务端方法执行比较耗时，就会导致客户端线程长时间阻塞，导致 ANR 。客户端的 onServiceConnected 和 onServiceDisconnected 方法都在 UI 线程中。</p>
<h4 id="服务端访问权限管理"><a href="#服务端访问权限管理" class="headerlink" title="服务端访问权限管理"></a>服务端访问权限管理</h4><ul>
<li>使用 Permission 验证，在 manifest 中声明</li>
</ul>
<pre><code class="xml">    &lt;permission android:name=&quot;com.jc.ipc.ACCESS_BOOK_SERVICE&quot;
        android:protectionLevel=&quot;normal&quot;/&gt;
    &lt;uses-permission android:name=&quot;com.jc.ipc.ACCESS_BOOK_SERVICE&quot;/&gt;
</code></pre>
<p>服务端 onBinder 方法中</p>
<pre><code class="java">    public IBinder onBind(Intent intent) {
        //Permission 权限验证
        int check = checkCallingOrSelfPermission(&quot;com.jc.ipc.ACCESS_BOOK_SERVICE&quot;);
        if (check == PackageManager.PERMISSION_DENIED) {
            return null;
        }

        return mBinder;
    }
</code></pre>
<ul>
<li>Pid Uid 验证</li>
</ul>
<p>详细代码：</p>
<pre><code class="java">// Book.aidl
package com.jc.ipc.aidl;

parcelable Book;
</code></pre>
<pre><code class="java">// IBookManager.aidl
package com.jc.ipc.aidl;

import com.jc.ipc.aidl.Book;
import com.jc.ipc.aidl.INewBookArrivedListener;

// AIDL 接口中只支持方法，不支持静态常量，区别于传统的接口
interface IBookManager {
    List&lt;Book&gt; getBookList();

    // AIDL 中除了基本数据类型，其他数据类型必须标上方向,in,out 或者 inout
    // in 表示输入型参数
    // out 表示输出型参数
    // inout 表示输入输出型参数

    void addBook(in Book book);

    void registerListener(INewBookArrivedListener listener);
    void unregisterListener(INewBookArrivedListener listener);

}
</code></pre>
<pre><code class="java">// INewBookArrivedListener.aidl
package com.jc.ipc.aidl;
import com.jc.ipc.aidl.Book;

// 提醒客户端新书到来

interface INewBookArrivedListener {
    void onNewBookArrived(in Book newBook);
}
</code></pre>
<pre><code class="java">public class BookManagerActivity extends AppCompatActivity {
    private static final String TAG = BookManagerActivity.class.getSimpleName();
    private static final int MSG_NEW_BOOK_ARRIVED = 0x10;
    private Button getBookListBtn,addBookBtn;
    private TextView displayTextView;
    private IBookManager bookManager;
    private Handler mHandler = new Handler(){
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case MSG_NEW_BOOK_ARRIVED:
                    Log.d(TAG, &quot;handleMessage: new book arrived &quot; + msg.obj);
                    Toast.makeText(BookManagerActivity.this, &quot;new book arrived &quot; + msg.obj, Toast.LENGTH_SHORT).show();
                    break;
                default:
                    super.handleMessage(msg);
            }

        }
    };

    private ServiceConnection mServiceConn = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            bookManager = IBookManager.Stub.asInterface(service);
            try {
                bookManager.registerListener(listener);
            } catch (RemoteException e) {
                e.printStackTrace();
            }

        }

        @Override
        public void onServiceDisconnected(ComponentName name) {

        }
    };

    private INewBookArrivedListener listener = new INewBookArrivedListener.Stub() {
        @Override
        public void onNewBookArrived(Book newBook) throws RemoteException {
            mHandler.obtainMessage(MSG_NEW_BOOK_ARRIVED, newBook).sendToTarget();

        }
    };

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.book_manager);
        displayTextView = (TextView) findViewById(R.id.displayTextView);
        Intent intent = new Intent(this, BookManagerService.class);
        bindService(intent, mServiceConn, BIND_AUTO_CREATE);

    }


    public void getBookList(View view) {
        try {
            List&lt;Book&gt; list = bookManager.getBookList();
            Log.d(TAG, &quot;getBookList: &quot; + list.toString());
            displayTextView.setText(list.toString());
        } catch (RemoteException e) {
            e.printStackTrace();
        }

    }

    public void addBook(View view) {
        try {
            bookManager.addBook(new Book(3, &quot;天龙八部&quot;));
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    @Override
    protected void onDestroy() {
        if (bookManager != null &amp;&amp; bookManager.asBinder().isBinderAlive()) {
            Log.d(TAG, &quot;unregister listener &quot; + listener);
            try {
                bookManager.unregisterListener(listener);
            } catch (RemoteException e) {
                e.printStackTrace();
            }
        }
        unbindService(mServiceConn);
        super.onDestroy();
    }
}
</code></pre>
<pre><code class="java">public class BookManagerService extends Service {
    private static final String TAG = BookManagerService.class.getSimpleName();

    // CopyOnWriteArrayList 支持并发读写，实现自动线程同步，他不是继承自 ArrayList
    private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;Book&gt;();
    //对象是不能跨进程传输的，对象的跨进程传输本质都是反序列化的过程，Binder 会把客户端传递过来的对象重新转化生成一个新的对象
    //RemoteCallbackList 是系统专门提供的用于删除系统跨进程 listener 的接口，利用底层的 Binder 对象是同一个
    //RemoteCallbackList 会在客户端进程终止后，自动溢出客户端注册的 listener ，内部自动实现了线程同步功能。
    private RemoteCallbackList&lt;INewBookArrivedListener&gt; mListeners = new RemoteCallbackList&lt;&gt;();
    private AtomicBoolean isServiceDestroied = new AtomicBoolean(false);


    private Binder mBinder = new IBookManager.Stub() {

        @Override
        public List&lt;Book&gt; getBookList() throws RemoteException {
            return mBookList;
        }

        @Override
        public void addBook(Book book) throws RemoteException {
            Log.d(TAG, &quot;addBook: &quot; + book.toString());
            mBookList.add(book);

        }

        @Override
        public void registerListener(INewBookArrivedListener listener) throws RemoteException {
            mListeners.register(listener);
        }

        @Override
        public void unregisterListener(INewBookArrivedListener listener) throws RemoteException {
            mListeners.unregister(listener);
        }
    };

    @Override
    public void onCreate() {
        super.onCreate();
        mBookList.add(new Book(1, &quot;老人与海&quot;));
        mBookList.add(new Book(2, &quot;哈姆雷特&quot;));
        new Thread(new ServiceWorker()).start();
    }

    private void onNewBookArrived(Book book) throws RemoteException {
        mBookList.add(book);

        int count = mListeners.beginBroadcast();

        for (int i = 0; i &lt; count; i++) {
            INewBookArrivedListener listener = mListeners.getBroadcastItem(i);
            if (listener != null) {
                listener.onNewBookArrived(book);
            }
        }

        mListeners.finishBroadcast();

    }

    private class ServiceWorker implements Runnable {
        @Override
        public void run() {
            while (!isServiceDestroied.get()) {
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                int bookId = mBookList.size() +1;
                Book newBook = new Book(bookId, &quot;new book # &quot; + bookId);
                try {
                    onNewBookArrived(newBook);
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
            }

        }
    }


    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        //Permission 权限验证
        int check = checkCallingOrSelfPermission(&quot;com.jc.ipc.ACCESS_BOOK_SERVICE&quot;);
        if (check == PackageManager.PERMISSION_DENIED) {
            return null;
        }

        return mBinder;
    }

    @Override
    public void onDestroy() {
        isServiceDestroied.set(true);
        super.onDestroy();
    }
}
</code></pre>
<h3 id="使用-ContentProvider"><a href="#使用-ContentProvider" class="headerlink" title="使用 ContentProvider"></a>使用 ContentProvider</h3><p>用于不同应用间数据共享，和 Messenger 底层实现同样是 Binder 和 AIDL，系统做了封装，使用简单。<br>系统预置了许多 ContentProvider ，如通讯录、日程表，需要跨进程访问。<br>使用方法：继承 ContentProvider 类实现 6 个抽象方法，这六个方法均运行在 ContentProvider 进程中，除 onCreate 运行在主线程里，其他五个方法均由外界回调运行在 Binder 线程池中。</p>
<p>ContentProvider 的底层数据，可以是 SQLite 数据库，可以是文件，也可以是内存中的数据。</p>
<p>详见代码：</p>
<pre><code class="java">public class BookProvider extends ContentProvider {
    private static final String TAG = &quot;BookProvider&quot;;
    public static final String AUTHORITY = &quot;com.jc.ipc.Book.Provider&quot;;

    public static final Uri BOOK_CONTENT_URI = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/book&quot;);
    public static final Uri USER_CONTENT_URI = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/user&quot;);

    public static final int BOOK_URI_CODE = 0;
    public static final int USER_URI_CODE = 1;
    private static final UriMatcher sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);

    static {
        sUriMatcher.addURI(AUTHORITY, &quot;book&quot;, BOOK_URI_CODE);
        sUriMatcher.addURI(AUTHORITY, &quot;user&quot;, USER_URI_CODE);
    }

    private Context mContext;
    private SQLiteDatabase mDB;

    @Override
    public boolean onCreate() {
        mContext = getContext();
        initProviderData();

        return true;
    }

    private void initProviderData() {
        //不建议在 UI 线程中执行耗时操作
        mDB = new DBOpenHelper(mContext).getWritableDatabase();
        mDB.execSQL(&quot;delete from &quot; + DBOpenHelper.BOOK_TABLE_NAME);
        mDB.execSQL(&quot;delete from &quot; + DBOpenHelper.USER_TABLE_NAME);
        mDB.execSQL(&quot;insert into book values(3,&#39;Android&#39;);&quot;);
        mDB.execSQL(&quot;insert into book values(4,&#39;iOS&#39;);&quot;);
        mDB.execSQL(&quot;insert into book values(5,&#39;Html5&#39;);&quot;);
        mDB.execSQL(&quot;insert into user values(1,&#39;haohao&#39;,1);&quot;);
        mDB.execSQL(&quot;insert into user values(2,&#39;nannan&#39;,0);&quot;);

    }

    @Nullable
    @Override
    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
        Log.d(TAG, &quot;query, current thread&quot;+ Thread.currentThread());
        String table = getTableName(uri);
        if (table == null) {
            throw new IllegalArgumentException(&quot;Unsupported URI&quot; + uri);
        }

        return mDB.query(table, projection, selection, selectionArgs, null, null, sortOrder, null);
    }

    @Nullable
    @Override
    public String getType(Uri uri) {
        Log.d(TAG, &quot;getType&quot;);
        return null;
    }

    @Nullable
    @Override
    public Uri insert(Uri uri, ContentValues values) {
        Log.d(TAG, &quot;insert&quot;);
        String table = getTableName(uri);
        if (table == null) {
            throw new IllegalArgumentException(&quot;Unsupported URI&quot; + uri);
        }
        mDB.insert(table, null, values);
        // 通知外界 ContentProvider 中的数据发生变化
        mContext.getContentResolver().notifyChange(uri, null);
        return uri;
    }

    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        Log.d(TAG, &quot;delete&quot;);
        String table = getTableName(uri);
        if (table == null) {
            throw new IllegalArgumentException(&quot;Unsupported URI&quot; + uri);
        }
        int count = mDB.delete(table, selection, selectionArgs);
        if (count &gt; 0) {
            mContext.getContentResolver().notifyChange(uri, null);
        }

        return count;
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
        Log.d(TAG, &quot;update&quot;);
        String table = getTableName(uri);
        if (table == null) {
            throw new IllegalArgumentException(&quot;Unsupported URI&quot; + uri);
        }
        int row = mDB.update(table, values, selection, selectionArgs);
        if (row &gt; 0) {
            getContext().getContentResolver().notifyChange(uri, null);
        }
        return row;
    }

    private String getTableName(Uri uri) {
        String tableName = null;
        switch (sUriMatcher.match(uri)) {
            case BOOK_URI_CODE:
                tableName = DBOpenHelper.BOOK_TABLE_NAME;
                break;
            case USER_URI_CODE:
                tableName = DBOpenHelper.USER_TABLE_NAME;
                break;
            default:
                break;
        }

        return tableName;

    }
}
</code></pre>
<pre><code class="java">public class DBOpenHelper extends SQLiteOpenHelper {

    private static final String DB_NAME = &quot;book_provider.db&quot;;
    public static final String BOOK_TABLE_NAME = &quot;book&quot;;
    public static final String USER_TABLE_NAME = &quot;user&quot;;

    private static final int DB_VERSION = 1;

    private String CREATE_BOOK_TABLE = &quot;CREATE TABLE IF NOT EXISTS &quot;
            + BOOK_TABLE_NAME + &quot;(_id INTEGER PRIMARY KEY,&quot; + &quot;name TEXT)&quot;;

    private String CREATE_USER_TABLE = &quot;CREATE TABLE IF NOT EXISTS &quot;
            + USER_TABLE_NAME + &quot;(_id INTEGER PRIMARY KEY,&quot; + &quot;name TEXT,&quot;
            + &quot;sex INT)&quot;;



    public DBOpenHelper(Context context) {
        super(context, DB_NAME, null, DB_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL(CREATE_BOOK_TABLE);
        db.execSQL(CREATE_USER_TABLE);

    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {

    }
}
</code></pre>
<pre><code class="java">public class ProviderActivity extends AppCompatActivity {
    private static final String TAG = ProviderActivity.class.getSimpleName();
    private TextView displayTextView;
    private Handler mHandler;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_provider);
        displayTextView = (TextView) findViewById(R.id.displayTextView);
        mHandler = new Handler();

        getContentResolver().registerContentObserver(BookProvider.BOOK_CONTENT_URI, true, new ContentObserver(mHandler) {
            @Override
            public boolean deliverSelfNotifications() {
                return super.deliverSelfNotifications();
            }

            @Override
            public void onChange(boolean selfChange) {
                super.onChange(selfChange);
            }

            @Override
            public void onChange(boolean selfChange, Uri uri) {
                Toast.makeText(ProviderActivity.this, uri.toString(), Toast.LENGTH_SHORT).show();
                super.onChange(selfChange, uri);
            }
        });




    }

    public void insert(View v) {
        ContentValues values = new ContentValues();
        values.put(&quot;_id&quot;,1123);
        values.put(&quot;name&quot;, &quot;三国演义&quot;);
        getContentResolver().insert(BookProvider.BOOK_CONTENT_URI, values);

    }
    public void delete(View v) {
        getContentResolver().delete(BookProvider.BOOK_CONTENT_URI, &quot;_id = 4&quot;, null);


    }
    public void update(View v) {
        ContentValues values = new ContentValues();
        values.put(&quot;_id&quot;,1123);
        values.put(&quot;name&quot;, &quot;三国演义新版&quot;);
        getContentResolver().update(BookProvider.BOOK_CONTENT_URI, values , &quot;_id = 1123&quot;, null);


    }
    public void query(View v) {
        Cursor bookCursor = getContentResolver().query(BookProvider.BOOK_CONTENT_URI, new String[]{&quot;_id&quot;, &quot;name&quot;}, null, null, null);
        StringBuilder sb = new StringBuilder();
        while (bookCursor.moveToNext()) {
            Book book = new Book(bookCursor.getInt(0),bookCursor.getString(1));
            sb.append(book.toString()).append(&quot;\n&quot;);
        }
        sb.append(&quot;--------------------------------&quot;).append(&quot;\n&quot;);
        bookCursor.close();

        Cursor userCursor = getContentResolver().query(BookProvider.USER_CONTENT_URI, new String[]{&quot;_id&quot;, &quot;name&quot;, &quot;sex&quot;}, null, null, null);
        while (userCursor.moveToNext()) {
            sb.append(userCursor.getInt(0))
                    .append(userCursor.getString(1)).append(&quot; ,&quot;)
                    .append(userCursor.getInt(2)).append(&quot; ,&quot;)
                    .append(&quot;\n&quot;);
        }
        sb.append(&quot;--------------------------------&quot;);
        userCursor.close();
        displayTextView.setText(sb.toString());
    }
}
</code></pre>
<h3 id="使用-Socket"><a href="#使用-Socket" class="headerlink" title="使用 Socket"></a>使用 Socket</h3><blockquote>
<p>Socket起源于 Unix，而 Unix 基本哲学之一就是“一切皆文件”，都可以用“打开 open –读写 write/read –关闭 close ”模式来操作。Socket 就是该模式的一个实现，网络的 Socket 数据传输是一种特殊的 I/O，Socket 也是一种文件描述符。Socket 也具有一个类似于打开文件的函数调用： Socket()，该函数返回一个整型的Socket 描述符，随后的连接建立、数据传输等操作都是通过该 Socket 实现的。</p>
<p>常用的 Socket 类型有两种：流式 Socket（SOCK_STREAM）和数据报式 Socket（SOCK_DGRAM）。流式是一种面向连接的 Socket，针对于面向连接的 TCP 服务应用；数据报式 Socket 是一种无连接的 Socket ，对应于无连接的 UDP 服务应用。</p>
</blockquote>
<p>Socket 本身可以传输任意字节流。</p>
<p>谈到Socket，就必须要说一说 TCP/IP 五层网络模型：</p>
<ul>
<li>应用层：规定应用程序的数据格式，主要的协议 HTTP，FTP，WebSocket，POP3 等；</li>
<li>传输层：建立“端口到端口” 的通信，主要的协议：TCP，UDP；</li>
<li>网络层：建立”主机到主机”的通信，主要的协议：IP，ARP ，IP 协议的主要作用：一个是为每一台计算机分配 IP 地址，另一个是确定哪些地址在同一子网；</li>
<li>数据链路层：确定电信号的分组方式，主要的协议：以太网协议；</li>
<li>物理层：负责电信号的传输。</li>
</ul>
<p><strong>Socket 是连接应用层与传输层之间接口（API）。</strong></p>
<p></p><p align="center"><img src="https://github.com/astaxie/build-web-application-with-golang/raw/master/zh/images/8.1.socket.png?raw=true" alt="网络模型"></p><p></p>
<p></p><p align="center">图片来自网络</p><p></p>
<p>只实现 TCP Socket 。<br>Client 端代码：</p>
<pre><code class="java">
public class TCPClientActivity extends AppCompatActivity implements View.OnClickListener{

    private static final String TAG = &quot;TCPClientActivity&quot;;
    public static final int MSG_RECEIVED = 0x10;
    public static final int MSG_READY = 0x11;
    private EditText editText;
    private TextView textView;
    private PrintWriter mPrintWriter;
    private Socket mClientSocket;
    private Button sendBtn;
    private StringBuilder stringBuilder;
    private Handler mHandler = new Handler(){
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case MSG_READY:
                    sendBtn.setEnabled(true);
                    break;
                case MSG_RECEIVED:
                    stringBuilder.append(msg.obj).append(&quot;\n&quot;);
                    textView.setText(stringBuilder.toString());
                    break;
                default:
                    super.handleMessage(msg);
            }

    }
    };

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.tcp_client_activity);
        editText = (EditText) findViewById(R.id.editText);
        textView = (TextView) findViewById(R.id.displayTextView);
        sendBtn = (Button) findViewById(R.id.sendBtn);
        sendBtn.setOnClickListener(this);
        sendBtn.setEnabled(false);
        stringBuilder = new StringBuilder();

        Intent intent = new Intent(TCPClientActivity.this, TCPServerService.class);
        startService(intent);

        new Thread(){
            @Override
            public void run() {
                connectTcpServer();
            }
        }.start();
    }


    private String formatDateTime(long time) {
        return new SimpleDateFormat(&quot;(HH:mm:ss)&quot;).format(new Date(time));
    }

    private void connectTcpServer() {
        Socket socket = null;
        while (socket == null) {
            try {
                socket = new Socket(&quot;localhost&quot;, 8888);
                mClientSocket = socket;
                mPrintWriter = new PrintWriter(new BufferedWriter(
                        new OutputStreamWriter(socket.getOutputStream())
                ), true);
                mHandler.sendEmptyMessage(MSG_READY);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        // receive message
        BufferedReader bufferedReader = null;
        try {
            bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        } catch (IOException e) {
            e.printStackTrace();
        }
        while (!isFinishing()) {
            try {
                String msg = bufferedReader.readLine();
                if (msg != null) {
                    String time = formatDateTime(System.currentTimeMillis());
                    String showedMsg = &quot;server &quot; + time + &quot;:&quot; + msg
                            + &quot;\n&quot;;
                    mHandler.obtainMessage(MSG_RECEIVED, showedMsg).sendToTarget();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

        }
    }

    @Override
    public void onClick(View v) {
        if (mPrintWriter != null) {
            String msg = editText.getText().toString();
            mPrintWriter.println(msg);
            editText.setText(&quot;&quot;);
            String time = formatDateTime(System.currentTimeMillis());
            String showedMsg = &quot;self &quot; + time + &quot;:&quot; + msg + &quot;\n&quot;;
            stringBuilder.append(showedMsg);

        }

    }

    @Override
    protected void onDestroy() {
        if (mClientSocket != null) {
            try {
                mClientSocket.shutdownInput();
                mClientSocket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        super.onDestroy();
    }
}
</code></pre>
<p>Server 端代码：</p>
<pre><code class="java">public class TCPServerService extends Service {
    private static final String TAG = &quot;TCPServerService&quot;;
    private boolean isServiceDestroyed = false;
    private String[] mMessages = new String[]{
            &quot;Hello! Body!&quot;,
            &quot;用户不在线！请稍后再联系！&quot;,
            &quot;请问你叫什么名字呀？&quot;,
            &quot;厉害了，我的哥！&quot;,
            &quot;Google 不需要科学上网是真的吗？&quot;,
            &quot;扎心了，老铁！！！&quot;
    };


    @Override
    public void onCreate() {
        new Thread(new TCPServer()).start();
        super.onCreate();
    }

    @Override
    public void onDestroy() {
        isServiceDestroyed = true;
        super.onDestroy();
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    private class TCPServer implements Runnable {

        @Override
        public void run() {
            ServerSocket serverSocket = null;
            try {
                serverSocket = new ServerSocket(8888);
            } catch (IOException e) {
                e.printStackTrace();
                return;
            }
            while (!isServiceDestroyed) {
                // receive request from client
                try {
                    final Socket client = serverSocket.accept();
                    Log.d(TAG, &quot;=============== accept ==================&quot;);
                    new Thread(){
                        @Override
                        public void run() {
                            try {
                                responseClient(client);
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                        }
                    }.start();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

        }
    }


    private void responseClient(Socket client) throws IOException {
        //receive message
        BufferedReader in = new BufferedReader(
                new InputStreamReader(client.getInputStream()));
        //send message
        PrintWriter out = new PrintWriter(
                new BufferedWriter(
                        new OutputStreamWriter(
                                client.getOutputStream())),true);
        out.println(&quot;欢迎来到聊天室！&quot;);

        while (!isServiceDestroyed) {
            String str = in.readLine();
            Log.d(TAG, &quot;message from client: &quot; + str);
            if (str == null) {
                return;
            }
            Random random = new Random();
            int index = random.nextInt(mMessages.length);
            String msg = mMessages[index];
            out.println(msg);
            Log.d(TAG, &quot;send Message: &quot; + msg);
        }
        out.close();
        in.close();
        client.close();

    }
}
</code></pre>
<p>演示：</p>
<p></p><p align="center"><img src="http://i4.buimg.com/588795/90d3ecdb634908c1.jpg" alt="Markdown"></p><br>UDP Socket 可以自己尝试着实现。<p></p>
]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://i4.buimg.com/588795/ecd70e1824f1dc35.jpg&quot; alt=&quot;Markdown&quot;&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;做好眼前的事，保持专注&lt;/p&gt;

&lt;blockq
    
    </summary>
    
      <category term="Android" scheme="https://githubhaohao.github.io/categories/Android/"/>
    
      <category term="进程" scheme="https://githubhaohao.github.io/categories/Android/%E8%BF%9B%E7%A8%8B/"/>
    
    
      <category term="IPC" scheme="https://githubhaohao.github.io/tags/IPC/"/>
    
  </entry>
  
  <entry>
    <title>Android 多线程实现方式</title>
    <link href="https://githubhaohao.github.io/2017/04/22/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>https://githubhaohao.github.io/2017/04/22/Android-多线程实现方式/</id>
    <published>2017-04-22T08:04:55.000Z</published>
    <updated>2017-05-11T12:54:31.208Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><img src="http://i2.muimg.com/588795/ed7dfa64d5e57628.jpg" alt="Markdown"></p>

<p align="center">只为初心</p>

<blockquote>
<p>一个优秀的程序员，必须具备两种能力：</p>
<ul>
<li>学习能力</li>
<li>时间管理能力</li>
</ul>
</blockquote>
<h2 id="Android-多线程实现方式"><a href="#Android-多线程实现方式" class="headerlink" title="Android 多线程实现方式"></a>Android 多线程实现方式</h2><p>通常来说，一个应用至少有一个进程，而一个进程至少有一个线程。<br>线程是 CPU 调度的基本单位，进程是系统资源分配的基本单位。<br>进程独享内存资源，一个进程可以看作一个 JVM ，一个进程崩溃后，在保护模式下一般不会对其它进程产生影响。<br>同一个进程中的线程共享内存资源，一个线程死掉就导致整个进程死掉。<br>行了，进程和线程就扯嫩忙多。<br>Android 提供了四种常用的多线程实现方式：</p>
<ul>
<li><strong>AsyncTask</strong></li>
<li><strong>异步消息机制</strong></li>
<li><strong>IntentService</strong></li>
<li><strong>ThreadPoolExcutor</strong></li>
</ul>
<h3 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h3><p>我们的老朋友 AsyncTask 类，它是封装好的线程池，操作 UI 线程极其方便。</p>
<p>瞅一眼，AsyncTask 的三个泛型参数：</p>
<p><code>public abstract class AsyncTask&lt;Params, Progress, Result&gt;</code></p>
<ul>
<li><code>params</code> ，<strong>传入参数类型</strong>，即 doInBackground() 方法中的参数类型;</li>
<li><code>Progress</code> ，异步任务执行过程中返回的<strong>任务执行进度类型</strong>，即 publishProgress() 和onProgressUpdate() 方法中传入的参数类型；</li>
<li><code>Result</code> ，异步任务执行完<strong>返回的结果类型</strong>，即 doInBackground() 方法中返回值的类型。</li>
</ul>
<p>四个回调方法：</p>
<ul>
<li><code>onPreExecute()</code>，在主线程执行，做一些准备工作。</li>
<li><code>doInBackground()</code>，在线程池中执行，该方法是抽象方法，在此方法中可以调用 <code>publishProgress()</code> 更新任务进度。</li>
<li><code>onProgressUpdate()</code>，在主线程中执行，在 publishProgress() 调用之后被回调，展示任务进度。</li>
<li><code>onPostExecute()</code>，在主线程中执行，异步任务结束后，回调此方法，处理返回结果。</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>当 AsyncTask 任务被取消时，回调 onCanceled(obj) ，此时 onPostExecute()，不会被调用，AsyncTask 中的 cancel() 方法并不是真正去取消任务，只是设置这个任务为取消状态，需要在 doInBackground() 中通过 isCancelled() 判断终止任务。</li>
<li>AsyncTask 必须在主线程中创建实例，execute() 方法也必须在主线程中调用。</li>
<li>每个 AsyncTask 实例只能执行一次 execute() ，多次执行会报错，如需执行多次，则需创建多个实例。</li>
<li>Android 3.0 之后， AsyncTask 对象默认执行多任务是串行执行，即 mAsyncTask.execute() ，并发执行的话需要使用 executeOnExecutor() 。</li>
<li>AsyncTask 用的是线程池机制和异步消息机制（基于 ThreadPoolExecutor 和 Handler ）。Android 2.3 以前，AsyncTask 线程池容量是 128 ，全局线程池只有 5 个工作线程，如果运用 AsyncTask 对象来执行多个并发异步任务，那么同一时间最多只能有 5 个线程同时运行，其他线程将被阻塞。Android 3.0 之后 Google 又进行了调整，新增接口 executeOnExecutor() ，允许自定义线程池（那么核心线程数以及线程容量也可自定义），并提供了 SERIAL_EXECUTOR 和 THREAD_POOL_EXECUTOR 预定义线程池。后来 Google 又做了一些调整（任何事物都不完美），将线程池的容量与 CPU 的核心数联系起来，如目前 SDK 25 版本中，预定义的核心线程数量最少有 2 个，最多 4 个，线程池容量范围 5 ~ 9 。改动如下：</li>
</ul>
<pre><code class="java">    private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
    private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));
    private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;
    private static final int KEEP_ALIVE_SECONDS = 30;
</code></pre>
<h3 id="异步消息机制"><a href="#异步消息机制" class="headerlink" title="异步消息机制"></a>异步消息机制</h3><p>异步消息机制的三大主角： Handler ，Message 和 Looper 。<br>Looper 负责创建 MessageQueue 消息对列，然后进入一个无限 for 循环中，不断地从消息队列中取消息，如果消息队列为空，当前线程阻塞，Handler 负责向消息队列中发送消息。</p>
<h4 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h4><p>Looper 有两个重要的方法： prepare() 和 loop()。</p>
<ul>
<li>prepare() ， Looper 与当前线程绑定，一个线程只能有一个 Looper 实例和一个 MessageQueue 实例。</li>
</ul>
<pre><code class="java">public static final void prepare() {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
        }
        sThreadLocal.set(new Looper(true)); 保证 Looper 对象在当前线程唯一
}

// Looper 的构造方法
private Looper(boolean quitAllowed) {
        mQueue = new MessageQueue(quitAllowed);
        mRun = true;
        mThread = Thread.currentThread();
}
</code></pre>
<ul>
<li>loop ，进入一个无限 for 循环体中，不断地从消息队列中取消息，然后交给消息的 target 属性的 dispatchMessage 方法去处理。</li>
</ul>
<pre><code class="java">public static void loop() {
        final Looper me = myLooper();
        if (me == null) {
            throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#39;t called on this thread.&quot;);
        }
        final MessageQueue queue = me.mQueue;

        // Make sure the identity of this thread is that of the local process,
        // and keep track of what that identity token actually is.
        Binder.clearCallingIdentity();
        final long ident = Binder.clearCallingIdentity();


        // 无限循环体，有没有想过在 UI 线程里，有这样一个死循环，为什么界面没卡死？？
        // 答案最后揭晓。
        for (;;) { 
            Message msg = queue.next(); // might block
            if (msg == null) {
                // No message indicates that the message queue is quitting.
                return;
            }

            msg.target.dispatchMessage(msg);

            msg.recycle();
        }
}
</code></pre>
<h4 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h4><p>Handler 负责向消息队列中发送消息。<br>在 Activity 中我们直接可以 new Handler ，那是因为在 Activity 的启动代码中，已经在当前 UI 线程中调用了 Looper.prepare() 和 Looper.loop() 方法。</p>
<p>在子线程中 new Handler 必须要在当前线程（子线程）中创建好 Looper 对象和消息队列，代码如下</p>
<pre><code class="java">    //在子线程中

    Looper.prepare();

    handler = new Handler() {

        public void handleMessage(Message msg) {
            //处理消息
        };
    };

    Looper.loop();
</code></pre>
<p>之后，你拿着这个 Handler 对象就可以在其他线程中，往这个子线程的消息队列中发消息了。</p>
<h4 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h4><p>HandlerThread 可以看作在子线程中创建一个异步消息处理机制的简化版，HandlerThread 对象自动帮我们在工作线程里创建 Looper 对象和消息队列。</p>
<p>使用方法：</p>
<pre><code class="java">mHandlerThread = new HandlerThread(&quot;MyHandlerThread&quot;);
mHandlerThread.start();

mHandler = new Handler(mHandlerThread.getLooper()){

    @Override
    public void handleMessage(Message msg) {
        //处理消息
    }
};
</code></pre>
<p>之后你就可以使用 Handler 对象往工作线程中的消息队列中发消息了。</p>
<p>看一下源码片段：</p>
<pre><code class="java">public class HandlerThread extends Thread {
    int mPriority;
    int mTid = -1;
    Looper mLooper;

    public HandlerThread(String name) {
        super(name);
        mPriority = Process.THREAD_PRIORITY_DEFAULT;
    }

    protected void onLooperPrepared() {
    }

    @Override
    public void run() {
        mTid = Process.myTid();
        Looper.prepare();
        synchronized (this) {
            mLooper = Looper.myLooper();
            notifyAll();
        }
        Process.setThreadPriority(mPriority);
        onLooperPrepared();
        Looper.loop();
        mTid = -1;
    }

    public Looper getLooper() {
        if (!isAlive()) {
            return null;
        }

        // If the thread has been started, wait until the looper has been created.
        synchronized (this) {
            while (isAlive() &amp;&amp; mLooper == null) {
                try {
                    wait();
                } catch (InterruptedException e) {
                }
            }
        }
        return mLooper;
    }
}
</code></pre>
<p><strong>注意</strong>：handler 在 UI 线程中初始化的，looper 在一个子线程中执行，我们必须等 mLooper 创建完成之后，才能调用 getLooper ，源码中是通过 wait 和 notify 解决两个线程的同步问题。</p>
<h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h3><p>IntentService 可以看成是 Service 和 HandlerThread 的合体。它继承自 Service ，并可以处理异步请求，其内部有一个 WorkerThread 来处理异步任务，当任务执行完毕后，IntentService 自动停止。</p>
<p>如果多次启动 IntentService 呢？ 看到 HandlerThread ，你就应该想到多次启动 IntentService ,就是将多个异步任务放到任务队列里面，然后在 onHandlerIntent 回调方法中串行执行，执行完毕后自动结束。</p>
<p>下面对源码进行简单的解析，IntentService 源码：</p>
<pre><code class="java">public abstract class IntentService extends Service {
    private volatile Looper mServiceLooper;
    private volatile ServiceHandler mServiceHandler;
    private String mName;
    private boolean mRedelivery;
    private final class ServiceHandler extends Handler {
        public ServiceHandler(Looper looper) {
            super(looper);
        }
        @Override
        public void handleMessage(Message msg) {
            //onHandleIntent 方法在工作线程中执行，执行完调用 stopSelf() 结束服务。
            onHandleIntent((Intent)msg.obj);
            stopSelf(msg.arg1);
        }
    }
    /**
     * Creates an IntentService.  Invoked by your subclass&#39;s constructor.
     *
     * @param name Used to name the worker thread, important only for debugging.
     */
    public IntentService(String name) {
        super();
        mName = name;
    }

    /**
     * enabled == true 时，如果任务没有执行完，当前进程就死掉了，那么系统就会令当前进程重启。
     * 任务会被重新执行。
     */
    public void setIntentRedelivery(boolean enabled) {
        mRedelivery = enabled;
    }
    @Override
    public void onCreate() {
        super.onCreate();

        // 上面已经讲过，HandlerThread 对象 start 之后，会在工作线程里创建消息队列 和 Looper 对象。
        HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);
        thread.start();

        mServiceLooper = thread.getLooper();
        // 获得 Looper 对象初始化 Handler 对象。
        mServiceHandler = new ServiceHandler(mServiceLooper);
    }
    @Override
    public void onStart(@Nullable Intent intent, int startId) {
        // IntentService 每次启动都会往工作线程消息队列中添加消息，不会创建新的线程。
        Message msg = mServiceHandler.obtainMessage();
        msg.arg1 = startId;
        msg.obj = intent;
        mServiceHandler.sendMessage(msg);
    }

    // 官方建议 IntentService onStartCommand 方法不应该被重写，注意该方法会调用 onStart 。
    @Override
    public int onStartCommand(@Nullable Intent intent, int flags, int startId) {
        onStart(intent, startId);
        return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;
    }
    @Override
    public void onDestroy() {  
        //服务停止会清除消息队列中的消息，除了当前执行的任务外，后续的任务不会被执行。
        mServiceLooper.quit();
    }
    /**
     * 不建议通过 bind 启动 IntentService ，如果通过 bind 启动 IntentService ，那么 onHandlerIntent 方法不会被回调。Activity 与 IntentService 之间的通信一般采用广播的方式。
     */
    @Override
    @Nullable
    public IBinder onBind(Intent intent) {
        return null;
    }
    /**
     * 子类必须要实现，执行具体的异步任务逻辑，由 IntentService 自动回调。
     */
    @WorkerThread
    protected abstract void onHandleIntent(@Nullable Intent intent);
}
</code></pre>
<p>IntentService 源码很容易理解，你也可以就自己的应用场景封装自己的 IntentService 。</p>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><ul>
<li>正常情况下，启动 IntentService ，任务完成，服务停止；</li>
<li>异步任务完成前，停止 IntentService ，服务停止，但任务还会执行完成，完成后，工作线程结束；</li>
<li>多次启动 IntentService ，任务会被一次串行执行，执行结束后，服务停止；</li>
<li>多次启动 IntentService ，在所有任务执行结束之前，停止 IntentService ，服务停止，除了当前执行的任务外，后续的任务不会被执行；</li>
</ul>
<h3 id="ThreadPoolExcutor"><a href="#ThreadPoolExcutor" class="headerlink" title="ThreadPoolExcutor"></a>ThreadPoolExcutor</h3><p align="center"><img src="http://tutorials.jenkov.com/images/java-concurrency-utils/thread-pool-executor.png" alt="Markdown"></p>

<p align="center">图片来自 Jakob Jenkov 博客</p>

<h4 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h4><p>用来管理一组工作线程，任务队列（ BlockingQueue ）中持有的任务等待着被线程池中的空闲线程执行。</p>
<h4 id="常用构造方法："><a href="#常用构造方法：" class="headerlink" title="常用构造方法："></a>常用构造方法：</h4><pre><code class="java">ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
    int corePoolSize,
    int maximumPoolSize,
    long keepAliveTime,
    TimeUnit unit,
    BlockingQueue&lt;Runnable&gt; workQueue
);
</code></pre>
<ol>
<li>corePoolSize 核心线程池容量，即线程池中所维持线程的最低数量。corePoolSize 初始值为 0 ，当有新任务加入到任务队列中，新的线程将被创建，这个时候即使线程池中存在空闲线程，只要当前线程数小于 corePoolSize ，那么新的线程依然被创建。</li>
<li>maximumPoolSize 线程池中所维持线程的最大数量。</li>
<li>keepAliveTime 空闲线程在没有新任务到来时的存活时间。</li>
<li>unit 参数 keepAliveTime 的时间单位。</li>
<li>workQueue 任务队列，必须是 BlockingQueue 。</li>
</ol>
<h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><h5 id="创建-ThreadFactory-，当然也可以自定义。"><a href="#创建-ThreadFactory-，当然也可以自定义。" class="headerlink" title="创建 ThreadFactory ，当然也可以自定义。"></a>创建 ThreadFactory ，当然也可以自定义。</h5><pre><code class="java">    private static final ThreadFactory sThreadFactory = new ThreadFactory() {
        private final AtomicInteger mCount = new AtomicInteger(1);

        public Thread newThread(Runnable r) {
            return new Thread(r, &quot;AsyncTask #&quot; + mCount.getAndIncrement());
        }
    };
</code></pre>
<h5 id="创建-ThreadPoolExecutor-。"><a href="#创建-ThreadPoolExecutor-。" class="headerlink" title="创建 ThreadPoolExecutor 。"></a>创建 ThreadPoolExecutor 。</h5><pre><code class="java">// 根据 CPU 核心数确定线程池容量。
public static final int NUMBER_OF_CORES = Runtime.getRuntime().availableProcessors(); 

mThreadPoolExecutor = new ThreadPoolExecutor(
        NUMBER_OF_CORES * 2, 
        NUMBER_OF_CORES * 2 + 1,
        60L,
        TimeUnit.SECONDS,
        new LinkedBlockingQueue&lt;Runnable&gt;(),
        backgroundPriorityThreadFactory
);
</code></pre>
<h5 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h5><pre><code class="java">mThreadPoolExecutor.execute(new Runnable() { 

    @Override  
    public void run() {  
         //do something  
    } 

});

Future future = mThreadPoolExecutor.submit(new Runnable() { 

    @Override  
    public void run() {  
         //do something  
    } 

});

//任务可取消
future.cancel(true);

Future&lt;Integer&gt; futureInt = mThreadPoolExecutor.submit(new Callable&lt;Integer&gt;() {
    @override
    public Integer call() throws Exception {
        return 0;
    }

});

//获取执行结果
futureInt.get();

FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;(){
    @override
    public Integer call() throws Exception {
        return 0;
    }    

});

mThreadPoolExecutor.submit(task);
task.get();
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://i2.muimg.com/588795/ed7dfa64d5e57628.jpg&quot; alt=&quot;Markdown&quot;&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;只为初心&lt;/p&gt;

&lt;blockquote&gt;
&lt;
    
    </summary>
    
      <category term="Android" scheme="https://githubhaohao.github.io/categories/Android/"/>
    
      <category term="线程" scheme="https://githubhaohao.github.io/categories/Android/%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="https://githubhaohao.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android Clean 架构浅析</title>
    <link href="https://githubhaohao.github.io/2017/04/15/Android-Clean-%E6%9E%B6%E6%9E%84%E6%B5%85%E6%9E%90/"/>
    <id>https://githubhaohao.github.io/2017/04/15/Android-Clean-架构浅析/</id>
    <published>2017-04-15T13:07:34.000Z</published>
    <updated>2017-05-13T08:10:52.547Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><img src="http://i1.piimg.com/588795/f96da96df4251851.jpg" alt="Cover"></p>

<p align="center">死磕 Android 架构也是一种娱乐</p>

<blockquote>
<p>Android 常用的架构主要有 MVC，MVP，MVVM 以及 Clean 。以上架构设计模式没有绝对的优劣之分，关键要看具体的应用场景。更多关于 MVC，MVP 以及 MVVM 介绍可以参考<a href="http://haohaochang.cn/2017/02/12/MVVM%EF%BC%8CRxJava%E5%92%8CRetrofit%E7%9A%84%E4%B8%80%E6%AC%A1%E5%AE%9E%E8%B7%B5/" target="_blank" rel="external">MVC,MVP &amp; MVVM</a></p>
</blockquote>
<h2 id="什么是-Clean-架构？"><a href="#什么是-Clean-架构？" class="headerlink" title="什么是 Clean 架构？"></a>什么是 Clean 架构？</h2><p align="center"><img src="http://www.elapsetech.com/media/107552/Close-Up-Robert-C-Martin.jpg" alt="author"></p>

<p align="center">Robert C. Martin (Uncle Bob)</p>

<p>Clean 架构是由 Uncle Bob 在 2012 年发表的, 针对 Web App 的架构设计。 </p>
<p>Bob大叔总结了各种系统架构的共通之处以及最终目标，并提出只需秉持分层与依赖规则的原则, 提出了 Clean 架构思想。</p>
<h2 id="Clean-架构浅析"><a href="#Clean-架构浅析" class="headerlink" title="Clean 架构浅析"></a>Clean 架构浅析</h2><h3 id="单向依赖"><a href="#单向依赖" class="headerlink" title="单向依赖"></a>单向依赖</h3><p><img src="https://fernandocejas.com/assets/migrated/clean_architecture1.png" alt="Cover"></p>
<p align="center">图片来自 Robert C. Martin (Uncle Bob)</p>

<p>Clean 架构各层之间的依赖是单向的，只能是外层依赖内层。</p>
<h3 id="MVP-VS-Clean"><a href="#MVP-VS-Clean" class="headerlink" title="MVP VS Clean"></a>MVP VS Clean</h3><p><img src="https://github.com/googlesamples/android-architecture/wiki/images/mvp-clean.png" alt="Cover"></p>
<p align="center">图片来自 Google</p>

<p>从上图可以看到 Clean 架构的 Android 实现，实际上是对目前比较流行的 MVP 架构进行改造。</p>
<p>MVP 之 View 和 Presenter 层作为 Clean 架构的 Presentations Layer, 新增 Domain Layer    处理所有的业务逻辑。MVP 中的 Model 层功能被弱化，作为 Data Layer 对外只提供接口，不再有业务逻辑。 一般来说每一层都有独立的数据模型。</p>
<h3 id="Clean-之-Presentation-层"><a href="#Clean-之-Presentation-层" class="headerlink" title="Clean 之 Presentation 层"></a>Clean 之 Presentation 层</h3><p>包含如下类： </p>
<ul>
<li>Presenter 和 View 层相关类，当然你也可以在 MVVP 架构基础之上进行改造。 </li>
<li>Mapper 类，负责将 Domain 层的数据模型转换为 Presentation 的数据模型。</li>
<li>本层的异常封装类。</li>
</ul>
<h3 id="Clean-之-Domain-层"><a href="#Clean-之-Domain-层" class="headerlink" title="Clean 之 Domain 层"></a>Clean 之 Domain 层</h3><p>Domain 层不依赖于 Android 类库和第三方库，可以独立做单元测试。</p>
<p>包含如下类：</p>
<ul>
<li>Use Cases (Interactor）类，负责完成对 Data 层的某一操作行为。（如获取 movie list ,获取某一 movie 的 detail info 可视为 2 个 Use Case 或 Interactor）。</li>
<li>Mapper 类，负责将 Data 层的数据模型转换为 Domain 层的数据模型。</li>
<li>本层的异常封装类。</li>
</ul>
<h3 id="Clean-之-Data-层"><a href="#Clean-之-Data-层" class="headerlink" title="Clean 之 Data 层"></a>Clean 之 Data 层</h3><p><img src="https://fernandocejas.com/assets/migrated/clean_architecture_data.png" alt="data"></p>
<p align="center">图片来自 Robert C. Martin (Uncle Bob)</p>

<p>这张图就足够说明一切了。</p>
<p>包含各种 API 接口，主要对应数据库操作，文件操作以及网络数据操作，一些异常封装类。<br>Mapper 类，负责将网络数据模型转换为 Data 层的数据模型。</p>
<p><strong>注意 Data 层只提供接口，没有业务逻辑。</strong></p>
<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><ul>
<li><a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean/" target="_blank" rel="external">https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean/</a></li>
<li><a href="https://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/" target="_blank" rel="external">https://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://i1.piimg.com/588795/f96da96df4251851.jpg&quot; alt=&quot;Cover&quot;&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;死磕 Android 架构也是一种娱乐&lt;/p&gt;

&lt;b
    
    </summary>
    
      <category term="Android" scheme="https://githubhaohao.github.io/categories/Android/"/>
    
      <category term="架构" scheme="https://githubhaohao.github.io/categories/Android/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="Clean 架构" scheme="https://githubhaohao.github.io/tags/Clean-%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView 加载与刷新功能实现</title>
    <link href="https://githubhaohao.github.io/2017/04/13/RecyclerView-%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%88%B7%E6%96%B0%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    <id>https://githubhaohao.github.io/2017/04/13/RecyclerView-加载与刷新功能实现/</id>
    <published>2017-04-13T10:30:00.000Z</published>
    <updated>2017-05-13T08:13:56.687Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><img src="http://i2.muimg.com/588795/9485f3b972f5ed01.jpg" alt="Cover"></p>

<p align="center">坚持就是进步</p>

<blockquote>
<p>最近 Kotlin Android 开发貌似要火起来，Kotlin 具有脚本语言风格，能与 Java 无缝兼容，并且有 Google 有意栽培。</p>
</blockquote>
<h2 id="RecyclerView-加载与刷新功能实现"><a href="#RecyclerView-加载与刷新功能实现" class="headerlink" title="RecyclerView 加载与刷新功能实现"></a>RecyclerView 加载与刷新功能实现</h2><p>RecyclerView 功能及灵活性强大到令人发指。在开发中，完全可以用它代替 ListView 和 GridView ，并且还具有瀑布流展示功能。</p>
<p>本文主要对 RecyclerView 进行简单的封装，来实现加载、刷新以及异常状态展示多种功能，实现及其简单，代码量很少。</p>
<h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p><img src="http://i1.piimg.com/588795/ddbeb1bc164791d2.gif" alt="jc-a"><br><img src="http://i1.piimg.com/588795/a8ccce06b8991393.gif" alt="jc-b"></p>
<p><a href="https://github.com/githubhaohao/JCRecyclerView/blob/master/demo.apk" target="_blank" rel="external">Demo 下载</a></p>
<blockquote><p><a href="https://github.com/githubhaohao/JCRecyclerView" target="_blank" rel="external">源码地址: https://github.com/githubhaohao/JCRecyclerView</a></p>
</blockquote>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>JCRecyclerView 继承 RecyclerView ，保留 RecyclerView 的所有特性。</p>
<p>内部类 JCAdapter 对外部的 RecyclerView Adapter 进行拦截改造，实现根据配置在 position = 0 的位置加载 Ad-Slot View （广告位），加载时在底部显示 Bottom View 表视加载正在进行。</p>
<pre><code class="java">    private class JCAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; {

        private RecyclerView.Adapter adapter;

        private static final int TYPE_ADSLOT = 0x10;
        private static final int TYPE_NORMAL = 0x11;
        private static final int TYPE_BOTTOM = 0x12;

        public JCAdapter(RecyclerView.Adapter adapter) {
            this.adapter = adapter;
        }

        @Override
        public void onViewAttachedToWindow(ViewHolder holder) {
            super.onViewAttachedToWindow(holder);
            ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams();
            if(layoutParams != null){
                if(adSlotView != null) {
                    if(layoutParams instanceof  StaggeredGridLayoutManager.LayoutParams &amp;&amp; holder.getLayoutPosition() == 0){
                        StaggeredGridLayoutManager.LayoutParams p = (StaggeredGridLayoutManager.LayoutParams) layoutParams;
                        p.setFullSpan(true);
                    }
                }
                if (bottomView != null &amp;&amp; isLoading) {
                    if(layoutParams instanceof  StaggeredGridLayoutManager.LayoutParams &amp;&amp; holder.getLayoutPosition() == getItemCount() - 1){
                        StaggeredGridLayoutManager.LayoutParams p = (StaggeredGridLayoutManager.LayoutParams) layoutParams;
                        p.setFullSpan(true);
                    }
                }

            }

            if (layoutManager instanceof GridLayoutManager) {
                final GridLayoutManager gridManager = ((GridLayoutManager)
                        layoutManager);
                gridManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() {
                    @Override
                    public int getSpanSize(int position) {
                        boolean spanResult = false;
                        if(adSlotView != null &amp;&amp; bottomView != null) {
                            if (isLoading) {
                                spanResult = (position == 0 || position == getItemCount() - 1);
                            } else {
                                spanResult = (position == 0);
                            }
                        } else if (adSlotView != null) {
                            spanResult = (position==0);
                        } else if (bottomView != null &amp;&amp; isLoading) {
                            spanResult = (position == getItemCount() - 1);
                        }

                        return spanResult
                                ? gridManager.getSpanCount():1;
                    }
                });
            }
        }

        @Override

        public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
            if (viewType == TYPE_ADSLOT) {
                return new JCViewHolder(adSlotView);
            } else if (viewType == TYPE_BOTTOM) {
                return new JCViewHolder(bottomView);
            }

            return adapter.onCreateViewHolder(parent,viewType);
        }

        @Override
        public void onBindViewHolder(ViewHolder holder, int position) {
            if (getItemViewType(0) == TYPE_ADSLOT) {
                if (position == 0) return;
                int newPosition = --position;
                if (adapter != null) {
                    if (newPosition &lt; adapter.getItemCount()) {
                        adapter.onBindViewHolder(holder, newPosition);
                    }
                }
                return;
            } else if (getItemViewType(position) == TYPE_BOTTOM) {
                return;
            }
            adapter.onBindViewHolder(holder, position);

        }

        @Override
        public int getItemCount() {
            int count = adapter.getItemCount();
            if (adSlotView != null) {
                count ++;
            }

            if (bottomView != null &amp;&amp; isLoading) {
                count ++;
            }
            return count;
        }

        @Override
        public int getItemViewType(int position) {
            if (position == 0) {
                return adSlotView == null ? TYPE_NORMAL : TYPE_ADSLOT;
            } else if (position == getItemCount() - 1 &amp;&amp; isLoading) {
                return bottomView == null ? TYPE_NORMAL : TYPE_BOTTOM;
            } else {
                return TYPE_NORMAL;
            }
        }
    }
</code></pre>
<p>向外暴露一个接口 OnLoadMoreListener ，完成加载时的回调。</p>
<pre><code class="java">    public interface OnLoadMoreListener {
        void onLoadMore();
    }
</code></pre>
<p>整体思路就是这些，完整代码：</p>
<pre><code class="java">public class JCRecyclerView extends RecyclerView {

    private static final String TAG = JCRecyclerView.class.getSimpleName();
    private LayoutManager layoutManager;
    private ViewGroup adSlotView;
    private ViewGroup stateView;
    private ViewGroup bottomView;
    private boolean isLoading = false;
    private JCAdapter jcAdapter;
    private OnLoadMoreListener onLoadMoreListener;

    public void addOnLoadMoreListener(OnLoadMoreListener listener) {
        this.onLoadMoreListener = listener;
        this.addOnScrollListener(new OnScrollListener() {
            @Override
            public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
                if (recyclerView.getLayoutManager() instanceof StaggeredGridLayoutManager) {
                    StaggeredGridLayoutManager layoutManager = (StaggeredGridLayoutManager) recyclerView.getLayoutManager();
                    int totalItemCount = recyclerView.getAdapter().getItemCount();
                    int[] lastVisibleItemPositions = new int[layoutManager.getSpanCount()];
                    layoutManager.findLastVisibleItemPositions(lastVisibleItemPositions);
                    int visibleItemCount = recyclerView.getChildCount();
                    int lastVisibleItemPosition = findMaxPosition(lastVisibleItemPositions);

                    if (newState == RecyclerView.SCROLL_STATE_IDLE
                            &amp;&amp; lastVisibleItemPosition == totalItemCount - 1
                            &amp;&amp; visibleItemCount &gt; 0) {
                        if (bottomView == null || isLoading || stateView != null) return;

                        isLoading = true;
                        jcAdapter.notifyDataSetChanged();
                        onLoadMoreListener.onLoadMore();
                        scrollToPosition(jcAdapter.getItemCount() - 1);
                    }
                } else {
                    LinearLayoutManager lm = (LinearLayoutManager) recyclerView.getLayoutManager();
                    int totalItemCount = recyclerView.getAdapter().getItemCount();
                    int lastVisibleItemPosition = lm.findLastVisibleItemPosition();
                    int visibleItemCount = recyclerView.getChildCount();

                    if (newState == RecyclerView.SCROLL_STATE_IDLE
                            &amp;&amp; lastVisibleItemPosition == totalItemCount - 1
                            &amp;&amp; visibleItemCount &gt; 0) {
                        if (bottomView == null || isLoading || stateView != null) return;

                        isLoading = true;
                        jcAdapter.notifyDataSetChanged();
                        onLoadMoreListener.onLoadMore();
                        scrollToPosition(jcAdapter.getItemCount() - 1);
                    }

                }

            }
        });

    }

    private int findMaxPosition(int[] positions) {
        int max = positions[0];
        for (int index = 1; index &lt; positions.length; index++) {
            if (positions[index] &gt; max) {
                max = positions[index];
            }
        }
        return max;
    }

    public void setBottomView(ViewGroup view) {
        if (bottomView == null) {
            this.bottomView = view;
        }

    }

    public void setLoading(boolean flag) {
        if (!flag) {
            isLoading = false;
            jcAdapter.notifyDataSetChanged();
            scrollToPosition(jcAdapter.getItemCount() - 1);
        }

    }

    public void setAdSlotView(ViewGroup view) {
        if (adSlotView == null) {
            adSlotView = view;
            if (jcAdapter != null) {
                jcAdapter.notifyItemInserted(0);
                scrollToPosition(0);
            }
        }
    }

    public void setStateView(ViewGroup view) {
        if (stateView != null) return;
        if (view == null) return;
        if (adSlotView != null) {
            scrollToPosition(0);
            stateView = view;
            Rect rect = new Rect();
            getGlobalVisibleRect(rect);
            LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, rect.bottom - rect.top - adSlotView.getHeight());
            adSlotView.addView(stateView, layoutParams);
        } else {
            showToast(&quot;You should set the ad-slot view at first.&quot;);
        }
    }

    public void removeAdSlotView() {
        if (adSlotView != null &amp;&amp; jcAdapter != null) {
            adSlotView = null;
            jcAdapter.notifyItemRemoved(0);
        }
    }

    public void removeStateView() {
        if (adSlotView != null &amp;&amp; stateView != null &amp;&amp; jcAdapter != null) {
            adSlotView.removeView(stateView);
            stateView = null;
        }
    }

    @Override
    public void setAdapter(Adapter adapter) {
        this.jcAdapter = new JCAdapter(adapter);
        super.setAdapter(this.jcAdapter);
    }

    public JCRecyclerView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    public void setLayoutManager(LayoutManager layoutManager) {
        this.layoutManager = layoutManager;
        super.setLayoutManager(layoutManager);
    }

    private class JCAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; {

        private RecyclerView.Adapter adapter;

        private static final int TYPE_ADSLOT = 0x10;
        private static final int TYPE_NORMAL = 0x11;
        private static final int TYPE_BOTTOM = 0x12;

        public JCAdapter(RecyclerView.Adapter adapter) {
            this.adapter = adapter;
        }

        @Override
        public void onViewAttachedToWindow(ViewHolder holder) {
            super.onViewAttachedToWindow(holder);
            ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams();
            if(layoutParams != null){
                if(adSlotView != null) {
                    if(layoutParams instanceof  StaggeredGridLayoutManager.LayoutParams &amp;&amp; holder.getLayoutPosition() == 0){
                        StaggeredGridLayoutManager.LayoutParams p = (StaggeredGridLayoutManager.LayoutParams) layoutParams;
                        p.setFullSpan(true);
                    }
                }
                if (bottomView != null &amp;&amp; isLoading) {
                    if(layoutParams instanceof  StaggeredGridLayoutManager.LayoutParams &amp;&amp; holder.getLayoutPosition() == getItemCount() - 1){
                        StaggeredGridLayoutManager.LayoutParams p = (StaggeredGridLayoutManager.LayoutParams) layoutParams;
                        p.setFullSpan(true);
                    }
                }

            }

            if (layoutManager instanceof GridLayoutManager) {
                final GridLayoutManager gridManager = ((GridLayoutManager)
                        layoutManager);
                gridManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() {
                    @Override
                    public int getSpanSize(int position) {
                        boolean spanResult = false;
                        if(adSlotView != null &amp;&amp; bottomView != null) {
                            if (isLoading) {
                                spanResult = (position == 0 || position == getItemCount() - 1);
                            } else {
                                spanResult = (position == 0);
                            }
                        } else if (adSlotView != null) {
                            spanResult = (position==0);
                        } else if (bottomView != null &amp;&amp; isLoading) {
                            spanResult = (position == getItemCount() - 1);
                        }

                        return spanResult
                                ? gridManager.getSpanCount():1;
                    }
                });
            }
        }

        @Override

        public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
            if (viewType == TYPE_ADSLOT) {
                return new JCViewHolder(adSlotView);
            } else if (viewType == TYPE_BOTTOM) {
                return new JCViewHolder(bottomView);
            }

            return adapter.onCreateViewHolder(parent,viewType);
        }

        @Override
        public void onBindViewHolder(ViewHolder holder, int position) {
            if (getItemViewType(0) == TYPE_ADSLOT) {
                if (position == 0) return;
                int newPosition = --position;
                if (adapter != null) {
                    if (newPosition &lt; adapter.getItemCount()) {
                        adapter.onBindViewHolder(holder, newPosition);
                    }
                }
                return;
            } else if (getItemViewType(position) == TYPE_BOTTOM) {
                return;
            }
            adapter.onBindViewHolder(holder, position);

        }

        @Override
        public int getItemCount() {
            int count = adapter.getItemCount();
            if (adSlotView != null) {
                count ++;
            }

            if (bottomView != null &amp;&amp; isLoading) {
                count ++;
            }
            return count;
        }

        @Override
        public int getItemViewType(int position) {
            if (position == 0) {
                return adSlotView == null ? TYPE_NORMAL : TYPE_ADSLOT;
            } else if (position == getItemCount() - 1 &amp;&amp; isLoading) {
                return bottomView == null ? TYPE_NORMAL : TYPE_BOTTOM;
            } else {
                return TYPE_NORMAL;
            }
        }
    }

    private class JCViewHolder extends RecyclerView.ViewHolder {

        public JCViewHolder(View itemView) {
            super(itemView);
        }
    }

    private void showToast(String msg) {
        Toast.makeText(getContext(),msg,Toast.LENGTH_SHORT).show();

    }

    public interface OnLoadMoreListener {
        void onLoadMore();
    }
}
</code></pre>
<p>200 多行代码，轻松实现 RecyclerView 刷新、加载以及异常状态的展示功能。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://i2.muimg.com/588795/9485f3b972f5ed01.jpg&quot; alt=&quot;Cover&quot;&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;坚持就是进步&lt;/p&gt;

&lt;blockquote&gt;
&lt;p
    
    </summary>
    
      <category term="Android" scheme="https://githubhaohao.github.io/categories/Android/"/>
    
      <category term="RecyclerView" scheme="https://githubhaohao.github.io/categories/Android/RecyclerView/"/>
    
    
      <category term="RecyclerView 加载与刷新" scheme="https://githubhaohao.github.io/tags/RecyclerView-%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%88%B7%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android jar 与 aar</title>
    <link href="https://githubhaohao.github.io/2017/04/01/Android-jar-%E4%B8%8E-aar/"/>
    <id>https://githubhaohao.github.io/2017/04/01/Android-jar-与-aar/</id>
    <published>2017-04-01T04:43:26.000Z</published>
    <updated>2017-05-13T08:10:16.571Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><img src="http://i4.buimg.com/588795/1372239da58c943a.jpg" alt="Cover"></p>

<p align="center">愚人节不愚人</p>

<blockquote>
<p>最近开始搞机器学习，同时项目也不停的维护着！嘿嘿，明天就是小长假了。</p>
</blockquote>
<h2 id="Android-jar-与-aar"><a href="#Android-jar-与-aar" class="headerlink" title="Android jar 与 aar"></a>Android jar 与 aar</h2><p><strong>jar</strong> (<strong>Java Application Resource</strong>) 是一种归档文件，以 ZIP 格式构建，以 .jar 为文件扩展名。用户可以使用JDK自带的 jar 命令创建或提取 JAR 文件。<strong>jar 文件只包含 class 文件和 配置文件。</strong></p>
<p><strong>aar</strong> (<strong>Android Application Resource</strong>) 是 android 中特有的归档文件，<strong>既包含 class 文件也包含 android 的 res 资源文件</strong>。</p>
<h2 id="Android-Studio-生成-jar-和-aar-文件"><a href="#Android-Studio-生成-jar-和-aar-文件" class="headerlink" title="Android Studio 生成 jar 和 aar 文件"></a>Android Studio 生成 jar 和 aar 文件</h2><h3 id="新建一个-Module"><a href="#新建一个-Module" class="headerlink" title="新建一个 Module"></a>新建一个 Module</h3><p>Android studio 菜单<strong> File -&gt; New -&gt; New Module -&gt; Android Module</strong> 。<br><img src="http://i4.buimg.com/588795/339c66823e3c881b.png" alt="new module"> </p>
<p>创建名为 mylibrary 的 module。</p>
<p><img src="http://i2.muimg.com/588795/afacc81c2031edea.png" alt="module"></p>
<p>在 mylibrary 下新建一个类 <strong>Person</strong> ,等会在 app module 下访问它。</p>
<p><img src="http://i4.buimg.com/588795/71501892d1d08bd4.png" alt="person"></p>
<h3 id="生成-jar-和-aar-文件"><a href="#生成-jar-和-aar-文件" class="headerlink" title="生成 jar 和 aar 文件"></a>生成 jar 和 aar 文件</h3><p>直接 Rebuild 或者运行 mylibrary task 如下图：<br><img src="http://i4.buimg.com/588795/88c5a8a24aca2790.png" alt="task"></p>
<p>Build Successful 之后可在下图的目录下找到 jar 和 arr 文件。<br><img src="http://i2.muimg.com/588795/76e1e131b84d17ec.png" alt="file"></p>
<p><img src="http://i2.muimg.com/588795/951d7279602acaad.png" alt="aar"></p>
<h3 id="引入-jar"><a href="#引入-jar" class="headerlink" title="引入 jar"></a>引入 jar</h3><ul>
<li>将 jar 文件拷贝到 app 的 lib 文件夹下；</li>
<li>右击 jar 文件，选择 <strong>Add As Library</strong> ，添加到 app module 下，然后 Android Studio 会自动编译。</li>
</ul>
<h3 id="引入-aar"><a href="#引入-aar" class="headerlink" title="引入 aar"></a>引入 aar</h3><ul>
<li>将 aar 文件拷贝到 app 的 lib 文件夹下 (可以修改 aar 文件名字，本例中修改为 mylibrary )；</li>
<li>修改 build.gradle 配置文件：<br>```gradle<br>android {<br>……<br>repositories {<br>   flatDir {<pre><code>   dirs &#39;libs&#39;
</code></pre>   }<br>}<br>}</li>
</ul>
<p>dependencies {<br>    ……<br>    compile(name: ‘mylibrary’, ext: ‘aar’)<br> } </p>
<p>```<br>Async Project 大工告成。</p>
<p>同样，你也可以在其他工程中引入 jar 或 aar 文件。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://i4.buimg.com/588795/1372239da58c943a.jpg&quot; alt=&quot;Cover&quot;&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;愚人节不愚人&lt;/p&gt;

&lt;blockquote&gt;
&lt;p
    
    </summary>
    
      <category term="Android" scheme="https://githubhaohao.github.io/categories/Android/"/>
    
    
      <category term="jar aar" scheme="https://githubhaohao.github.io/tags/jar-aar/"/>
    
  </entry>
  
  <entry>
    <title>Android 四大组件之 Activity</title>
    <link href="https://githubhaohao.github.io/2017/03/01/Android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8B-Activity/"/>
    <id>https://githubhaohao.github.io/2017/03/01/Android-四大组件之-Activity/</id>
    <published>2017-03-01T06:36:14.000Z</published>
    <updated>2017-05-13T08:11:37.470Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><img src="http://i2.buimg.com/588795/f44c5bdc30a8cc26.jpg" alt="Cover"></p>

<p align="center">唉！最近拖延症又犯了</p>

<blockquote>
<p>最近真的是越来越懒了，总是找各种理由不写博客。虽然最近各种事，又搞论文，又搞项目的，再拖下去实在是对不住 “不忘初心” 这一句话。惭愧！<br>虽然关于 Activity 已经被写烂了，但是从本篇文章里，你一定会发现不同的东西。</p>
</blockquote>
<h2 id="Activity-生命周期"><a href="#Activity-生命周期" class="headerlink" title="Activity 生命周期"></a>Activity 生命周期</h2><h3 id="一般情况下"><a href="#一般情况下" class="headerlink" title="一般情况下"></a>一般情况下</h3><p><img src="https://developer.android.com/images/activity_lifecycle.png" alt="haohaochang.cn"></p>
<pre><code class="java"> public class Activity extends ApplicationContext {
     protected void onCreate(Bundle savedInstanceState);

     protected void onStart();

     protected void onResume();

     protected void onPause();

     protected void onStop();

     protected void onDestroy();
 }
</code></pre>
<h3 id="异常情况下"><a href="#异常情况下" class="headerlink" title="异常情况下"></a>异常情况下</h3><h4 id="系统配置变化导致Activity销毁重建"><a href="#系统配置变化导致Activity销毁重建" class="headerlink" title="系统配置变化导致Activity销毁重建"></a>系统配置变化导致Activity销毁重建</h4><ol>
<li>旋转屏幕，Activity 销毁并重新创建，在异常情况下系统会在 onStop 之前调用 onSaveInstanceState 来保存状态。Activity 重新创建后，会在 onStart 之后调用 onRestoreInstanceState 恢复之前保存的数据。</li>
<li>系统只在 Activity 异常终止的时候才会调用 onSaveInstanceState 和 onRestoreInstanceState 方法。其他情况不会触发。</li>
</ol>
<h4 id="资源内存不足导致低优先级的-Activity-被回收"><a href="#资源内存不足导致低优先级的-Activity-被回收" class="headerlink" title="资源内存不足导致低优先级的 Activity 被回收"></a>资源内存不足导致低优先级的 Activity 被回收</h4><ol>
<li>前台- 可见非前台（被对话框遮挡的 Activity ）-后台，这三种 Activity 优先级从高到低。</li>
<li><code>android:configChanges=&quot;orientation&quot;</code> 在 manifest 中指定 configChanges 在系统配置变化后不重新创建 Activity，也不会执行onSaveInstanceState 和 onRestoreInstanceState 方法，而是调用 onConfigurationChnaged 方法。</li>
<li>configChanges 一般常用三个选项：<ul>
<li>locale <strong>系统语言变化</strong></li>
<li>keyborardHidden <strong>键盘的可访问性发生了变化，比如用户调出了键盘</strong></li>
<li>orientation <strong>屏幕方向变化</strong></li>
</ul>
</li>
</ol>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h4 id="首次启动-Activity"><a href="#首次启动-Activity" class="headerlink" title="首次启动 Activity"></a>首次启动 Activity</h4><pre><code>MainActivity onCreate
MainActivity onStart
MainActivity onResume
</code></pre><h4 id="跳转到-SecondActivity"><a href="#跳转到-SecondActivity" class="headerlink" title="跳转到 SecondActivity"></a>跳转到 SecondActivity</h4><pre><code>MainActivity onPause
SecondActivity onCreate
SecondActivity onStart
SecondActivity onResume
MainActivity onStop
</code></pre><h4 id="Back-返回-MainActivity"><a href="#Back-返回-MainActivity" class="headerlink" title="Back 返回 MainActivity"></a>Back 返回 MainActivity</h4><pre><code>SecondActivity onPause
MainActivity onRestart
MainActivity onStart
MainActivity onResume
SecondActivity onStop
SecondActivity onDestroy
</code></pre><h4 id="Home-回退桌面"><a href="#Home-回退桌面" class="headerlink" title="Home 回退桌面"></a>Home 回退桌面</h4><pre><code>MainActivity onPause
MainActivity onStop
</code></pre><h4 id="桌面返回可见"><a href="#桌面返回可见" class="headerlink" title="桌面返回可见"></a>桌面返回可见</h4><pre><code>MainActivity onRestart
MainActivity onStart
MainActivity onResume
</code></pre><h4 id="锁屏"><a href="#锁屏" class="headerlink" title="锁屏"></a>锁屏</h4><pre><code>MainActivity onPause
MainActivity onStop
</code></pre><h4 id="解锁屏"><a href="#解锁屏" class="headerlink" title="解锁屏"></a>解锁屏</h4><pre><code>MainActivity onRestart
MainActivity onStart
MainActivity onResume
</code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><blockquote><p>onStart 开始到 onStop 之前， Activity 可见。<br>onResume 开始到 onPause 之前， Activity 可接受用户交互。<br>在新Activity启动之前，栈顶的Activity需要先onPause后，新Activity才能启动。所以不能在onPause执行耗时操作。</p>
</blockquote>
<h2 id="Activity-数据传递"><a href="#Activity-数据传递" class="headerlink" title="Activity 数据传递"></a>Activity 数据传递</h2><p>Activity 传递数据一般有以下几种方式：</p>
<h3 id="Intent-传递数据"><a href="#Intent-传递数据" class="headerlink" title="Intent 传递数据"></a>Intent 传递数据</h3><p>MainActivity</p>
<pre><code class="java">Intent intent=new Intent();  
intent.setClass(MainActivity.this, OtherActivity.class);  
Bundle bundle = new Bundle();  
bundle.putString(KEY, VALUE);
intent.putExtras(bundle);  
startActivity（intent）;
</code></pre>
<p>OtherActivity</p>
<pre><code class="java">Intent intent = getIntent();  
Bundle bundle = intent.getEtras();  
String value = bundle.getString(KEY);
</code></pre>
<p>利用 Intent 对象在 Activity 之间传递数据是 Android 开发最常用的方式。<br>利用 Intent 对象可以传递基本数据类型，以及一些可序列化的对象。</p>
<h3 id="public-型的静态变量"><a href="#public-型的静态变量" class="headerlink" title="public 型的静态变量"></a>public 型的静态变量</h3><p>public 型的静态变量，在类被加载的时候，就被创建在静态存储区，不依赖于对象。</p>
<h3 id="Application-对象"><a href="#Application-对象" class="headerlink" title="Application 对象"></a>Application 对象</h3><p>在整个应用程序中就一个Application单例，它的生命周期贯穿整个程序，堆内存中只存在一个对象实例，所以程序内所有它的引用指向的是同一块堆内存，所以可以在不同activity对application实例变量进行值的存取。<br><em>不推荐</em>。</p>
<h3 id="Clipboard-剪切板"><a href="#Clipboard-剪切板" class="headerlink" title="Clipboard 剪切板"></a>Clipboard 剪切板</h3><p>ClipboardManager：该类是系统剪切板服务的接口，用来放入或取出全局剪切板中的文本。</p>
<pre><code class="java">ClipboardManager clipboardManager = (ClipboardManager)getSystemService(Context.CLIPBOARD_SERVICE);

clipboardManager.setText(DATA.toString());
}
</code></pre>
<pre><code class="java">ClipboardManager clipboardManager = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);  
String data = clipboardManager.getText().toString();
</code></pre>
<p>Clipboard 也可以传递可序列化对象。</p>
<h3 id="文件传值"><a href="#文件传值" class="headerlink" title="文件传值"></a>文件传值</h3><p>通过向本地文件写入和读取来传递数据。<br>常用的如 SharedPrefrences 对象等。</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>你自己想吧！</p>
<h2 id="Activity-启动模式"><a href="#Activity-启动模式" class="headerlink" title="Activity 启动模式"></a>Activity 启动模式</h2><p>启动模式,简单地说就是 Activity 启动时的策略，在AndroidManifest.xml 中的标签的 android:launchMode 属性设置；</p>
<p>启动模式有4种，分别为 <strong>standard、singleTop、singleTask、singleInstance；</strong></p>
<h3 id="standard-模式"><a href="#standard-模式" class="headerlink" title="standard 模式"></a>standard 模式</h3><p>每次 startActivity 时，都创建 Activity 实例，并放入任务栈，该任务栈中，可以有多个同类 Activity 的实例。</p>
<p><strong>应用场景</strong>：Your idea。</p>
<h3 id="singleTop-模式"><a href="#singleTop-模式" class="headerlink" title="singleTop 模式"></a>singleTop 模式</h3><p>栈顶不是该类型的 Activity，则创建一个新的 Activity。否则，回调该  Activity 实例的 onNewIntent 方法。</p>
<p><strong>应用场景</strong>：接收通知消息启动的页面。</p>
<p>例如，对于推送比较频繁的应用，如果收到多个推送，每次都打开一个页面显示内容是不妥的。</p>
<h3 id="singleTask-模式"><a href="#singleTask-模式" class="headerlink" title="singleTask 模式"></a>singleTask 模式</h3><p>任务栈中不存在启动 Activity 的实例，则创建 Activity 放入任务栈。<br>否则，回调该 Activity 的 onNewIntent 方法，并将该 Activity 置于栈顶，其以上的 Activity 都被弹出 (pop)。<strong>[onNewIntent + clearTop]</strong></p>
<p><strong>应用场景</strong>：作为应用的入口点。</p>
<p>例如，对于浏览器的主界面，不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走 onNewIntent ，并且会清空主界面上面的其他页面。</p>
<h3 id="singleInstance-模式"><a href="#singleInstance-模式" class="headerlink" title="singleInstance 模式"></a>singleInstance 模式</h3><p>回退栈中，只有这一个Activity，没有其他Activity。</p>
<p><strong>应用场景</strong>：闹铃的响铃界面。正在进行 QQ 聊天室时，闹铃响了，弹出一个对话形式的（以 SingleInstance 加载模式打开的）AlarmActivity，按了返回键之后回到 QQ 聊天界面，这是因为 Alarm Activity 所在的任务栈只有它一个元素， 因此退出之后这个任务栈空了。如果是以 SingleTask 打开 AlarmActivity，那么当闹铃响了的时候，按返回键应该进入闹铃设置界面。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://i2.buimg.com/588795/f44c5bdc30a8cc26.jpg&quot; alt=&quot;Cover&quot;&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;唉！最近拖延症又犯了&lt;/p&gt;

&lt;blockquote
    
    </summary>
    
      <category term="Android" scheme="https://githubhaohao.github.io/categories/Android/"/>
    
      <category term="四大组件" scheme="https://githubhaohao.github.io/categories/Android/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
    
      <category term="Activity" scheme="https://githubhaohao.github.io/tags/Activity/"/>
    
  </entry>
  
  <entry>
    <title>Android 主题切换和多主题实现</title>
    <link href="https://githubhaohao.github.io/2017/02/17/Android%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2%E5%92%8C%E5%A4%9A%E4%B8%BB%E9%A2%98%E5%AE%9E%E7%8E%B0/"/>
    <id>https://githubhaohao.github.io/2017/02/17/Android主题切换和多主题实现/</id>
    <published>2017-02-17T06:13:42.000Z</published>
    <updated>2017-05-13T08:19:35.108Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/githubhaohao/ImageRoom/blob/master/Images/multi-theme/giraffe-1959110__340.jpg?raw=true" alt="Cover"></p>
<p align="center">又是一个周末</p>

<h2 id="白天和夜间模式"><a href="#白天和夜间模式" class="headerlink" title="白天和夜间模式"></a>白天和夜间模式</h2><p>Android官方在Support包从23.2版本开始提供支持白天夜间模式的主题 Theme.AppCompat.DayNight，也就是 DayNight Mode ，轻松实现主体无缝切换。</p>
<p>Theme.AppCompat.DayNight 可以根据系统时间切换 Theme.AppCompat (暗色) 和 Theme.AppCompat.Light ( 亮色 ) 两种主题。这将大大提高了阅读类应用的用户体验 同时还支持 Material Design。</p>
<p><strong>需要注意的是</strong>，这个特性只支持 API v14 及以上的 Android 设备，在 API v14 以下的设备则会默认使用亮色的主题。</p>
<h3 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h3><p><img src="https://github.com/githubhaohao/ImageRoom/blob/master/Images/multi-theme/multi_theme.gif?raw=true" alt="效果预览"></p>
<h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><h4 id="1-引入-support-v7-23-2-版本的依赖"><a href="#1-引入-support-v7-23-2-版本的依赖" class="headerlink" title="1. 引入 support-v7:23.2+ 版本的依赖"></a>1. 引入 support-v7:23.2+ 版本的依赖</h4><pre><code class="gradle">compile &#39;com.android.support:appcompat-v7:25.1.1&#39;
</code></pre>
<p>为保证主题风格的统一，所有的 Activity 类应继承 AppCompatActivity 。</p>
<h4 id="2-自定义实现-DayNight-主题"><a href="#2-自定义实现-DayNight-主题" class="headerlink" title="2. 自定义实现 DayNight 主题"></a>2. 自定义实现 DayNight 主题</h4><p><img src="https://github.com/githubhaohao/ImageRoom/blob/master/Images/multi-theme/res-night.png?raw=true" alt="res-night"></p>
<p>res 目录下新建 values-night 文件，拷贝修改 colors.xml 和 styles.xml 文件到 values-night，为 Night Model 下系统加载的 color资源，同样地也可以指定 Night Model 下加载的 drawable 资源在 drawable-night 文件夹中，同理 layout mipmap 资源加载也是如此。</p>
<pre><code class="xml">    &lt;style name=&quot;MyApp.DayNight.NoActionBar.Theme&quot; parent=&quot;Theme.AppCompat.DayNight.NoActionBar&quot;&gt;
        &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;
        &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;
        &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;
        &lt;item name=&quot;android:textColorPrimary&quot;&gt;@color/colorAccent&lt;/item&gt;
    &lt;/style&gt;
</code></pre>
<p>具体位置颜色设置看图：</p>
<p><img src="https://github.com/githubhaohao/ImageRoom/blob/master/Images/multi-theme/screen.png?raw=true" alt="screen"></p>
<p>在 AndroidManifest.xml 中声明，单个 Activity 的主题。 </p>
<pre><code class="xml">    &lt;application
        android:name=&quot;.MyApplication&quot;
        android:allowBackup=&quot;true&quot;
        android:icon=&quot;@mipmap/ic_launcher&quot;
        android:label=&quot;@string/app_name&quot;
        android:supportsRtl=&quot;true&quot;&gt;
        &lt;activity
            android:name=&quot;.MainActivity&quot;
            android:label=&quot;@string/app_name&quot;
            android:theme=&quot;@style/MyApp.DayNight.NoActionBar.Theme&quot;&gt;
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;

                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
    &lt;/application&gt;
</code></pre>
<p>或者整个 App 的主题</p>
<pre><code class="xml">
    &lt;application
        android:name=&quot;.MyApplication&quot;
        android:allowBackup=&quot;true&quot;
        android:icon=&quot;@mipmap/ic_launcher&quot;
        android:label=&quot;@string/app_name&quot;
        android:supportsRtl=&quot;true&quot;
        android:theme=&quot;@style/MyApp.DayNight.NoActionBar.Theme&quot;&gt;
        &lt;activity
            android:name=&quot;.MainActivity&quot;
            android:label=&quot;@string/app_name&quot;
            &gt;
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;

                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
    &lt;/application&gt;
</code></pre>
<h4 id="3-设置-DayNight-主题"><a href="#3-设置-DayNight-主题" class="headerlink" title="3 设置 DayNight 主题"></a>3 设置 DayNight 主题</h4><p>初始化主题:</p>
<pre><code class="java">    private void initAppTheme() {
        if (getThemeSharedPref().getBoolean(KEY_NIGHT_THEME, false)) {
            getDelegate().setLocalNightMode(AppCompatDelegate.MODE_NIGHT_YES);
        } else {
            getDelegate().setLocalNightMode(AppCompatDelegate.MODE_NIGHT_NO);
        }
    }

    private SharedPreferences getThemeSharedPref() {
        return getSharedPreferences(&quot;APP_THEME&quot;, Context.MODE_PRIVATE);
    }
</code></pre>
<p>初始化主题应该在 <strong>super.onCreate() </strong> 之前执行，不然 Activity 会启动 2 次,下图为证：</p>
<p><img src="https://github.com/githubhaohao/ImageRoom/blob/master/Images/multi-theme/restart.png?raw=true" alt="restart"></p>
<p>切换主题：</p>
<pre><code class="java">        if (id == R.id.set_day_theme) {
            getDelegate().setLocalNightMode(AppCompatDelegate.MODE_NIGHT_NO);
            getThemeSharedPref().edit().putBoolean(KEY_NIGHT_THEME,false).apply();
        } else if (id == R.id.set_night_theme) {
            getDelegate().setLocalNightMode(AppCompatDelegate.MODE_NIGHT_YES);
            getThemeSharedPref().edit().putBoolean(KEY_NIGHT_THEME, true).apply();
        }
</code></pre>
<p><strong>切换主题会重启 Activity。</strong></p>
<p>DayNight Theme 有 4 种 Model ，分别是：</p>
<ul>
<li>MODE_NIGHT_NO. 使用 Day 主题</li>
<li>MODE_NIGHT_YES. 使用暗色 Night 主题</li>
<li>MODE_NIGHT_AUTO. 根据系统时间自动切换</li>
<li>MODE_NIGHT_FOLLOW_SYSTEM(默认选项). 设置为跟随系统</li>
</ul>
<h2 id="多主题实现"><a href="#多主题实现" class="headerlink" title="多主题实现"></a>多主题实现</h2><p>介绍几种换肤的第三方库。</p>
<h3 id="MultipleTheme"><a href="#MultipleTheme" class="headerlink" title="MultipleTheme"></a><a href="https://github.com/dersoncheng/MultipleTheme" target="_blank" rel="external">MultipleTheme</a></h3><blockquote>
<p>真正的支持无缝换肤／夜间模式的Android框架，配合theme和换肤控件框架可以做到无缝切换换肤（无需重启应用和当前页面）。</p>
<p>该应用框架可以实现无缝换肤／切换夜间模式的需求，需要在换肤／切换夜间模式的界面只需要使用框架里的自封装控件，其他界面的控件使用原生android控件即可。</p>
</blockquote>
<p><strong>缺陷</strong>：各种控件都需要重定义。<br><strong>优势</strong>：扩展性强，无需重启 Activity。</p>
<h3 id="Colorful-推荐"><a href="#Colorful-推荐" class="headerlink" title="Colorful [推荐]"></a><a href="https://github.com/garretyoder/Colorful" target="_blank" rel="external">Colorful</a> [推荐]</h3><blockquote>
<p>Colorful is a dynamic theme library allowing you to change your apps’ color schemes easily.</p>
</blockquote>
<p><strong>缺陷</strong>：主题颜色可定制性差，不支持 Material Design 风格。<br><strong>优势</strong>：使用方便。</p>
<h3 id="Prism"><a href="#Prism" class="headerlink" title="Prism"></a><a href="https://github.com/StylingAndroid/Prism" target="_blank" rel="external">Prism</a></h3><p><img src="https://blog.leancloud.cn/wp-content/uploads/2015/09/Android_Rainbow_All720-e1441357130150.jpg" alt="Prism"></p>
<p>Prism 下含有三个库：</p>
<ul>
<li>prsim 库含有一些核心功能；</li>
<li>prism-viewpager 库实现了核心库与 ViewPager 的对接；</li>
<li>prism-palette 库实现了核心库与 Palette 的对接。</li>
</ul>
<p>分成三个库是为了区分依赖条件：核心库不依赖外部条件，它能够很容易地添加到你的工程之中；但是 prism-viewpager 和 prism-palette 需要依赖相应的support库。所以当你的程序不使用这些依赖库时，你可以只使用 prism 库来省去不必要的依赖条件。不过当你的程序中使用了 ViewPager 时，即已经对相关的support库有了依赖，那么添加 prism-viewpager 库就不需要额外的依赖条件。</p>
<p><strong>但是，作者已停止更新。</strong></p>
<h3 id="Android-Skin-Loader-推荐"><a href="#Android-Skin-Loader-推荐" class="headerlink" title="Android-Skin-Loader [推荐]"></a><a href="https://github.com/fengjundev/Android-Skin-Loader" target="_blank" rel="external">Android-Skin-Loader</a> [推荐]</h3><p>看效果</p>
<p><img src="https://github.com/githubhaohao/ImageRoom/blob/master/Images/multi-theme/skin_loader.gif?raw=true" alt="skin-loader"></p>
<p>项目目录：</p>
<p><img src="https://github.com/githubhaohao/ImageRoom/blob/master/Images/multi-theme/skin.png?raw=true" alt="项目目录"></p>
<p>Android-Skin-Loader<br>├── android-skin-loader-lib      // 皮肤加载库<br>├── android-skin-loader-sample   // 皮肤库应用实例<br>├── android-skin-loader-skin     // 皮肤包生成demo<br>└── skin-package                 // 皮肤包输出目录</p>
<p>可以将皮肤文件打包分离，支持在线换肤，皮肤共享，不会重启 Activity 或 Fragment 。皮肤包（ 后缀名为.skin ）的本质是一个apk文件，该apk文件不包含代码，只包含资源文件。 </p>
<p><strong>缺陷</strong>：每个换肤的 View 都要设置 <code>skin:enable=&quot;true&quot;</code> 繁琐 ( 反正我感觉挺烦的 )，不支持 Material Design 风格。</p>
<p>不过，还好 <a href="https://github.com/burgessjp/ThemeSkinning" target="_blank" rel="external">ThemeSkinning</a> 进行了优化，支持 Material Design 和字体的切换。</p>
<p>示例：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/623504-0c8a0c72d3a173ed.gif?imageMogr2/auto-orient/strip" alt="sample"></p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/githubhaohao/ImageRoom/blob/master/Images/multi-theme/giraffe-1959110__340.jpg?raw=true&quot; alt=&quot;Cover&quot;&gt;&lt;/p&gt;
&lt;p
    
    </summary>
    
      <category term="Android" scheme="https://githubhaohao.github.io/categories/Android/"/>
    
      <category term="主题" scheme="https://githubhaohao.github.io/categories/Android/%E4%B8%BB%E9%A2%98/"/>
    
    
      <category term="Android 主题切换" scheme="https://githubhaohao.github.io/tags/Android-%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>MVVM，RxJava 和 Retrofit 的一次实践</title>
    <link href="https://githubhaohao.github.io/2017/02/12/MVVM%EF%BC%8CRxJava%E5%92%8CRetrofit%E7%9A%84%E4%B8%80%E6%AC%A1%E5%AE%9E%E8%B7%B5/"/>
    <id>https://githubhaohao.github.io/2017/02/12/MVVM，RxJava和Retrofit的一次实践/</id>
    <published>2017-02-12T06:21:25.000Z</published>
    <updated>2017-05-13T08:20:15.060Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/githubhaohao/ImageRoom/blob/master/Images/country-1295915__340.png?raw=true" alt="Cover"></p>
<p align="center">春节后的第一篇博客</p>

<blockquote>
<p>本文已授权微信公众号：鸿洋（hongyangAndroid）原创首发。<br>原创文章，转载请注明出处:<a href="http://haohaochang.cn/2017/02/12/MVVM%EF%BC%8CRxJava%E5%92%8CRetrofit%E7%9A%84%E4%B8%80%E6%AC%A1%E5%AE%9E%E8%B7%B5/" target="_blank" rel="external">haohaochang.cn</a></p>
</blockquote>
<hr>
<h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><img src="https://github.com/githubhaohao/MVVMRxJavaRetrofitSample/blob/master/image/sample.gif?raw=true" alt="result"></p>
<p><a href="https://github.com/githubhaohao/MVVMRxJavaRetrofitSample/blob/master/demo.apk" target="_blank" rel="external">Demo 下载</a></p>
<h2 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p><img src="https://github.com/githubhaohao/ImageRoom/blob/master/Images/mvvm/mvc.PNG?raw=true" alt="mvc"></p>
<ul>
<li><strong>视图层（View）</strong>：用户界面。</li>
<li><strong>控制器层（Controller）</strong>：业务逻辑</li>
<li><strong>模型层（Model）</strong>：数据保存</li>
</ul>
<hr>
<ol>
<li>View 层传送指令到 Controller 层</li>
<li>Controller 层完成业务逻辑后，要求 Model 层改变状态</li>
<li>Model 层将新的数据发送到 View层，使用户得到反馈</li>
</ol>
<p><strong>缺陷</strong>:View 层和 Model 层是相互可知，耦合性大，像 Activity 或者 Fragment 既在 Controller 层，又在 View 层，造成工程的可扩展性可维护性非常差。</p>
<h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p><img src="https://github.com/githubhaohao/ImageRoom/blob/master/Images/mvvm/mvp.png?raw=true" alt="mvp"></p>
<p>在 MVP 架构模式中，Controller 层变成了 Presenter 层。</p>
<ol>
<li>MVP 模式各层之间的通信，都是双向的。</li>
<li>View 层与 Model 层不直接发生联系，都通过 Presenter 层进行间接通信。</li>
<li>Model 层与 Presenter 层，Presenter 层与 View 层之间通过接口建立联系。</li>
</ol>
<p>采用 MVP 模式，Activity 与 Fragment 只位于 View 层。</p>
<p><strong>MVP 的缺陷在于</strong>:由于我们使用了接口的方式去连接 View 层和  Presenter 层，这样就导致了特定场景下的一些问题，当你的页面逻辑很复杂的时候，你的 View 层实现的接口会有很多，如果你的 App 中有很多个这样复杂的页面，维护接口的成本就会变的非常的大。</p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p><img src="https://github.com/githubhaohao/ImageRoom/blob/master/Images/mvvm/mvvp.PNG?raw=true" alt="MVVM"></p>
<p>MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。<br><strong>区别在于</strong>: View 层与 ViewModel 层通过 DataBinding 相互绑定，View 层的变动，自动反映在 ViewModel 层，反之亦然。</p>
<h3 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a></h3><p><img src="https://github.com/githubhaohao/ImageRoom/blob/master/Images/mvvm/kotlin-android-rxjava.png?raw=true" alt="RxJava"></p>
<blockquote>
<p>Rx 是微软 .Net 的一个响应式扩展，Rx 借助可观测的序列提供一种简单的方式来创建异步的，基于事件驱动的程序。2012 年 Netflix 为了应对不断增长的业务需求开始将 .NET Rx 迁移到 JVM 上面。并于 13 年二月份正式向外展示了 RxJava 。</p>
<p>从语义的角度来看， RxJava 就是 .NET Rx 。从语法的角度来看， Netflix 考虑到了对应每个 Rx 方法,保留了 Java 代码规范和基本的模式。</p>
</blockquote>
<p>RxJava 在 GitHub 主页的介绍是：</p>
<blockquote>
<p>RxJava is a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences.</p>
</blockquote>
<p>一个在 Java VM 上使用可观测的序列来组成异步的、基于事件程序的库。</p>
<p>RxJava 本质上是一个异步操作库，是一个能让你用极其简洁的逻辑去处理繁琐复杂任务的异步事件库。</p>
<p>简而言之，RxJava 可以用几个关键字概括：<strong>简洁，队列化，异步</strong>。</p>
<h3 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a><a href="https://github.com/square/retrofit" target="_blank" rel="external">Retrofit</a></h3><p><img src="https://github.com/githubhaohao/ImageRoom/blob/master/Images/mvvm/android-libs-retrofit-1-638.jpg?raw=true" alt="retrofit"></p>
<p>一个 Android 和 Java 上 HTTP 库（利用注解和 OKHttp 来实现和服务器的数据交互）。</p>
<p>Retrofit 基于 OKHttp 并引入注解，使用简单，易扩展，易维护。</p>
<blockquote>
<p><a href="http://square.github.io/retrofit/" target="_blank" rel="external"><strong>Retrofit 官方文档:http://square.github.io/retrofit/</strong></a></p>
</blockquote>
<h3 id="DataBinding"><a href="#DataBinding" class="headerlink" title="DataBinding"></a><a href="https://developer.android.com/topic/libraries/data-binding/index.html" target="_blank" rel="external">DataBinding</a></h3><p><img src="https://github.com/githubhaohao/ImageRoom/blob/master/Images/mvvm/data_binding.png?raw=true" alt="data-binding"></p>
<p>在Google IO 2015 中，Google 在 support-v7 中新增了 Data Binding，使用 Data Binding可以直接在布局的 xml 中绑定布局与数据，从而简化代码，Android Data Binding是Android 的 MVVM 框架。因为 Data Binding 是包含在 support-v7 包里面的，所以可以向下兼容到最低 Android 2.1 (API level 7+).</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>直接上代码。</p>
<h3 id="依赖的第三方类库"><a href="#依赖的第三方类库" class="headerlink" title="依赖的第三方类库"></a>依赖的第三方类库</h3><pre><code class="gradle">    compile &#39;io.reactivex:rxjava:1.1.0&#39;
    compile &#39;io.reactivex:rxandroid:1.1.0&#39;
    compile &#39;com.squareup.retrofit2:retrofit:2.0.0-beta4&#39;
    compile &#39;com.squareup.retrofit2:converter-gson:2.0.0-beta4&#39;
    compile &#39;com.squareup.retrofit2:adapter-rxjava:2.0.0-beta4&#39;
    compile &#39;com.github.bumptech.glide:glide:3.7.0&#39;
</code></pre>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><blockquote>
<p><code>https://api.douban.com/v2/movie/top250?start=0&amp;count=20</code></p>
</blockquote>
<h3 id="引入DataBinding"><a href="#引入DataBinding" class="headerlink" title="引入DataBinding"></a>引入DataBinding</h3><pre><code class="gradle">android {
    ......

    dataBinding {
        enabled = true
    }
}
</code></pre>
<h3 id="工程目录结构"><a href="#工程目录结构" class="headerlink" title="工程目录结构"></a>工程目录结构</h3><p><img src="https://github.com/githubhaohao/ImageRoom/blob/master/Images/mvvm/%E7%9B%AE%E5%BD%95.png?raw=true" alt="目录"></p>
<blockquote>
<p>详细源码：<a href="https://github.com/githubhaohao/MVVMRxJavaRetrofitSample" target="_blank" rel="external">https://github.com/githubhaohao/MVVMRxJavaRetrofitSample</a></p>
</blockquote>
<h3 id="MVVM-之-View"><a href="#MVVM-之-View" class="headerlink" title="MVVM 之 View"></a>MVVM 之 View</h3><p><strong>MainActivity.java</strong></p>
<pre><code class="java">getFragmentManager().beginTransaction().add(R.id.movie_fragment, MovieFragment.getInstance()).commit();
</code></pre>
<p><strong>MovieFragment.java</strong></p>
<pre><code class="java">public class MovieFragment extends Fragment implements CompletedListener,SwipeRefreshLayout.OnRefreshListener{

    private static String TAG = MovieFragment.class.getSimpleName();
    private MainViewModel viewModel;
    private MovieFragmentBinding movieFragmentBinding;
    private MovieAdapter movieAdapter;

    public static MovieFragment getInstance() {
        return new MovieFragment();
    }

    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View contentView = inflater.inflate(R.layout.movie_fragment, container, false);
        movieFragmentBinding = MovieFragmentBinding.bind(contentView);
        initData();
        return contentView;
    }

    private void initData() {
        movieAdapter = new MovieAdapter();
        movieFragmentBinding.recyclerView.setLayoutManager(new LinearLayoutManager(getActivity(), LinearLayoutManager.VERTICAL, false));
        movieFragmentBinding.recyclerView.setItemAnimator(new DefaultItemAnimator());
        movieFragmentBinding.recyclerView.setAdapter(movieAdapter);
        movieFragmentBinding.swipeRefreshLayout.setColorSchemeResources(R.color.colorAccent, R.color.colorPrimary, R.color.colorPrimaryDark);
        movieFragmentBinding.swipeRefreshLayout.setOnRefreshListener(this);
        viewModel = new MainViewModel(movieAdapter,this);
        movieFragmentBinding.setViewModel(viewModel);

    }

    @Override
    public void onRefresh() {
        movieAdapter.clearItems();
        viewModel.refreshData();
    }

    @Override
    public void onCompleted() {
        if (movieFragmentBinding.swipeRefreshLayout.isRefreshing()) {
            movieFragmentBinding.swipeRefreshLayout.setRefreshing(false);
        }
    }
}
</code></pre>
<p><strong>activity_main.xml</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:fitsSystemWindows=&quot;true&quot;
    tools:context=&quot;.view.MainActivity&quot;&gt;

    &lt;!-- ... --&gt;

    &lt;FrameLayout
        android:layout_marginTop=&quot;?attr/actionBarSize&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:id=&quot;@+id/movie_fragment&quot;/&gt;

    &lt;!-- ... --&gt;

&lt;/android.support.design.widget.CoordinatorLayout&gt;
</code></pre>
<p><strong>movie_fragment.xml</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;data&gt;
        &lt;variable
            name=&quot;viewModel&quot;
            type=&quot;com.jc.mvvmrxjavaretrofitsample.viewModel.MainViewModel&quot;/&gt;
    &lt;/data&gt;
    &lt;RelativeLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;
        &lt;android.support.v4.widget.SwipeRefreshLayout
            android:visibility=&quot;@{viewModel.contentViewVisibility}&quot;
            android:id=&quot;@+id/swipe_refresh_layout&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;&gt;

            &lt;android.support.v7.widget.RecyclerView
                android:id=&quot;@+id/recycler_view&quot;
                android:background=&quot;#ddd&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;match_parent&quot;
                android:padding=&quot;8dp&quot;&gt;
            &lt;/android.support.v7.widget.RecyclerView&gt;

        &lt;/android.support.v4.widget.SwipeRefreshLayout&gt;

        &lt;ProgressBar
            style=&quot;?android:attr/progressBarStyleLarge&quot;
            android:id=&quot;@+id/progress_bar&quot;
            android:visibility=&quot;@{viewModel.progressBarVisibility}&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_centerInParent=&quot;true&quot;/&gt;

        &lt;LinearLayout
            android:layout_width=&quot;match_parent&quot;
            android:id=&quot;@+id/error_info_layout&quot;
            android:visibility=&quot;@{viewModel.errorInfoLayoutVisibility}&quot;
            android:orientation=&quot;vertical&quot;
            android:layout_height=&quot;match_parent&quot;&gt;
            &lt;TextView
                android:layout_gravity=&quot;center&quot;
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;wrap_content&quot;
                android:text=&quot;@{viewModel.exception}&quot;/&gt;
        &lt;/LinearLayout&gt;
    &lt;/RelativeLayout&gt;
&lt;/layout&gt;
</code></pre>
<p><strong>movie_item.xml</strong></p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/tools&quot;&gt;
    &lt;data&gt;
        &lt;variable
            name=&quot;viewModel&quot;
            type=&quot;com.jc.mvvmrxjavaretrofitsample.viewModel.MovieViewModel&quot;/&gt;
    &lt;/data&gt;
    &lt;android.support.v7.widget.CardView
        xmlns:card_view=&quot;http://schemas.android.com/apk/res-auto&quot;
        android:id=&quot;@+id/card_view&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        card_view:cardCornerRadius=&quot;4dp&quot;
        card_view:cardBackgroundColor=&quot;@color/background&quot;
        card_view:cardUseCompatPadding=&quot;true&quot;&gt;
        &lt;LinearLayout
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:orientation=&quot;horizontal&quot;&gt;
            &lt;ImageView
                android:layout_margin=&quot;8dp&quot;
                android:layout_width=&quot;60dp&quot;
                android:layout_height=&quot;100dp&quot;
                android:src=&quot;@drawable/cover&quot;
                app:imageUrl=&quot;@{viewModel.imageUrl}&quot;
                android:id=&quot;@+id/cover&quot;/&gt;
            &lt;LinearLayout
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;match_parent&quot;
                android:layout_margin=&quot;8dp&quot;
                android:orientation=&quot;vertical&quot;&gt;
                &lt;TextView
                    android:textColor=&quot;@android:color/black&quot;
                    android:layout_width=&quot;wrap_content&quot;
                    android:layout_height=&quot;wrap_content&quot;
                    android:text=&quot;@{viewModel.title}&quot;
                    android:textSize=&quot;12sp&quot;/&gt;
                &lt;LinearLayout
                    android:layout_width=&quot;wrap_content&quot;
                    android:layout_height=&quot;wrap_content&quot;
                    android:layout_marginTop=&quot;4dp&quot;
                    android:orientation=&quot;horizontal&quot;&gt;
                    &lt;android.support.v7.widget.AppCompatRatingBar
                        android:id=&quot;@+id/ratingBar&quot;
                        style=&quot;?android:attr/ratingBarStyleSmall&quot;
                        android:layout_width=&quot;wrap_content&quot;
                        android:layout_height=&quot;wrap_content&quot;
                        android:layout_gravity=&quot;center_vertical&quot;
                        android:isIndicator=&quot;true&quot;
                        android:max=&quot;10&quot;
                        android:numStars=&quot;5&quot;
                        android:rating=&quot;@{viewModel.rating}&quot; /&gt;

                    &lt;TextView
                        android:id=&quot;@+id/rating_text&quot;
                        android:layout_width=&quot;wrap_content&quot;
                        android:layout_height=&quot;wrap_content&quot;
                        android:layout_gravity=&quot;center_vertical&quot;
                        android:layout_marginLeft=&quot;6dp&quot;
                        android:text=&quot;@{viewModel.ratingText}&quot;
                        android:textColor=&quot;?android:attr/textColorSecondary&quot;
                        android:textSize=&quot;10sp&quot; /&gt;

                &lt;/LinearLayout&gt;
                &lt;TextView
                    android:layout_width=&quot;wrap_content&quot;
                    android:layout_height=&quot;wrap_content&quot;
                    android:textColor=&quot;?android:attr/textColorSecondary&quot;
                    android:textSize=&quot;10sp&quot;
                    android:text=&quot;@{viewModel.movieType}&quot;
                    android:id=&quot;@+id/movie_type_text&quot;
                    android:layout_marginTop=&quot;6dp&quot;
                    /&gt;
                &lt;TextView
                    android:layout_width=&quot;wrap_content&quot;
                    android:layout_height=&quot;wrap_content&quot;
                    android:textColor=&quot;?android:attr/textColorSecondary&quot;
                    android:textSize=&quot;10sp&quot;
                    android:text=&quot;@{viewModel.year}&quot;
                    android:id=&quot;@+id/year_text&quot;
                    android:layout_marginTop=&quot;6dp&quot;
                    /&gt;
            &lt;/LinearLayout&gt;

        &lt;/LinearLayout&gt;

    &lt;/android.support.v7.widget.CardView&gt;
&lt;/layout&gt;
</code></pre>
<p><strong>MovieAdapter.java</strong></p>
<pre><code class="java">public class MovieAdapter extends RecyclerView.Adapter&lt;MovieAdapter.BindingHolder&gt; {
    private List&lt;Movie&gt; movies;

    public MovieAdapter() {
        movies = new ArrayList&lt;&gt;();
    }

    @Override
    public BindingHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        MovieItemBinding itemBinding = DataBindingUtil.inflate(LayoutInflater.from(parent.getContext()), R.layout.movie_item, parent, false);
        return new BindingHolder(itemBinding);
    }

    @Override
    public void onBindViewHolder(BindingHolder holder, int position) {
        MovieViewModel movieViewModel = new MovieViewModel(movies.get(position));
        holder.itemBinding.setViewModel(movieViewModel);
    }

    @Override
    public int getItemCount() {
        return movies.size();
    }

    public void addItem(Movie movie) {
        movies.add(movie);
        notifyItemInserted(movies.size() - 1);
    }

    public void clearItems() {
        movies.clear();
        notifyDataSetChanged();
    }

    public static class BindingHolder extends RecyclerView.ViewHolder {
        private MovieItemBinding itemBinding;

        public BindingHolder(MovieItemBinding itemBinding) {
            super(itemBinding.cardView);
            this.itemBinding = itemBinding;
        }
    }
}
</code></pre>
<p>回调接口<strong> CompletedListener.java</strong></p>
<pre><code class="java">public interface CompletedListener {
    void onCompleted();
}
</code></pre>
<h3 id="MVVM-之-ViewModel"><a href="#MVVM-之-ViewModel" class="headerlink" title="MVVM 之 ViewModel"></a>MVVM 之 ViewModel</h3><p><strong>MainViewModel.java</strong></p>
<pre><code class="java">public class MainViewModel {
    public ObservableField&lt;Integer&gt; contentViewVisibility;
    public ObservableField&lt;Integer&gt; progressBarVisibility;
    public ObservableField&lt;Integer&gt; errorInfoLayoutVisibility;
    public ObservableField&lt;String&gt; exception;
    private Subscriber&lt;Movie&gt; subscriber;
    private MovieAdapter movieAdapter;
    private CompletedListener completedListener;

    public MainViewModel(MovieAdapter movieAdapter,CompletedListener completedListener) {
        this.movieAdapter = movieAdapter;
        this.completedListener = completedListener;
        initData();
        getMovies();
    }

    private void getMovies() {
        subscriber = new Subscriber&lt;Movie&gt;() {
            @Override
            public void onCompleted() {
                Log.d(&quot;[MainViewModel]&quot;, &quot;onCompleted&quot;);
                hideAll();
                contentViewVisibility.set(View.VISIBLE);
                completedListener.onCompleted();
            }

            @Override
            public void onError(Throwable e) {
                hideAll();
                errorInfoLayoutVisibility.set(View.VISIBLE);
                exception.set(e.getMessage());
            }

            @Override
            public void onNext(Movie movie) {
                movieAdapter.addItem(movie);
            }
        };
        RetrofitHelper.getInstance().getMovies(subscriber, 0, 20);
    }

    public void refreshData() {
        getMovies();
    }

    private void initData() {
        contentViewVisibility = new ObservableField&lt;&gt;();
        progressBarVisibility = new ObservableField&lt;&gt;();
        errorInfoLayoutVisibility = new ObservableField&lt;&gt;();
        exception = new ObservableField&lt;&gt;();
        contentViewVisibility.set(View.GONE);
        errorInfoLayoutVisibility.set(View.GONE);
        progressBarVisibility.set(View.VISIBLE);
    }

    private void hideAll(){
        contentViewVisibility.set(View.GONE);
        errorInfoLayoutVisibility.set(View.GONE);
        progressBarVisibility.set(View.GONE);
    }
}
</code></pre>
<p><strong>MovieViewModel.java</strong></p>
<pre><code class="java">public class MovieViewModel extends BaseObservable {
    private Movie movie;

    public MovieViewModel(Movie movie) {
        this.movie = movie;
    }

    public String getCoverUrl() {
        return movie.getImages().getSmall();
    }

    public String getTitle() {
        return movie.getTitle();
    }

    public float getRating() {
        return movie.getRating().getAverage();
    }

    public String getRatingText(){
        return String.valueOf(movie.getRating().getAverage());
    }

    public String getYear() {
        return movie.getYear();
    }

    public String getMovieType() {
        StringBuilder builder = new StringBuilder();
        for (String s : movie.getGenres()) {
            builder.append(s + &quot; &quot;);
        }
        return builder.toString();
    }

    public String getImageUrl() {
        return movie.getImages().getSmall();
    }

    @BindingAdapter({&quot;app:imageUrl&quot;})
    public static void loadImage(ImageView imageView,String url) {
        Glide.with(imageView.getContext())
                .load(url)
                .placeholder(R.drawable.cover)
                .error(R.drawable.cover)
                .into(imageView);

    }
}
</code></pre>
<h3 id="MVVM-之-Model"><a href="#MVVM-之-Model" class="headerlink" title="MVVM 之 Model"></a>MVVM 之 Model</h3><p><strong>DouBanMovieService.java</strong></p>
<pre><code class="java">public interface DouBanMovieService {
    String BASE_URL = &quot;https://api.douban.com/v2/movie/&quot;;

    @GET(&quot;top250&quot;)
    Observable&lt;Response&lt;List&lt;Movie&gt;&gt;&gt; getMovies(@Query(&quot;start&quot;) int start, @Query(&quot;count&quot;) int count);
}
</code></pre>
<p><strong>RetrofitHelper.java</strong></p>
<pre><code class="java">public class RetrofitHelper {
    private static final int DEFAULT_TIMEOUT = 10;
    private Retrofit retrofit;
    private DouBanMovieService movieService;
    OkHttpClient.Builder builder;

    /**
     * 获取RetrofitHelper对象的单例
     * */
    private static class Singleton {
        private static final RetrofitHelper INSTANCE = new RetrofitHelper();
    }

    public static RetrofitHelper getInstance() {
        return Singleton.INSTANCE;
    }

    public RetrofitHelper() {
        builder = new OkHttpClient.Builder();
        builder.connectTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS);

        retrofit = new Retrofit.Builder()
                .client(builder.build())
                .addConverterFactory(GsonConverterFactory.create())
                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
                .baseUrl(DouBanMovieService.BASE_URL)
                .build();
        movieService = retrofit.create(DouBanMovieService.class);
    }

    public void getMovies(Subscriber&lt;Movie&gt; subscriber, int start, int count) {
        movieService.getMovies(start, count)
                .map(new Func1&lt;Response&lt;List&lt;Movie&gt;&gt;, List&lt;Movie&gt;&gt;() {
                    @Override
                    public List&lt;Movie&gt; call(Response&lt;List&lt;Movie&gt;&gt; listResponse) {
                        return listResponse.getSubjects();
                    }
                })
                .flatMap(new Func1&lt;List&lt;Movie&gt;, Observable&lt;Movie&gt;&gt;() {
                    @Override
                    public Observable&lt;Movie&gt; call(List&lt;Movie&gt; movies) {
                        return Observable.from(movies);
                    }
                })
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(subscriber);
    }
}
</code></pre>
<p>还有 entity 类，这里就不贴出来了。</p>
<blockquote>
<p>详细源码：<a href="https://github.com/githubhaohao/MVVMRxJavaRetrofitSample" target="_blank" rel="external">https://github.com/githubhaohao/MVVMRxJavaRetrofitSample</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/githubhaohao/ImageRoom/blob/master/Images/country-1295915__340.png?raw=true&quot; alt=&quot;Cover&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;cent
    
    </summary>
    
      <category term="Android" scheme="https://githubhaohao.github.io/categories/Android/"/>
    
    
      <category term="MVVM" scheme="https://githubhaohao.github.io/tags/MVVM/"/>
    
      <category term="MVP" scheme="https://githubhaohao.github.io/tags/MVP/"/>
    
      <category term="MVC" scheme="https://githubhaohao.github.io/tags/MVC/"/>
    
      <category term="RxJava" scheme="https://githubhaohao.github.io/tags/RxJava/"/>
    
      <category term="Retrofit" scheme="https://githubhaohao.github.io/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>ES6入门: 需要掌握的基本语法</title>
    <link href="https://githubhaohao.github.io/2017/01/25/ES6%E5%85%A5%E9%97%A8-%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>https://githubhaohao.github.io/2017/01/25/ES6入门-需要掌握的基本语法/</id>
    <published>2017-01-25T14:26:31.000Z</published>
    <updated>2017-05-13T08:14:36.658Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/githubhaohao/ImageRoom/blob/master/Images/es6.jpg?raw=true" alt="cover"></p>
<h2 id="ES6是什么"><a href="#ES6是什么" class="headerlink" title="ES6是什么"></a>ES6是什么</h2><h3 id="1-ES-ECMAScript-和JavaScript的关系"><a href="#1-ES-ECMAScript-和JavaScript的关系" class="headerlink" title="1. ES (ECMAScript) 和JavaScript的关系"></a>1. ES (ECMAScript) 和JavaScript的关系</h3><blockquote>
<p>ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现（另外的ECMAScript方言还有Jscript和ActionScript）。日常场合，这两个词是可以互换的。</p>
</blockquote>
<h3 id="2-ES6和ECMAScript-2015的关系"><a href="#2-ES6和ECMAScript-2015的关系" class="headerlink" title="2. ES6和ECMAScript 2015的关系"></a>2. ES6和ECMAScript 2015的关系</h3><p>ES6，一般是指ECMAScript 2015标准，但有时也表示一种泛指，是指JavaScript语言的下一代标准。涵盖了ECMAScript 2015，2016，2017等版本，而ECMAScript 2015则是正式名称，特指该年发布的正式版本的语言标准。</p>
<h2 id="Babel转码器"><a href="#Babel转码器" class="headerlink" title="Babel转码器"></a><a href="http://babeljs.io/docs/setup/" target="_blank" rel="external">Babel转码器</a></h2><p><img src="https://github.com/githubhaohao/TinkerSample/blob/master/image/babel.png?raw=true" alt=""></p>
<p>Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。去<a href="http://babeljs.io/docs/setup/" target="_blank" rel="external">官网</a>选择自己习惯的工具来使用使用Babel吧！</p>
<h2 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h2><p>let和const与var类似都是用来声明变量的，但又有各自不同的用途。let与var对比，看代码：</p>
<pre><code class="javascript">var name = &#39;haohao&#39;;

if(true){
  var name = &#39;jack&#39;;
  console.log(name)  //jack
}

console.log(name)  //jack
</code></pre>
<p>ES5只有全局作用域和块级作用域，导致内层变量覆盖外层变量，使得两次输出的都是<code>jack</code>。而let为JS新增了块级作用域，因此它声明的变量只在let命令所在的代码块有效，具体看代码：</p>
<pre><code class="javascript">let name = &#39;haohao&#39;;

if(true){
  let name = &#39;jack&#39;;
  console.log(name)  //jack
}

console.log(name)  //haohao
</code></pre>
<p>const用来声明常量，一旦声明就不能改变。当我们尝试改变const声明的常量时，浏览器就会报错。</p>
<pre><code class="javascript">const PI = Math.PI

PI = 23 //Module build failed: SyntaxError: /es6/app.js: &quot;PI&quot; is read-only
</code></pre>
<p>引用其他Module中声明的变量，用const来声明可以避免对其重命名而导致出现BUG。</p>
<pre><code class="javascript">const {width, height} = window.get(&#39;Dimension&#39;);
</code></pre>
<h2 id="解构-Destructuring"><a href="#解构-Destructuring" class="headerlink" title="解构 (Destructuring)"></a>解构 (Destructuring)</h2><p><strong>解构</strong> (Destructuring) 是指按照某种模式，从对象或数组中提取值对指定的变量进行赋值。</p>
<p>ES6之前为变量赋值：</p>
<pre><code class="javascript">let name = &#39;jack&#39;;
let addr = &#39;cn&#39;;
let sex = &#39;male&#39;;
</code></pre>
<p>ES6可以这样：</p>
<pre><code class="javascript">let [name,addr,sex] = [&#39;jack&#39;,&#39;cn&#39;,&#39;male&#39;];

name //jack
addr //cn
sex  //male
</code></pre>
<p>默认值:</p>
<pre><code class="javascript">let [name,addr,sex = &#39;male&#39;] = [&#39;jack&#39;,&#39;cn&#39;];

name //jack
addr //cn
sex  //male
</code></pre>
<p>关于对象以前这样：</p>
<pre><code class="javascript">let name = &#39;jack&#39;;
let addr = &#39;cn&#39;;
let sex = &#39;male&#39;;
let student = { name:name, addr:addr, sex:sex }
console.log(student);

//Object { name:&#39;jack&#39;, addr:&#39;cn&#39;, sex:&#39;male&#39; }
</code></pre>
<p>ES6可以这样：</p>
<pre><code class="javascript">let name = &#39;jack&#39;;
let addr = &#39;cn&#39;;
let sex = &#39;male&#39;;
let student = { name, addr, sex }
console.log(student);

//Object { name:&#39;jack&#39;, addr:&#39;cn&#39;, sex:&#39;male&#39; }
</code></pre>
<p>还有这样:</p>
<pre><code class="javascript">let student = { name:&#39;kene&#39;, addr:&#39;us&#39;, sex:&#39;male&#39; }
let { name, sex } = student;
let { addr } = student;
console.log(name, addr, sex);

//kene us male
</code></pre>
<h2 id="模板字符串-template-string"><a href="#模板字符串-template-string" class="headerlink" title="模板字符串 (template string)"></a>模板字符串 (template string)</h2><p>传统模板字符串：</p>
<pre><code class="javascript">$(&#39;#showId&#39;).append(
  &quot;Hello，everyone!&quot; +
  &quot;I am Jack.&quot;+
  &quot;I like eat &quot; + fruits + &quot;!&quot; 
);
</code></pre>
<p>ES6模板字符串：</p>
<pre><code class="javascript">$(&#39;#showId&#39;).append(`
  Hello，everyone!
  I am Jack.
  I like eat ${fruits}! 
`);
</code></pre>
<p>反引号标识起始，<code>${}</code>引入变量，所有的空格缩进保存输出。</p>
<h2 id="箭头函数-arrow-functions"><a href="#箭头函数-arrow-functions" class="headerlink" title="箭头函数 (arrow functions)"></a>箭头函数 (arrow functions)</h2><p>ES6允许使用“箭头”（=&gt;）定义函数。</p>
<pre><code class="javascript">var func = i =&gt; i + 1;
var func = (a, b) =&gt; {a++; b++; return a + b;}
</code></pre>
<p>上面的箭头函数等同于：</p>
<pre><code class="javascript">var func = function(i) {
  return i + 1;
};

var func = function(a, b) {
  a++;
  b++;
  return a + b;
}
</code></pre>
<p>当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。有一种使用场景：</p>
<pre><code class="javascript">class Person {
  constructor(){
    this.name = &#39;person&#39;;
  }
  sayHello(){
    setTimeout(function(){
      console.log(this.name + &#39;says hello.&#39;);
  });
  }
}

let p = new Person();
p.sayHello();

//undefined says hello.
</code></pre>
<p>运行上面的代码会报错，这是因为setTimeout中的this指向的是全局对象。有了箭头函数上述问题便可迎刃而解：</p>
<pre><code class="javascript">class Person {
  constructor(){
    this.name = &#39;person&#39;;
  }
  sayHello(){
    setTimeout(() =&gt; {
      console.log(this.name + &#39;says hello.&#39;);
  });
  }
}

let p = new Person();
p.sayHello();

//person says hello.
</code></pre>
<h2 id="类-Class"><a href="#类-Class" class="headerlink" title="类 (Class)"></a>类 (Class)</h2><p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。</p>
<pre><code class="javascript">class Person {
  constructor(){
    this.name = &#39;person&#39;;
  }
  sayHello(){
    setTimeout(() =&gt; {
      console.log(this.name + &#39;says hello.&#39;);
  });
  }
}

let p = new Person();
p.sayHello();

//person says hello.
</code></pre>
<p>上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。</p>
<p>ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>
<pre><code class="javascript">class Student extends Person {
  constructor(){
    super();
    this.name = &#39;student&#39;;
  }
}

let s = new Student();
s.sayHello();

//student says hello.
</code></pre>
<p>上面定义了一个Student类，该类通过extends关键字，继承了Person类的所有属性和方法。</p>
<p>子类Student必须在constructor方法中调用super方法，否则新建实例时会报错,子类就得不到this对象。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。</p>
<h2 id="export和import"><a href="#export和import" class="headerlink" title="export和import"></a>export和import</h2><p>ES6的模块化功能。<br>以前这样写：</p>
<pre><code class="javascript">//content.js
module.exports = &#39;apple&#39;;

//index.js
var fruits = require(&#39;./content.js&#39;);
console.log(fruits);

//apple
</code></pre>
<p>ES6这样：</p>
<pre><code class="javascript">//content.js
export default &#39;apple&#39;;

//index.js
import fruits from &#39;./content.js&#39;;
console.log(fruits);

//apple
</code></pre>
<p>深入点，看代码：</p>
<pre><code class="javascript">//content.js
export const KIND = &#39;Thailand Apple&#39;;

export default &#39;apple&#39;;

export function say(){
  return &#39;I like apple!&#39;;
} 

//index.js
import fruits, { say, KIND }  from &#39;./content.js&#39;;
//如果只导入say //import { say }  from &#39;./content.js&#39;;
console.log(fruits);
console.log(KIND);
say();

//apple 
//Thailand Apple
//I like apple!
</code></pre>
<p>修改变量名。</p>
<pre><code class="javascript">//content.js
export const KIND = &#39;Thailand Apple&#39;;

export default &#39;apple&#39;;

export function say(){
  return &#39;I like apple!&#39;;
} 

//index.js
import fruits, { say, KIND as type }  from &#39;./content.js&#39;;
console.log(fruits);
console.log(type);
say();

//apple 
//Thailand Apple
//I like apple!
</code></pre>
<p>整体加载,*为指定的一个对象。</p>
<pre><code class="javascript">//content.js
export const KIND = &#39;Thailand Apple&#39;;

export default &#39;apple&#39;;

export function say(){
  return &#39;I like apple!&#39;;
} 

//index.js
import fruits, * as content from &#39;./content.js&#39;;
console.log(fruits);
console.log(content.type);
content.say();

//apple 
//Thailand Apple
//I like apple!
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/githubhaohao/ImageRoom/blob/master/Images/es6.jpg?raw=true&quot; alt=&quot;cover&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;ES6是什么&quot;&gt;&lt;a href=&quot;#ES6是什
    
    </summary>
    
      <category term="ES6" scheme="https://githubhaohao.github.io/categories/ES6/"/>
    
    
      <category term="ES6入门" scheme="https://githubhaohao.github.io/tags/ES6%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>分分钟接入Tinker</title>
    <link href="https://githubhaohao.github.io/2017/01/18/%E5%88%86%E5%88%86%E9%92%9F%E6%8E%A5%E5%85%A5Tinker/"/>
    <id>https://githubhaohao.github.io/2017/01/18/分分钟接入Tinker/</id>
    <published>2017-01-18T01:23:38.000Z</published>
    <updated>2017-05-13T08:13:43.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tinker是什么"><a href="#Tinker是什么" class="headerlink" title="Tinker是什么"></a><a href="https://github.com/Tencent/tinker" target="_blank" rel="external">Tinker</a>是什么</h2><blockquote>
<p>Tinker是微信官方的Android热补丁解决方案，它支持动态下发代码、So库以及资源，让应用能够在不需要重新安装的情况下实现更新。当然，你也可以使用Tinker来更新你的插件。<br>它主要包括以下几个部分：</p>
<ul>
<li><p>1.gradle编译插件: tinker-patch-gradle-plugin</p>
</li>
<li><p>2.核心sdk库: tinker-android-lib</p>
</li>
<li><p>3.非gradle编译用户的命令行版本: tinker-patch-cli.jar</p>
</li>
</ul>
</blockquote>
<p><br><br><img src="https://github.com/Tencent/tinker/raw/master/assets/tinker.png" alt="Tinker"></p>
<h2 id="引入依赖和插件"><a href="#引入依赖和插件" class="headerlink" title="引入依赖和插件"></a>引入依赖和插件</h2><p>在你项目根目录下的 <code>build.gradle</code> 文件中添加:</p>
<pre><code class="gradle">buildscript {
    dependencies {
        classpath (&#39;com.tencent.tinker:tinker-patch-gradle-plugin:1.7.6&#39;)
    }
}
</code></pre>
<p>在 <code>app/build.gradle</code> 文件中添加依赖和插件：</p>
<pre><code class="gradle">dependencies {
    //optional, help to generate the final application 
    provided(&#39;com.tencent.tinker:tinker-android-anno:1.7.6&#39;)
    //tinker&#39;s main Android lib
    compile(&#39;com.tencent.tinker:tinker-android-lib:1.7.6&#39;) 
    compile &quot;com.android.support:multidex:1.0.1&quot;
}
...

...
apply plugin: &#39;com.tencent.tinker.patch&#39;
</code></pre>
<h2 id="添加task"><a href="#添加task" class="headerlink" title="添加task"></a>添加task</h2><p>添加task <code>tinkerPatch</code> 在 <code>app/build.gradle</code> 文件中,其中 <code>oldApk</code> 路径为出现BUG的APK路径（自定义），添加完之后Async Project。</p>
<pre><code class="gradle">tinkerPatch {

    oldApk = &quot;J://tinkerSample/app-debug.apk&quot;
    ignoreWarning = true
    useSign = true
    buildConfig {
        applyMapping = null
        applyResourceMapping = null
        tinkerId = &quot;tinkerId&quot;
    }

    dex {
        dexMode = &quot;jar&quot;
        usePreGeneratedPatchDex = false
        pattern = [&quot;classes*.dex&quot;,
                   &quot;assets/secondary-dex-?.jar&quot;]
        loader = [&quot;com.tencent.tinker.loader.*&quot;,
                  &quot;com.jc.tinkersample.SimpleApp&quot;,
                  &quot;com.jc.tinkersample.BaseBuildInfo&quot;
        ]
    }

    lib {
        pattern = [&quot;lib/armeabi/*.so&quot;]
    }

    res {
        pattern = [&quot;res/*&quot;, &quot;assets/*&quot;, &quot;resources.arsc&quot;, &quot;AndroidManifest.xml&quot;]
        ignoreChange = [&quot;assets/sample_meta.txt&quot;]
        largeModSize = 100
    }

    packageConfig {
        configField(&quot;patchMessage&quot;, &quot;tinker is sample to use&quot;)
        configField(&quot;platform&quot;, &quot;all&quot;)
        configField(&quot;patchVersion&quot;, &quot;1.0&quot;)
    }

    sevenZip {
        zipArtifact = &quot;com.tencent.mm:SevenZip:1.1.10&quot;
    }
}
</code></pre>
<h2 id="接入Tinker"><a href="#接入Tinker" class="headerlink" title="接入Tinker"></a>接入Tinker</h2><p>自定义Application继承 <code>DefaultApplicationLike</code> 类，也可以<a href="https://github.com/Tencent/tinker/wiki/Tinker-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%A9%E5%B1%95" target="_blank" rel="external">自定义扩展</a>。</p>
<pre><code class="java">@DefaultLifeCycle(
        application = &quot;com.jc.tinkersample.SimpleApp&quot;,
        flags = ShareConstants.TINKER_ENABLE_ALL,
        loadVerifyFlag = false
)
public class SimpleAppLike extends DefaultApplicationLike {
    public SimpleAppLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag, long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent, Resources[] resources, ClassLoader[] classLoader, AssetManager[] assetManager) {
        super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent, resources, classLoader, assetManager);
    }

    @Override
    public void onBaseContextAttached(Context base) {
        super.onBaseContextAttached(base);
        MultiDex.install(base);
        TinkerInstaller.install(this);
    }

    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH)
    public void registerActivityLifecycleCallbacks(Application.ActivityLifecycleCallbacks callback) {
        getApplication().registerActivityLifecycleCallbacks(callback);
    }
}
</code></pre>
<p>运行安装到你的手机里，然后把 <code>app-debug.apk</code> 放到 <code>oldApk</code> 对应的路径下，用于生成 <code>patch.apk</code>。</p>
<p><img src="https://github.com/githubhaohao/TinkerSample/raw/master/image/app_debug.png" alt="app_debug"></p>
<p>然后，修复你项目的bug（这里只是象征性地修改了一下Text），打开Android Studio 右侧的gradle project 运行 <code>tinkerPatchDebug</code> task生成<code>patch.apk</code>。</p>
<p><img src="https://github.com/githubhaohao/TinkerSample/blob/master/image/terminal.png?raw=true" alt="command"></p>
<p><img src="https://github.com/githubhaohao/TinkerSample/blob/master/image/tinker_task.png?raw=true" alt="tinker_task"></p>
<p>找到<code>patch_signed_7zip.apk</code> 文件。</p>
<p><img src="https://github.com/githubhaohao/TinkerSample/blob/master/image/signed_apk.png?raw=true" alt="new_apk"></p>
<p>复制 <code>patch_signed_7zip.apk</code> 文件把它放到手机外部存储目录下 （这里为根目录）。 </p>
<pre><code class="java">        String path = Environment.getExternalStorageDirectory().getAbsolutePath() + &quot;/patch_signed_7zip.apk&quot;;
        File file = new File(path);
        if (file.exists()){
            Toast.makeText(this, &quot;patch.apk is existing.&quot;, Toast.LENGTH_SHORT).show();
            TinkerInstaller.onReceiveUpgradePatch(getApplicationContext(), path);
        }else{
            Toast.makeText(this,&quot;patch.apk is inexistent.&quot;, Toast.LENGTH_SHORT).show();
        }
</code></pre>
<p>调用Tinker API <code>TinkerInstaller.onReceiveUpgradePatch(getApplicationContext(), path);</code> 进行热修复，重启app热修复完成。</p>
<p>详细代码<a href="https://github.com/githubhaohao/TinkerSample" target="_blank" rel="external">https://github.com/githubhaohao/TinkerSample</a></p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><ol>
<li><a href="https://github.com/WeMobileDev/article/blob/master/%E5%BE%AE%E4%BF%A1Android%E7%83%AD%E8%A1%A5%E4%B8%81%E5%AE%9E%E8%B7%B5%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF.md" target="_blank" rel="external">微信Android热补丁实践演进之路</a></li>
<li><a href="https://github.com/WeMobileDev/article/blob/master/Android_N%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91%E4%B8%8E%E5%AF%B9%E7%83%AD%E8%A1%A5%E4%B8%81%E5%BD%B1%E5%93%8D%E8%A7%A3%E6%9E%90.md" target="_blank" rel="external">Android N混合编译与对热补丁影响深度解析</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286384&amp;idx=1&amp;sn=f1aff31d6a567674759be476bcd12549&amp;scene=4#wechat_redirect" target="_blank" rel="external">微信Tinker的一切都在这里，包括源码</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Tinker是什么&quot;&gt;&lt;a href=&quot;#Tinker是什么&quot; class=&quot;headerlink&quot; title=&quot;Tinker是什么&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/Tencent/tinker&quot; target=&quot;_blank&quot;
    
    </summary>
    
      <category term="Android" scheme="https://githubhaohao.github.io/categories/Android/"/>
    
    
      <category term="Tinker" scheme="https://githubhaohao.github.io/tags/Tinker/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://githubhaohao.github.io/2017/01/12/cover/"/>
    <id>https://githubhaohao.github.io/2017/01/12/cover/</id>
    <published>2017-01-12T08:31:23.971Z</published>
    <updated>2017-05-13T08:12:39.171Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。</p>
</blockquote>
<p><div align="center"><br><img src="https://avatars0.githubusercontent.com/u/17926884?v=3&s=460" width="100" height="100" alt="logo"><br></div></p>
<p align="center"><i>不忘初心，不惧未来。<i><br><br><b>haohao</b><br><br>2017/01/14<br></i></i></p>

]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://avatars0.githubusercontent.com
    
    </summary>
    
    
  </entry>
  
</feed>
