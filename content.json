{"meta":{"title":"haohao","subtitle":"不忘初心","description":"不忘初心","author":"haohao","url":"https://githubhaohao.github.io"},"pages":[{"title":"","date":"2017-01-20T03:02:23.125Z","updated":"2017-01-20T03:02:12.387Z","comments":true,"path":"baidu_verify_mlJIN34eq8.html","permalink":"https://githubhaohao.github.io/baidu_verify_mlJIN34eq8.html","excerpt":"","text":"mlJIN34eq8"},{"title":"","date":"2017-01-14T01:08:49.684Z","updated":"2017-01-14T01:08:49.684Z","comments":true,"path":"404.html","permalink":"https://githubhaohao.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2017-01-20T02:12:03.265Z","updated":"2017-01-20T02:11:46.875Z","comments":true,"path":"googlea9fee49d9b41dd58.html","permalink":"https://githubhaohao.github.io/googlea9fee49d9b41dd58.html","excerpt":"","text":"google-site-verification: googlea9fee49d9b41dd58.html"},{"title":"About","date":"2017-01-13T08:40:55.000Z","updated":"2017-01-14T02:04:19.512Z","comments":false,"path":"about/index.html","permalink":"https://githubhaohao.github.io/about/index.html","excerpt":"","text":"阳光温热，岁月静好。 haohao 不忘初心，不惧未来。"},{"title":"Tags","date":"2017-01-13T09:53:21.000Z","updated":"2017-01-14T01:53:27.154Z","comments":false,"path":"tags/index.html","permalink":"https://githubhaohao.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-01-13T09:50:33.000Z","updated":"2017-01-14T01:18:01.407Z","comments":false,"path":"categories/index.html","permalink":"https://githubhaohao.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-05-15T01:46:02.511Z","updated":"2017-05-15T01:46:02.511Z","comments":true,"path":"me/css/style.css","permalink":"https://githubhaohao.github.io/me/css/style.css","excerpt":"","text":"/* Project: Hello World Personal Page Project URI: http://timpotter.github.io Author: Tim Potter Author URI: http://littlethunder.co */ /* Reset Browser Defaults*/ * { padding:0; margin: 0; } *, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; } /* Typography */ body { font-family: \"Helvetica Neue\", Arial, sans-serif; font-weight: 300; color: #444; -webkit-font-smoothing: antialiased; } header { text-align: center; text-transform: uppercase; } header p { letter-spacing: 2px; font-weight: 300; } h1 { font-weight: 100; font-size: 3em; /* 48/16 */ margin-bottom: 40px; line-height: 1em; } p { line-height: 1.75em; } .about p:nth-of-type(1) { font-size: 1.5em; /* 24/16 */ line-height: 1.5em; text-align: center; } .about p { padding-bottom: 20px; text-align: justify; font-style: bold; } footer p { text-align: center; font-size: 0.625em; /* 10/16 */ } small { text-align: center; } strong { font-weight: 400; } a { text-decoration: none; font-weight: 400; color: #333; } a:hover { text-decoration: underline; color: #666; } .social a { opacity: 0.3; transition: opacity .25s ease-in-out; -moz-transition: opacity .25s ease-in-out; -webkit-transition: opacity .25s ease-in-out; } .social a:hover { opacity: 0.8; } .social li { display: inline; margin: 5px; color: #444; } /* Images */ .background { /* Delete background class from for a vanilla style */ background: url(../images/background.jpg) top center no-repeat; } img.avatar { margin-bottom: 30px; border-radius: 50%; width: 125px; height: 125px; margin-top: -30px; } .social li img { width: 50px; } /* Layout */ .container { width: 600px; margin: 100px auto 25px; background-color: rgba(255, 255, 255, 0.5); padding: 0 60px 30px; border-radius: 6px; } .social { margin-top: 60px; text-align: center; } footer { margin-top: 30px; } /* Responsive Styles */ @media only screen and (min-width: 1920px) { .background { background-size: 100%; } } @media only screen and (max-width: 600px) { .container { width: 90%; margin-top: 50px; padding: 0 30px 30px; } h1 { font-size: 2.25em; /* 36/16 */ margin-bottom: 20px; } .social { margin-top: 20px; } .about p { text-align: left; padding-bottom: 15px; } .about p:nth-of-type(1) { font-size: 1.25em; /* 20/16 */ text-align: center; } }"}],"posts":[{"title":"Android 设计模式之外观模式","slug":"Android-设计模式之外观模式","date":"2017-05-15T02:05:07.000Z","updated":"2017-05-15T03:18:15.488Z","comments":false,"path":"2017/05/15/Android-设计模式之外观模式/","link":"","permalink":"https://githubhaohao.github.io/2017/05/15/Android-设计模式之外观模式/","excerpt":"","text":"打造个人品牌是现代职业规划的趋势 在当下互联网革命的时代，有这样一种说法，如果一个人到三十岁以后还是只有工资收入，那么它的职业规划是失败的。本文是 Android 设计模式的第三篇，接下来会陆续推出整个常用的设计模式系列。 外观模式外观模式 (Facade Pattern) ，又名门面模式，归类为对象结构型模式，外部对象与一个子系统通信必须通过一个统一的外观对象进行。 模式结构 Client 外部对象 Facade 外观对象 SubSystem 子系统对象 盗图 模式实现 电视遥控器是现实生活中一个比较好的外观模式的运用，遥控器可以控制电源 (Power) 的电源、声音 (Voice) 的调整、频道 (Channel) 的切换等。这个遥控器就是我们这里说的外观或者门面，而电源、声音、频道切换系统就是我们的子系统。 PowerSystempublic class PowerSystem { public void powerOn() { System.out.println(&quot;power on&quot;); } public void powerOff() { System.out.println(&quot;power off&quot;); } } VoiceSystempublic class VoiceSystem { public void turnUp() { System.out.println(&quot;voice increasing&quot;); } public void turnDown() { System.out.println(&quot;voice reducing&quot;); } } ChannelSystempublic class ChannelSystem { public void next() { System.out.println(&quot;next channel&quot;); } public void prev() { System.out.println(&quot;prev channel&quot;); } } Facadepublic class Facade { private PowerSystem mPowerSystem = new PowerSystem(); private VoiceSystem mVoiceSystem = new VoiceSystem(); private ChannelSystem mChannelSystem = new ChannelSystem(); public void powerOn() { mPowerSystem.powerOn(); } public void powerOff() { mPowerSystem.powerOff(); } public void turnUp() { mVoiceSystem.turnUp(); } public void turnDown() { mVoiceSystem.turnDown(); } public void nextChannel() { mChannelSystem.next(); } public void prevChannel() { mChannelSystem.prev(); } } Clientpublic static void main (String[] args) { Facade facade = new Facade(); facade.powerOn(); facade.turnUp(); facade.nextChannel(); } Running power on voice increasing next channel Android 中的实现在 Activity 中可以进行很多重要的操作，如 startService() ，startActivity() ，sendBroadcast() ，bindService() 以及获取 System Service 。Activity 就可以简单地看作一个门面，但是这些工作实际上并不是 Activity 来实现的，而是委托 Activity 父类 ContextThemeWrapper 中的 mBase 对象，mBase 对象的实现类是 ContextImpl 。 看一下源码： class ContextImpl extends Context { private final static String TAG = &quot;ApplicationContext&quot;; private final static boolean DEBUG = false; private final static boolean DEBUG_ICONS = false; private static final Object sSync = new Object(); private static AlarmManager sAlarmManager; private static PowerManager sPowerManager; private static ConnectivityManager sConnectivityManager; private AudioManager mAudioManager; LoadedApk mPackageInfo; private Resources mResources; private PackageManager mPackageManager; private NotificationManager mNotificationManager = null; private ActivityManager mActivityManager = null; ... @Override public boolean bindService(Intent service, ServiceConnection conn, int flags) { warnIfCallingFromSystemProcess(); return bindServiceCommon(service, conn, flags, mMainThread.getHandler(), Process.myUserHandle()); } @Override public Object getSystemService(String name) { return SystemServiceRegistry.getSystemService(this, name); } @Override public String getSystemServiceName(Class&lt;?&gt; serviceClass) { return SystemServiceRegistry.getSystemServiceName(serviceClass); } @Override public void sendBroadcast(Intent intent) { String resolvedType = intent.resolveTypeIfNeeded(getContentResolver()); try { ActivityManagerNative.getDefault().broadcastIntent( mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, false, false); } catch (RemoteException e) { } } @Override public void startActivity(Intent intent) { if ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == 0) { throw new AndroidRuntimeException( &quot;Calling startActivity() from outside of an Activity &quot; + &quot; context requires the FLAG_ACTIVITY_NEW_TASK flag.&quot; + &quot; Is this really what you want?&quot;); } mMainThread.getInstrumentation().execStartActivity( getOuterContext(), mMainThread.getApplicationThread(), null, null, intent, -1); } @Override public ComponentName startService(Intent service) { try { ComponentName cn = ActivityManagerNative.getDefault().startService( mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(getContentResolver())); if (cn != null &amp;&amp; cn.getPackageName().equals(&quot;!&quot;)) { throw new SecurityException( &quot;Not allowed to start service &quot; + service + &quot; without permission &quot; + cn.getClassName()); } return cn; } catch (RemoteException e) { return null; } } @Override public String getPackageName() { if (mPackageInfo != null) { return mPackageInfo.getPackageName(); } throw new RuntimeException(&quot;Not supported in system context&quot;); } ... } ContextImpl 内部有很多 Manager 类的对象，也就是也就是子系统对象。 ContextImpl 内部封装了一些系统级别的操作以及提供了一些访问系统的接口，我们在开发过程中可以很方便地利用其访问子系统。 外观模式的优点与缺点优点 屏蔽了子系统内部细节，使子系统的使用更见便利 减少客户端所持对象的数目，降低了客户端与子系统的耦合度缺点 增加新的子系统可能需要修改外观类，违背了“开闭原则” 参考 https://github.com/simple-android-framework/android_design_patterns_analysis/tree/master/facade/elsdnwn","categories":[{"name":"Android","slug":"Android","permalink":"https://githubhaohao.github.io/categories/Android/"},{"name":"设计模式","slug":"Android/设计模式","permalink":"https://githubhaohao.github.io/categories/Android/设计模式/"}],"tags":[{"name":"外观模式","slug":"外观模式","permalink":"https://githubhaohao.github.io/tags/外观模式/"}]},{"title":"Android 设计模式之 Builder 模式","slug":"Android-设计模式之-Builder-模式","date":"2017-05-13T05:28:00.000Z","updated":"2017-05-13T08:56:06.815Z","comments":false,"path":"2017/05/13/Android-设计模式之-Builder-模式/","link":"","permalink":"https://githubhaohao.github.io/2017/05/13/Android-设计模式之-Builder-模式/","excerpt":"","text":"平坦的路往往只能带你到平凡的地方 最近在研究 Clean 和 Unidirectional （ Android Flux ）架构，回头放一个大招。本文是 Android 设计模式的第二篇，接下来会陆续推出整个常用的设计模式系列。 Builder 模式Builder 又名生成器模式，或建造（者）模式。它是一种对象构建模式，用于抽象复杂对象的构建过程，构造过程的不同实现方法可以构建出具有不同表示的对象。 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 模式结构 Product 产品，表示被构造的复杂对象。 Builder 抽象构建者，为创建一个 Product 对象的各个部件指定抽象方法（接口方法）。 ConcreteBuilder 具体构建者，实现 Builder 接口（抽象类）以及各个抽象方法。 Director 指挥者，构建实现（继承） Builder 接口（抽象类）的对象。 盗图 模式实现我们以生产手机为例，当我们拿到一个手机产品通常比较关注它的品牌 (Brand) ，CPU 核心数目 (CPU Core)，运行内存 (RAM) 以及操作系统 (OS)。 Productpublic class Phone { private int mCPUCore = 1; private int mRam = 1; private String mOS = &quot;Android&quot;; private String mBrand = &quot;Google&quot;; public int getCPUCore() { return mCPUCore; } public int getRAM() { return mRam; } public String getOS() { return mOS; } public String getBrand() { return mBrand; } public void setCPUCore(int mCPUCore) { this.mCPUCore = mCPUCore; } public void setRAM(int mRam) { this.mRam = mRam; } public void setOS(String mOS) { this.mOS = mOS; } public void setBrand(String mBrand) { this.mBrand = mBrand; } @Override public String toString() { return &quot;Brand : &quot; + getBrand() +&quot;, CPUCore : &quot; + getCPUCore() + &quot;, RAM : &quot; + getRAM() + &quot;, OS : &quot; + getOS(); } } Builder 抽象类 public abstract class PhoneBuilder { protected Phone mPhone; public void createPhone() { mPhone = new Phone(); } public Phone getPhone() { return mPhone; } public abstract void buildPhoneCpu(); public abstract void buildPhoneRam(); public abstract void buildPhoneOS(); } ConcreteBuilderXiaoMiPhoneBuilder public class XiaoMiPhoneBuilder extends PhoneBuilder { public XiaoMiPhoneBuilder() { createPhone(); mPhone.setBrand(&quot;XiaoMi&quot;); } @Override public void buildPhoneCpu() { mPhone.setCPUCore(4); } @Override public void buildPhoneRam() { mPhone.setRAM(4); } @Override public void buildPhoneOS() { mPhone.setOS(&quot;MIUI Android&quot;); } } GooglePhoneBuilder public class GooglePhoneBuilder extends PhoneBuilder { public GooglePhoneBuilder() { createPhone(); mPhone.setBrand(&quot;Google&quot;); } @Override public void buildPhoneCpu() { mPhone.setCPUCore(8); } @Override public void buildPhoneRam() { mPhone.setRAM(6); } @Override public void buildPhoneOS() { mPhone.setOS(&quot;Android&quot;); } } Directorpublic class PhoneDirector { private PhoneBuilder mPhoneBuilder; public PhoneDirector setPhoneBuilder(PhoneBuilder phoneBuilder) { this.mPhoneBuilder = phoneBuilder; return this; } public Phone getPhone() { return mPhoneBuilder.getPhone(); } public PhoneDirector constructPhone() { mPhoneBuilder.buildPhoneCpu(); mPhoneBuilder.buildPhoneOS(); mPhoneBuilder.buildPhoneRam(); return this; } } Samplepublic class BuilderSample { public static void main(String[] args) { PhoneDirector phoneDirector = new PhoneDirector(); PhoneBuilder xiaomiphoneBuilder = new XiaoMiPhoneBuilder(); PhoneBuilder googlePhoneBuilder = new GooglePhoneBuilder(); Phone xiaoMiPhone = phoneDirector.setPhoneBuilder(xiaomiphoneBuilder) .constructPhone() .getPhone(); Phone googlePhone = phoneDirector.setPhoneBuilder(googlePhoneBuilder) .constructPhone() .getPhone(); System.out.println(xiaoMiPhone + &quot;\\n&quot; + googlePhone); } } Running Brand : XiaoMi, CPUCore : 4, RAM : 4, OS : MIUI Android Brand : Google, CPUCore : 8, RAM : 6, OS : Android Android 中的实现在 Android 开发中我们最常用到的实现 Builder 的类是 AlertDialog.Builder ，Builder 是AlertDialog 的静态内部类。基本用法如下： AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setIcon(R.drawable.icon); builder.setTitle(&quot;Title&quot;); builder.setMessage(&quot;Message&quot;); builder.setPositiveButton(&quot;OK&quot;, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int whichButton) { setTitle(&quot;点击了对话框上的 OK 按钮&quot;); } }); builder.setNeutralButton(&quot;Nothing&quot;, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int whichButton) { setTitle(&quot;点击了对话框上的 Nothing 按钮&quot;); } }); builder.setNegativeButton(&quot;Cancel&quot;, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int whichButton) { setTitle(&quot;点击了对话框上的 Cancel 按钮&quot;); } }); builder.create().show(); 我们看一下简化后的 AlertDialog 源码： public class AlertDialog extends Dialog implements DialogInterface { // Controller, 接受 Builder 成员变量P中的各个参数 private AlertController mAlert; // 构造函数 protected AlertDialog(Context context, int theme) { this(context, theme, true); } // 构造 AlertDialog AlertDialog(Context context, int theme, boolean createContextWrapper) { super(context, resolveDialogTheme(context, theme), createContextWrapper); mWindow.alwaysReadCloseOnTouchAttr(); mAlert = new AlertController(getContext(), this, getWindow()); } @Override public void setTitle(CharSequence title) { super.setTitle(title); mAlert.setTitle(title); } public void setCustomTitle(View customTitleView) { mAlert.setCustomTitle(customTitleView); } public void setMessage(CharSequence message) { mAlert.setMessage(message); } // Builder内部类 public static class Builder { // 存储 AlertDialog 的各个参数, 例如 title ， message ， icon 等. private final AlertController.AlertParams P; public Builder(Context context) { this(context, resolveDialogTheme(context, 0)); } public Builder(Context context, int theme) { P = new AlertController.AlertParams(new ContextThemeWrapper( context, resolveDialogTheme(context, theme))); mTheme = theme; } ...... public Builder setTitle(CharSequence title) { P.mTitle = title; return this; } public Builder setMessage(CharSequence message) { P.mMessage = message; return this; } public Builder setIcon(int iconId) { P.mIconId = iconId; return this; } public Builder setPositiveButton(CharSequence text, final OnClickListener listener) { P.mPositiveButtonText = text; P.mPositiveButtonListener = listener; return this; } public Builder setView(View view) { P.mView = view; P.mViewSpacingSpecified = false; return this; } // 构建 AlertDialog, 传递参数 public AlertDialog create() { final AlertDialog dialog = new AlertDialog(P.mContext, mTheme, false); 将P中的参数应用的dialog中的mAlert对象中 P.apply(dialog.mAlert); dialog.setCancelable(P.mCancelable); if (P.mCancelable) { dialog.setCanceledOnTouchOutside(true); } dialog.setOnCancelListener(P.mOnCancelListener); if (P.mOnKeyListener != null) { dialog.setOnKeyListener(P.mOnKeyListener); } return dialog; } } } 从源码中可以看到 AlertDialog.Builder 同时扮演了 Builder ， ConcreteBuilder 以及 Director 三个角色，是 Builder 模式的简化版。 我们从 AlertDialog 的构建和使用中，可以体会到运用 Builder 模式带来的简介性和高度的可定制性。 Builder 模式的优点和缺点优点 使用简单，可扩展性强，封装良好； 高度的可定制性，构造过程可精细化控制。 缺点 Builder 模式只适用于构建过程复杂的同一类 Product ，此外要考虑多余 Builder 和 Director 对象对内存的占用。","categories":[{"name":"Android","slug":"Android","permalink":"https://githubhaohao.github.io/categories/Android/"},{"name":"设计模式","slug":"Android/设计模式","permalink":"https://githubhaohao.github.io/categories/Android/设计模式/"}],"tags":[{"name":"Builder 模式","slug":"Builder-模式","permalink":"https://githubhaohao.github.io/tags/Builder-模式/"}]},{"title":"Android 设计模式之单例模式","slug":"Android-设计模式之单例模式","date":"2017-05-06T05:53:52.000Z","updated":"2017-05-13T08:09:15.382Z","comments":false,"path":"2017/05/06/Android-设计模式之单例模式/","link":"","permalink":"https://githubhaohao.github.io/2017/05/06/Android-设计模式之单例模式/","excerpt":"","text":"时刻尝试走出舒适区 最近在培养自己的广泛阅读习惯，感觉阅读中最重要的是动脑思考，阅读是接受讯息，思考是消化讯息。本文是 Android 设计模式的开篇，接下来会陆续推出整个常用的设计模式系列。 设计模式设计模式简而言之就是优秀的代码设计经验的总结。设计模式的产生是为了提高代码的可复用性，可扩展性，可靠性以及可读性。 设计模式原则 单一职责原则: 一个类只负责一项职责; 里氏替换原则: 子类可以扩展父类的功能，但不能改变父类原有的功能; 依赖倒置原则: 面向接口编程，将依赖对象的共同特征抽象成接口； 接口隔离原则: 一个类不应该实现它不需要的接口方法，即建立单一接口，细化接口，尽量减少接口中的方法; 迪米特法则: 一个对象应该对其他对象保持最少的了解，即降低类与类之间的耦合； 开闭原则: 一个类对扩展开放，对修改关闭。 设计模式分类创建型设计模式设计对象的实例化，避免用户用 new 运算符创建对象。例如单例模式，Builder 模式，原型模式等。 行为型设计模式设计对象之间的通信交互。如观察者模式，迭代器模式，责任链模式等。 结构型设计模式设计如何组合类和对象以形成更大的结构。如适配器模式，代理模式，桥接模式等。 单例模式简单介绍常用的五种单例模式的写法。 饿汉式单例public class Person { private static final INSTANCE = new Person(); private Person(){ } public static Person getInstance() { return INSTANCE; } } 优点：线程安全。缺点：类加载的时候就进行初始化，对于初始化逻辑复杂的类，会导致类加载变慢。 (DCL) 懒汉式单例public class Person { private static volatile sInstance = new Person(); private Person(){ } public static Person getInstance() { if (sInstance == null){ synchronized (Person.class) { if (sInstance == null) { sInstance = new Person(); } } } return sInstance; } } 优点：volatile 声明单例引用，可以防止并发时初始化成员变量和对象实例化顺序可能会被打乱，双重校验锁定解决了多余的同步问题。缺点：并发时存在极小的概率导致 DCL 失效，据说是百万分之一。 静态内部类单例public class Person { private Person(){ } private static class Singleton { private static final Person INSTANCE = new Person(); } public static Person getInstance() { return Singleton.INSTANCE; } } 优点：充分结合了懒汉式单例与饿汉式的优点，同时有效避开了它们的缺点，充分保证线程安全。推荐缺点：会有的！ 枚举型单例public enum PersonEnum { INSTANCE; private PersonEnum() { } public void fun() { // do something } } 使用方法： PersonEnum.INSTANCE.fun(); 优点：简洁，线程安全。《Effective Java》的作者在书中是这样夸枚举型单例： 这种写法在功能上与共有域方法相近，但是它更简洁，无偿地提供了序列化机制，绝对防止对此实例化，即使是在面对复杂的序列化或者反射攻击的时候。虽然这中方法还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。 缺点：Google 官方强烈建议尽量不要使用 enum ，它会增加额外的内存占用，同时增加可执行文件 .dex 的大小，也不适用继承场景。 容器型单例public class Person { public Person () { } } public class SingletonManager { public static final KEY_SINGLETON = &quot;singleton&quot;; private static Map&lt;String, Object&gt; sInstanceMap = new HashMap&lt;&gt;(); public static void registerSingleton(String key, Object obj) { if (!sInstanceMap.containsKey(key)) { sInstanceMap.put(key, obj); } } public static Person getSingleton(String key) { return (Person) sInstanceMap.get(key); } } 使用： SingletonManager.registerSingleton(KEY_SINGLETON, new Person); Person person = SingletonManager.getSingleton(); 优点：可以将不同单例注册到一个容器中统一管理，隐藏了类的具体实现，降低了耦合度。推荐缺点：会有的！ 单例模式的优点与缺点优点：减少内存开销，避免资源重用。缺点：单例类的扩展性很差，持有外部引用时，非常容易造成内存泄漏。","categories":[{"name":"Android","slug":"Android","permalink":"https://githubhaohao.github.io/categories/Android/"},{"name":"设计模式","slug":"Android/设计模式","permalink":"https://githubhaohao.github.io/categories/Android/设计模式/"}],"tags":[{"name":"单例模式","slug":"单例模式","permalink":"https://githubhaohao.github.io/tags/单例模式/"}]},{"title":"Android 进程间通信方式","slug":"Android-进程间通信方式","date":"2017-04-27T11:05:29.000Z","updated":"2017-05-06T09:13:23.781Z","comments":true,"path":"2017/04/27/Android-进程间通信方式/","link":"","permalink":"https://githubhaohao.github.io/2017/04/27/Android-进程间通信方式/","excerpt":"","text":"做好眼前的事，保持专注 我们的大脑是串行结构，而非并行结构，你永远无法真正将自己的注意力同时放在两个任务之中。 Android 中的 IPC 方式使用 Intent Activity，Service，Receiver 都支持在 Intent 中传递 Bundle 数据，而 Bundle 实现了 Parcelable 接口，可以在不同的进程间进行传输。 在一个进程中启动了另一个进程的 Acyivity，Service 和 Receiver ，可以在 Bundle 中附加要传递的数据通过 Intent 发送出去。 使用文件共享 Windows 上，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读和写；而 Android 系统基于 Linux ，使得其并发读取文件没有限制地进行，甚至允许两个线程同时对一个文件进行读写操作，尽管这样可能会出问题。 可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（注意：并不是同一个对象，只是内容相同。）。 SharedPreferences 是个特例，系统对它的读 / 写有一定的缓存策略，即内存中会有一份 ShardPreferences 文件的缓存，系统对他的读 / 写就变得不可靠，当面对高并发的读写访问，SharedPreferences 有很多大的几率丢失数据。因此，IPC 不建议采用 SharedPreferences。 使用 MessengerMessenger 是一种轻量级的 IPC 方案，它的底层实现是 AIDL ，可以在不同进程中传递 Message 对象，它一次只处理一个请求，在服务端不需要考虑线程同步的问题，服务端不存在并发执行的情形。 服务端进程：服务端创建一个 Service 来处理客户端请求，同时通过一个 Handler 对象来实例化一个 Messenger 对象，然后在 Service 的 onBind 中返回这个 Messenger 对象底层的 Binder 即可。 public class MessengerService extends Service { private static final String TAG = MessengerService.class.getSimpleName(); private class MessengerHandler extends Handler { /** * @param msg */ @Override public void handleMessage(Message msg) { switch (msg.what) { case Constants.MSG_FROM_CLIENT: Log.d(TAG, &quot;receive msg from client: msg = [&quot; + msg.getData().getString(Constants.MSG_KEY) + &quot;]&quot;); Toast.makeText(MessengerService.this, &quot;receive msg from client: msg = [&quot; + msg.getData().getString(Constants.MSG_KEY) + &quot;]&quot;, Toast.LENGTH_SHORT).show(); Messenger client = msg.replyTo; Message replyMsg = Message.obtain(null, Constants.MSG_FROM_SERVICE); Bundle bundle = new Bundle(); bundle.putString(Constants.MSG_KEY, &quot;我已经收到你的消息，稍后回复你！&quot;); replyMsg.setData(bundle); try { client.send(replyMsg); } catch (RemoteException e) { e.printStackTrace(); } break; default: super.handleMessage(msg); } } } private Messenger mMessenger = new Messenger(new MessengerHandler()); @Nullable @Override public IBinder onBind(Intent intent) { return mMessenger.getBinder(); } } 客户端进程：首先绑定服务端 Service ，绑定成功之后用服务端的 IBinder 对象创建一个 Messenger ，通过这个 Messenger 就可以向服务端发送消息了，消息类型是 Message 。如果需要服务端响应，则需要创建一个 Handler 并通过它来创建一个 Messenger（和服务端一样），并通过 Message 的 replyTo 参数传递给服务端。服务端通过 Message 的 replyTo 参数就可以回应客户端了。 public class MainActivity extends AppCompatActivity { private static final String TAG = MainActivity.class.getSimpleName(); private Messenger mGetReplyMessenger = new Messenger(new MessageHandler()); private Messenger mService; private class MessageHandler extends Handler { @Override public void handleMessage(Message msg) { switch (msg.what) { case Constants.MSG_FROM_SERVICE: Log.d(TAG, &quot;received msg form service: msg = [&quot; + msg.getData().getString(Constants.MSG_KEY) + &quot;]&quot;); Toast.makeText(MainActivity.this, &quot;received msg form service: msg = [&quot; + msg.getData().getString(Constants.MSG_KEY) + &quot;]&quot;, Toast.LENGTH_SHORT).show(); break; default: super.handleMessage(msg); } } } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } public void bindService(View v) { Intent mIntent = new Intent(this, MessengerService.class); bindService(mIntent, mServiceConnection, Context.BIND_AUTO_CREATE); } public void sendMessage(View v) { Message msg = Message.obtain(null,Constants.MSG_FROM_CLIENT); Bundle data = new Bundle(); data.putString(Constants.MSG_KEY, &quot;Hello! This is client.&quot;); msg.setData(data); msg.replyTo = mGetReplyMessenger; try { mService.send(msg); } catch (RemoteException e) { e.printStackTrace(); } } @Override protected void onDestroy() { unbindService(mServiceConnection); super.onDestroy(); } private ServiceConnection mServiceConnection = new ServiceConnection() { /** * @param name * @param service */ @Override public void onServiceConnected(ComponentName name, IBinder service) { mService = new Messenger(service); Message msg = Message.obtain(null,Constants.MSG_FROM_CLIENT); Bundle data = new Bundle(); data.putString(Constants.MSG_KEY, &quot;Hello! This is client.&quot;); msg.setData(data); // msg.replyTo = mGetReplyMessenger; try { mService.send(msg); } catch (RemoteException e) { e.printStackTrace(); } } /** * @param name */ @Override public void onServiceDisconnected(ComponentName name) { } }; } 注意：客户端和服务端是通过拿到对方的 Messenger 来发送 Message 的。只不过客户端通过 bindService onServiceConnected 而服务端通过 message.replyTo 来获得对方的 Messenger 。Messenger 中有一个 Hanlder 以串行的方式处理队列中的消息。不存在并发执行，因此我们不用考虑线程同步的问题。 图片来自《Android 开发艺术探索》 使用 AIDLMessenger 是以串行的方式处理客户端发来的消息，如果大量消息同时发送到服务端，服务端只能一个一个处理，所以大量并发请求就不适合用 Messenger ，而且 Messenger 只适合传递消息，不能跨进程调用服务端的方法。AIDL 可以解决并发和跨进程调用方法的问题，要知道 Messenger 本质上也是 AIDL ，只不过系统做了封装方便上层的调用而已。 AIDL 文件支持的数据类型 基本数据类型； String 和 CharSequence ArrayList ，里面的元素必须能够被 AIDL 支持； HashMap ，里面的元素必须能够被 AIDL 支持； Parcelable ，实现 Parcelable 接口的对象；注意：如果 AIDL 文件中用到了自定义的 Parcelable 对象，必须新建一个和它同名的 AIDL 文件。 AIDL ，AIDL 接口本身也可以在 AIDL 文件中使用。 服务端服务端创建一个 Service 用来监听客户端的连接请求，然后创建一个 AIDL 文件，将暴露给客户端的接口在这个 AIDL 文件中声明，最后在 Service 中实现这个 AIDL 接口即可。 客户端绑定服务端的 Service ，绑定成功后，将服务端返回的 Binder 对象转成 AIDL 接口所属的类型，然后就可以调用 AIDL 中的方法了。客户端调用远程服务的方法，被调用的方法运行在服务端的 Binder 线程池中，同时客户端的线程会被挂起，如果服务端方法执行比较耗时，就会导致客户端线程长时间阻塞，导致 ANR 。客户端的 onServiceConnected 和 onServiceDisconnected 方法都在 UI 线程中。 服务端访问权限管理 使用 Permission 验证，在 manifest 中声明 &lt;permission android:name=&quot;com.jc.ipc.ACCESS_BOOK_SERVICE&quot; android:protectionLevel=&quot;normal&quot;/&gt; &lt;uses-permission android:name=&quot;com.jc.ipc.ACCESS_BOOK_SERVICE&quot;/&gt; 服务端 onBinder 方法中 public IBinder onBind(Intent intent) { //Permission 权限验证 int check = checkCallingOrSelfPermission(&quot;com.jc.ipc.ACCESS_BOOK_SERVICE&quot;); if (check == PackageManager.PERMISSION_DENIED) { return null; } return mBinder; } Pid Uid 验证 详细代码： // Book.aidl package com.jc.ipc.aidl; parcelable Book; // IBookManager.aidl package com.jc.ipc.aidl; import com.jc.ipc.aidl.Book; import com.jc.ipc.aidl.INewBookArrivedListener; // AIDL 接口中只支持方法，不支持静态常量，区别于传统的接口 interface IBookManager { List&lt;Book&gt; getBookList(); // AIDL 中除了基本数据类型，其他数据类型必须标上方向,in,out 或者 inout // in 表示输入型参数 // out 表示输出型参数 // inout 表示输入输出型参数 void addBook(in Book book); void registerListener(INewBookArrivedListener listener); void unregisterListener(INewBookArrivedListener listener); } // INewBookArrivedListener.aidl package com.jc.ipc.aidl; import com.jc.ipc.aidl.Book; // 提醒客户端新书到来 interface INewBookArrivedListener { void onNewBookArrived(in Book newBook); } public class BookManagerActivity extends AppCompatActivity { private static final String TAG = BookManagerActivity.class.getSimpleName(); private static final int MSG_NEW_BOOK_ARRIVED = 0x10; private Button getBookListBtn,addBookBtn; private TextView displayTextView; private IBookManager bookManager; private Handler mHandler = new Handler(){ @Override public void handleMessage(Message msg) { switch (msg.what) { case MSG_NEW_BOOK_ARRIVED: Log.d(TAG, &quot;handleMessage: new book arrived &quot; + msg.obj); Toast.makeText(BookManagerActivity.this, &quot;new book arrived &quot; + msg.obj, Toast.LENGTH_SHORT).show(); break; default: super.handleMessage(msg); } } }; private ServiceConnection mServiceConn = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { bookManager = IBookManager.Stub.asInterface(service); try { bookManager.registerListener(listener); } catch (RemoteException e) { e.printStackTrace(); } } @Override public void onServiceDisconnected(ComponentName name) { } }; private INewBookArrivedListener listener = new INewBookArrivedListener.Stub() { @Override public void onNewBookArrived(Book newBook) throws RemoteException { mHandler.obtainMessage(MSG_NEW_BOOK_ARRIVED, newBook).sendToTarget(); } }; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.book_manager); displayTextView = (TextView) findViewById(R.id.displayTextView); Intent intent = new Intent(this, BookManagerService.class); bindService(intent, mServiceConn, BIND_AUTO_CREATE); } public void getBookList(View view) { try { List&lt;Book&gt; list = bookManager.getBookList(); Log.d(TAG, &quot;getBookList: &quot; + list.toString()); displayTextView.setText(list.toString()); } catch (RemoteException e) { e.printStackTrace(); } } public void addBook(View view) { try { bookManager.addBook(new Book(3, &quot;天龙八部&quot;)); } catch (RemoteException e) { e.printStackTrace(); } } @Override protected void onDestroy() { if (bookManager != null &amp;&amp; bookManager.asBinder().isBinderAlive()) { Log.d(TAG, &quot;unregister listener &quot; + listener); try { bookManager.unregisterListener(listener); } catch (RemoteException e) { e.printStackTrace(); } } unbindService(mServiceConn); super.onDestroy(); } } public class BookManagerService extends Service { private static final String TAG = BookManagerService.class.getSimpleName(); // CopyOnWriteArrayList 支持并发读写，实现自动线程同步，他不是继承自 ArrayList private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;Book&gt;(); //对象是不能跨进程传输的，对象的跨进程传输本质都是反序列化的过程，Binder 会把客户端传递过来的对象重新转化生成一个新的对象 //RemoteCallbackList 是系统专门提供的用于删除系统跨进程 listener 的接口，利用底层的 Binder 对象是同一个 //RemoteCallbackList 会在客户端进程终止后，自动溢出客户端注册的 listener ，内部自动实现了线程同步功能。 private RemoteCallbackList&lt;INewBookArrivedListener&gt; mListeners = new RemoteCallbackList&lt;&gt;(); private AtomicBoolean isServiceDestroied = new AtomicBoolean(false); private Binder mBinder = new IBookManager.Stub() { @Override public List&lt;Book&gt; getBookList() throws RemoteException { return mBookList; } @Override public void addBook(Book book) throws RemoteException { Log.d(TAG, &quot;addBook: &quot; + book.toString()); mBookList.add(book); } @Override public void registerListener(INewBookArrivedListener listener) throws RemoteException { mListeners.register(listener); } @Override public void unregisterListener(INewBookArrivedListener listener) throws RemoteException { mListeners.unregister(listener); } }; @Override public void onCreate() { super.onCreate(); mBookList.add(new Book(1, &quot;老人与海&quot;)); mBookList.add(new Book(2, &quot;哈姆雷特&quot;)); new Thread(new ServiceWorker()).start(); } private void onNewBookArrived(Book book) throws RemoteException { mBookList.add(book); int count = mListeners.beginBroadcast(); for (int i = 0; i &lt; count; i++) { INewBookArrivedListener listener = mListeners.getBroadcastItem(i); if (listener != null) { listener.onNewBookArrived(book); } } mListeners.finishBroadcast(); } private class ServiceWorker implements Runnable { @Override public void run() { while (!isServiceDestroied.get()) { try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } int bookId = mBookList.size() +1; Book newBook = new Book(bookId, &quot;new book # &quot; + bookId); try { onNewBookArrived(newBook); } catch (RemoteException e) { e.printStackTrace(); } } } } @Nullable @Override public IBinder onBind(Intent intent) { //Permission 权限验证 int check = checkCallingOrSelfPermission(&quot;com.jc.ipc.ACCESS_BOOK_SERVICE&quot;); if (check == PackageManager.PERMISSION_DENIED) { return null; } return mBinder; } @Override public void onDestroy() { isServiceDestroied.set(true); super.onDestroy(); } } 使用 ContentProvider用于不同应用间数据共享，和 Messenger 底层实现同样是 Binder 和 AIDL，系统做了封装，使用简单。系统预置了许多 ContentProvider ，如通讯录、日程表，需要跨进程访问。使用方法：继承 ContentProvider 类实现 6 个抽象方法，这六个方法均运行在 ContentProvider 进程中，除 onCreate 运行在主线程里，其他五个方法均由外界回调运行在 Binder 线程池中。 ContentProvider 的底层数据，可以是 SQLite 数据库，可以是文件，也可以是内存中的数据。 详见代码： public class BookProvider extends ContentProvider { private static final String TAG = &quot;BookProvider&quot;; public static final String AUTHORITY = &quot;com.jc.ipc.Book.Provider&quot;; public static final Uri BOOK_CONTENT_URI = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/book&quot;); public static final Uri USER_CONTENT_URI = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/user&quot;); public static final int BOOK_URI_CODE = 0; public static final int USER_URI_CODE = 1; private static final UriMatcher sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH); static { sUriMatcher.addURI(AUTHORITY, &quot;book&quot;, BOOK_URI_CODE); sUriMatcher.addURI(AUTHORITY, &quot;user&quot;, USER_URI_CODE); } private Context mContext; private SQLiteDatabase mDB; @Override public boolean onCreate() { mContext = getContext(); initProviderData(); return true; } private void initProviderData() { //不建议在 UI 线程中执行耗时操作 mDB = new DBOpenHelper(mContext).getWritableDatabase(); mDB.execSQL(&quot;delete from &quot; + DBOpenHelper.BOOK_TABLE_NAME); mDB.execSQL(&quot;delete from &quot; + DBOpenHelper.USER_TABLE_NAME); mDB.execSQL(&quot;insert into book values(3,&#39;Android&#39;);&quot;); mDB.execSQL(&quot;insert into book values(4,&#39;iOS&#39;);&quot;); mDB.execSQL(&quot;insert into book values(5,&#39;Html5&#39;);&quot;); mDB.execSQL(&quot;insert into user values(1,&#39;haohao&#39;,1);&quot;); mDB.execSQL(&quot;insert into user values(2,&#39;nannan&#39;,0);&quot;); } @Nullable @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { Log.d(TAG, &quot;query, current thread&quot;+ Thread.currentThread()); String table = getTableName(uri); if (table == null) { throw new IllegalArgumentException(&quot;Unsupported URI&quot; + uri); } return mDB.query(table, projection, selection, selectionArgs, null, null, sortOrder, null); } @Nullable @Override public String getType(Uri uri) { Log.d(TAG, &quot;getType&quot;); return null; } @Nullable @Override public Uri insert(Uri uri, ContentValues values) { Log.d(TAG, &quot;insert&quot;); String table = getTableName(uri); if (table == null) { throw new IllegalArgumentException(&quot;Unsupported URI&quot; + uri); } mDB.insert(table, null, values); // 通知外界 ContentProvider 中的数据发生变化 mContext.getContentResolver().notifyChange(uri, null); return uri; } @Override public int delete(Uri uri, String selection, String[] selectionArgs) { Log.d(TAG, &quot;delete&quot;); String table = getTableName(uri); if (table == null) { throw new IllegalArgumentException(&quot;Unsupported URI&quot; + uri); } int count = mDB.delete(table, selection, selectionArgs); if (count &gt; 0) { mContext.getContentResolver().notifyChange(uri, null); } return count; } @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) { Log.d(TAG, &quot;update&quot;); String table = getTableName(uri); if (table == null) { throw new IllegalArgumentException(&quot;Unsupported URI&quot; + uri); } int row = mDB.update(table, values, selection, selectionArgs); if (row &gt; 0) { getContext().getContentResolver().notifyChange(uri, null); } return row; } private String getTableName(Uri uri) { String tableName = null; switch (sUriMatcher.match(uri)) { case BOOK_URI_CODE: tableName = DBOpenHelper.BOOK_TABLE_NAME; break; case USER_URI_CODE: tableName = DBOpenHelper.USER_TABLE_NAME; break; default: break; } return tableName; } } public class DBOpenHelper extends SQLiteOpenHelper { private static final String DB_NAME = &quot;book_provider.db&quot;; public static final String BOOK_TABLE_NAME = &quot;book&quot;; public static final String USER_TABLE_NAME = &quot;user&quot;; private static final int DB_VERSION = 1; private String CREATE_BOOK_TABLE = &quot;CREATE TABLE IF NOT EXISTS &quot; + BOOK_TABLE_NAME + &quot;(_id INTEGER PRIMARY KEY,&quot; + &quot;name TEXT)&quot;; private String CREATE_USER_TABLE = &quot;CREATE TABLE IF NOT EXISTS &quot; + USER_TABLE_NAME + &quot;(_id INTEGER PRIMARY KEY,&quot; + &quot;name TEXT,&quot; + &quot;sex INT)&quot;; public DBOpenHelper(Context context) { super(context, DB_NAME, null, DB_VERSION); } @Override public void onCreate(SQLiteDatabase db) { db.execSQL(CREATE_BOOK_TABLE); db.execSQL(CREATE_USER_TABLE); } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { } } public class ProviderActivity extends AppCompatActivity { private static final String TAG = ProviderActivity.class.getSimpleName(); private TextView displayTextView; private Handler mHandler; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_provider); displayTextView = (TextView) findViewById(R.id.displayTextView); mHandler = new Handler(); getContentResolver().registerContentObserver(BookProvider.BOOK_CONTENT_URI, true, new ContentObserver(mHandler) { @Override public boolean deliverSelfNotifications() { return super.deliverSelfNotifications(); } @Override public void onChange(boolean selfChange) { super.onChange(selfChange); } @Override public void onChange(boolean selfChange, Uri uri) { Toast.makeText(ProviderActivity.this, uri.toString(), Toast.LENGTH_SHORT).show(); super.onChange(selfChange, uri); } }); } public void insert(View v) { ContentValues values = new ContentValues(); values.put(&quot;_id&quot;,1123); values.put(&quot;name&quot;, &quot;三国演义&quot;); getContentResolver().insert(BookProvider.BOOK_CONTENT_URI, values); } public void delete(View v) { getContentResolver().delete(BookProvider.BOOK_CONTENT_URI, &quot;_id = 4&quot;, null); } public void update(View v) { ContentValues values = new ContentValues(); values.put(&quot;_id&quot;,1123); values.put(&quot;name&quot;, &quot;三国演义新版&quot;); getContentResolver().update(BookProvider.BOOK_CONTENT_URI, values , &quot;_id = 1123&quot;, null); } public void query(View v) { Cursor bookCursor = getContentResolver().query(BookProvider.BOOK_CONTENT_URI, new String[]{&quot;_id&quot;, &quot;name&quot;}, null, null, null); StringBuilder sb = new StringBuilder(); while (bookCursor.moveToNext()) { Book book = new Book(bookCursor.getInt(0),bookCursor.getString(1)); sb.append(book.toString()).append(&quot;\\n&quot;); } sb.append(&quot;--------------------------------&quot;).append(&quot;\\n&quot;); bookCursor.close(); Cursor userCursor = getContentResolver().query(BookProvider.USER_CONTENT_URI, new String[]{&quot;_id&quot;, &quot;name&quot;, &quot;sex&quot;}, null, null, null); while (userCursor.moveToNext()) { sb.append(userCursor.getInt(0)) .append(userCursor.getString(1)).append(&quot; ,&quot;) .append(userCursor.getInt(2)).append(&quot; ,&quot;) .append(&quot;\\n&quot;); } sb.append(&quot;--------------------------------&quot;); userCursor.close(); displayTextView.setText(sb.toString()); } } 使用 Socket Socket起源于 Unix，而 Unix 基本哲学之一就是“一切皆文件”，都可以用“打开 open –读写 write/read –关闭 close ”模式来操作。Socket 就是该模式的一个实现，网络的 Socket 数据传输是一种特殊的 I/O，Socket 也是一种文件描述符。Socket 也具有一个类似于打开文件的函数调用： Socket()，该函数返回一个整型的Socket 描述符，随后的连接建立、数据传输等操作都是通过该 Socket 实现的。 常用的 Socket 类型有两种：流式 Socket（SOCK_STREAM）和数据报式 Socket（SOCK_DGRAM）。流式是一种面向连接的 Socket，针对于面向连接的 TCP 服务应用；数据报式 Socket 是一种无连接的 Socket ，对应于无连接的 UDP 服务应用。 Socket 本身可以传输任意字节流。 谈到Socket，就必须要说一说 TCP/IP 五层网络模型： 应用层：规定应用程序的数据格式，主要的协议 HTTP，FTP，WebSocket，POP3 等； 传输层：建立“端口到端口” 的通信，主要的协议：TCP，UDP； 网络层：建立”主机到主机”的通信，主要的协议：IP，ARP ，IP 协议的主要作用：一个是为每一台计算机分配 IP 地址，另一个是确定哪些地址在同一子网； 数据链路层：确定电信号的分组方式，主要的协议：以太网协议； 物理层：负责电信号的传输。 Socket 是连接应用层与传输层之间接口（API）。 图片来自网络 只实现 TCP Socket 。Client 端代码： public class TCPClientActivity extends AppCompatActivity implements View.OnClickListener{ private static final String TAG = &quot;TCPClientActivity&quot;; public static final int MSG_RECEIVED = 0x10; public static final int MSG_READY = 0x11; private EditText editText; private TextView textView; private PrintWriter mPrintWriter; private Socket mClientSocket; private Button sendBtn; private StringBuilder stringBuilder; private Handler mHandler = new Handler(){ @Override public void handleMessage(Message msg) { switch (msg.what) { case MSG_READY: sendBtn.setEnabled(true); break; case MSG_RECEIVED: stringBuilder.append(msg.obj).append(&quot;\\n&quot;); textView.setText(stringBuilder.toString()); break; default: super.handleMessage(msg); } } }; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.tcp_client_activity); editText = (EditText) findViewById(R.id.editText); textView = (TextView) findViewById(R.id.displayTextView); sendBtn = (Button) findViewById(R.id.sendBtn); sendBtn.setOnClickListener(this); sendBtn.setEnabled(false); stringBuilder = new StringBuilder(); Intent intent = new Intent(TCPClientActivity.this, TCPServerService.class); startService(intent); new Thread(){ @Override public void run() { connectTcpServer(); } }.start(); } private String formatDateTime(long time) { return new SimpleDateFormat(&quot;(HH:mm:ss)&quot;).format(new Date(time)); } private void connectTcpServer() { Socket socket = null; while (socket == null) { try { socket = new Socket(&quot;localhost&quot;, 8888); mClientSocket = socket; mPrintWriter = new PrintWriter(new BufferedWriter( new OutputStreamWriter(socket.getOutputStream()) ), true); mHandler.sendEmptyMessage(MSG_READY); } catch (IOException e) { e.printStackTrace(); } } // receive message BufferedReader bufferedReader = null; try { bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); } catch (IOException e) { e.printStackTrace(); } while (!isFinishing()) { try { String msg = bufferedReader.readLine(); if (msg != null) { String time = formatDateTime(System.currentTimeMillis()); String showedMsg = &quot;server &quot; + time + &quot;:&quot; + msg + &quot;\\n&quot;; mHandler.obtainMessage(MSG_RECEIVED, showedMsg).sendToTarget(); } } catch (IOException e) { e.printStackTrace(); } } } @Override public void onClick(View v) { if (mPrintWriter != null) { String msg = editText.getText().toString(); mPrintWriter.println(msg); editText.setText(&quot;&quot;); String time = formatDateTime(System.currentTimeMillis()); String showedMsg = &quot;self &quot; + time + &quot;:&quot; + msg + &quot;\\n&quot;; stringBuilder.append(showedMsg); } } @Override protected void onDestroy() { if (mClientSocket != null) { try { mClientSocket.shutdownInput(); mClientSocket.close(); } catch (IOException e) { e.printStackTrace(); } } super.onDestroy(); } } Server 端代码： public class TCPServerService extends Service { private static final String TAG = &quot;TCPServerService&quot;; private boolean isServiceDestroyed = false; private String[] mMessages = new String[]{ &quot;Hello! Body!&quot;, &quot;用户不在线！请稍后再联系！&quot;, &quot;请问你叫什么名字呀？&quot;, &quot;厉害了，我的哥！&quot;, &quot;Google 不需要科学上网是真的吗？&quot;, &quot;扎心了，老铁！！！&quot; }; @Override public void onCreate() { new Thread(new TCPServer()).start(); super.onCreate(); } @Override public void onDestroy() { isServiceDestroyed = true; super.onDestroy(); } @Nullable @Override public IBinder onBind(Intent intent) { return null; } private class TCPServer implements Runnable { @Override public void run() { ServerSocket serverSocket = null; try { serverSocket = new ServerSocket(8888); } catch (IOException e) { e.printStackTrace(); return; } while (!isServiceDestroyed) { // receive request from client try { final Socket client = serverSocket.accept(); Log.d(TAG, &quot;=============== accept ==================&quot;); new Thread(){ @Override public void run() { try { responseClient(client); } catch (IOException e) { e.printStackTrace(); } } }.start(); } catch (IOException e) { e.printStackTrace(); } } } } private void responseClient(Socket client) throws IOException { //receive message BufferedReader in = new BufferedReader( new InputStreamReader(client.getInputStream())); //send message PrintWriter out = new PrintWriter( new BufferedWriter( new OutputStreamWriter( client.getOutputStream())),true); out.println(&quot;欢迎来到聊天室！&quot;); while (!isServiceDestroyed) { String str = in.readLine(); Log.d(TAG, &quot;message from client: &quot; + str); if (str == null) { return; } Random random = new Random(); int index = random.nextInt(mMessages.length); String msg = mMessages[index]; out.println(msg); Log.d(TAG, &quot;send Message: &quot; + msg); } out.close(); in.close(); client.close(); } } 演示： UDP Socket 可以自己尝试着实现。","categories":[{"name":"Android","slug":"Android","permalink":"https://githubhaohao.github.io/categories/Android/"},{"name":"进程","slug":"Android/进程","permalink":"https://githubhaohao.github.io/categories/Android/进程/"}],"tags":[{"name":"IPC","slug":"IPC","permalink":"https://githubhaohao.github.io/tags/IPC/"}]},{"title":"Android 多线程实现方式","slug":"Android-多线程实现方式","date":"2017-04-22T08:04:55.000Z","updated":"2017-05-11T12:54:31.208Z","comments":true,"path":"2017/04/22/Android-多线程实现方式/","link":"","permalink":"https://githubhaohao.github.io/2017/04/22/Android-多线程实现方式/","excerpt":"","text":"只为初心 一个优秀的程序员，必须具备两种能力： 学习能力 时间管理能力 Android 多线程实现方式通常来说，一个应用至少有一个进程，而一个进程至少有一个线程。线程是 CPU 调度的基本单位，进程是系统资源分配的基本单位。进程独享内存资源，一个进程可以看作一个 JVM ，一个进程崩溃后，在保护模式下一般不会对其它进程产生影响。同一个进程中的线程共享内存资源，一个线程死掉就导致整个进程死掉。行了，进程和线程就扯嫩忙多。Android 提供了四种常用的多线程实现方式： AsyncTask 异步消息机制 IntentService ThreadPoolExcutor AsyncTask我们的老朋友 AsyncTask 类，它是封装好的线程池，操作 UI 线程极其方便。 瞅一眼，AsyncTask 的三个泛型参数： public abstract class AsyncTask&lt;Params, Progress, Result&gt; params ，传入参数类型，即 doInBackground() 方法中的参数类型; Progress ，异步任务执行过程中返回的任务执行进度类型，即 publishProgress() 和onProgressUpdate() 方法中传入的参数类型； Result ，异步任务执行完返回的结果类型，即 doInBackground() 方法中返回值的类型。 四个回调方法： onPreExecute()，在主线程执行，做一些准备工作。 doInBackground()，在线程池中执行，该方法是抽象方法，在此方法中可以调用 publishProgress() 更新任务进度。 onProgressUpdate()，在主线程中执行，在 publishProgress() 调用之后被回调，展示任务进度。 onPostExecute()，在主线程中执行，异步任务结束后，回调此方法，处理返回结果。 注意： 当 AsyncTask 任务被取消时，回调 onCanceled(obj) ，此时 onPostExecute()，不会被调用，AsyncTask 中的 cancel() 方法并不是真正去取消任务，只是设置这个任务为取消状态，需要在 doInBackground() 中通过 isCancelled() 判断终止任务。 AsyncTask 必须在主线程中创建实例，execute() 方法也必须在主线程中调用。 每个 AsyncTask 实例只能执行一次 execute() ，多次执行会报错，如需执行多次，则需创建多个实例。 Android 3.0 之后， AsyncTask 对象默认执行多任务是串行执行，即 mAsyncTask.execute() ，并发执行的话需要使用 executeOnExecutor() 。 AsyncTask 用的是线程池机制和异步消息机制（基于 ThreadPoolExecutor 和 Handler ）。Android 2.3 以前，AsyncTask 线程池容量是 128 ，全局线程池只有 5 个工作线程，如果运用 AsyncTask 对象来执行多个并发异步任务，那么同一时间最多只能有 5 个线程同时运行，其他线程将被阻塞。Android 3.0 之后 Google 又进行了调整，新增接口 executeOnExecutor() ，允许自定义线程池（那么核心线程数以及线程容量也可自定义），并提供了 SERIAL_EXECUTOR 和 THREAD_POOL_EXECUTOR 预定义线程池。后来 Google 又做了一些调整（任何事物都不完美），将线程池的容量与 CPU 的核心数联系起来，如目前 SDK 25 版本中，预定义的核心线程数量最少有 2 个，最多 4 个，线程池容量范围 5 ~ 9 。改动如下： private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors(); private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4)); private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1; private static final int KEEP_ALIVE_SECONDS = 30; 异步消息机制异步消息机制的三大主角： Handler ，Message 和 Looper 。Looper 负责创建 MessageQueue 消息对列，然后进入一个无限 for 循环中，不断地从消息队列中取消息，如果消息队列为空，当前线程阻塞，Handler 负责向消息队列中发送消息。 LooperLooper 有两个重要的方法： prepare() 和 loop()。 prepare() ， Looper 与当前线程绑定，一个线程只能有一个 Looper 实例和一个 MessageQueue 实例。 public static final void prepare() { if (sThreadLocal.get() != null) { throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); } sThreadLocal.set(new Looper(true)); 保证 Looper 对象在当前线程唯一 } // Looper 的构造方法 private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mRun = true; mThread = Thread.currentThread(); } loop ，进入一个无限 for 循环体中，不断地从消息队列中取消息，然后交给消息的 target 属性的 dispatchMessage 方法去处理。 public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#39;t called on this thread.&quot;); } final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); // 无限循环体，有没有想过在 UI 线程里，有这样一个死循环，为什么界面没卡死？？ // 答案最后揭晓。 for (;;) { Message msg = queue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return; } msg.target.dispatchMessage(msg); msg.recycle(); } } HandlerHandler 负责向消息队列中发送消息。在 Activity 中我们直接可以 new Handler ，那是因为在 Activity 的启动代码中，已经在当前 UI 线程中调用了 Looper.prepare() 和 Looper.loop() 方法。 在子线程中 new Handler 必须要在当前线程（子线程）中创建好 Looper 对象和消息队列，代码如下 //在子线程中 Looper.prepare(); handler = new Handler() { public void handleMessage(Message msg) { //处理消息 }; }; Looper.loop(); 之后，你拿着这个 Handler 对象就可以在其他线程中，往这个子线程的消息队列中发消息了。 HandlerThreadHandlerThread 可以看作在子线程中创建一个异步消息处理机制的简化版，HandlerThread 对象自动帮我们在工作线程里创建 Looper 对象和消息队列。 使用方法： mHandlerThread = new HandlerThread(&quot;MyHandlerThread&quot;); mHandlerThread.start(); mHandler = new Handler(mHandlerThread.getLooper()){ @Override public void handleMessage(Message msg) { //处理消息 } }; 之后你就可以使用 Handler 对象往工作线程中的消息队列中发消息了。 看一下源码片段： public class HandlerThread extends Thread { int mPriority; int mTid = -1; Looper mLooper; public HandlerThread(String name) { super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT; } protected void onLooperPrepared() { } @Override public void run() { mTid = Process.myTid(); Looper.prepare(); synchronized (this) { mLooper = Looper.myLooper(); notifyAll(); } Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; } public Looper getLooper() { if (!isAlive()) { return null; } // If the thread has been started, wait until the looper has been created. synchronized (this) { while (isAlive() &amp;&amp; mLooper == null) { try { wait(); } catch (InterruptedException e) { } } } return mLooper; } } 注意：handler 在 UI 线程中初始化的，looper 在一个子线程中执行，我们必须等 mLooper 创建完成之后，才能调用 getLooper ，源码中是通过 wait 和 notify 解决两个线程的同步问题。 IntentServiceIntentService 可以看成是 Service 和 HandlerThread 的合体。它继承自 Service ，并可以处理异步请求，其内部有一个 WorkerThread 来处理异步任务，当任务执行完毕后，IntentService 自动停止。 如果多次启动 IntentService 呢？ 看到 HandlerThread ，你就应该想到多次启动 IntentService ,就是将多个异步任务放到任务队列里面，然后在 onHandlerIntent 回调方法中串行执行，执行完毕后自动结束。 下面对源码进行简单的解析，IntentService 源码： public abstract class IntentService extends Service { private volatile Looper mServiceLooper; private volatile ServiceHandler mServiceHandler; private String mName; private boolean mRedelivery; private final class ServiceHandler extends Handler { public ServiceHandler(Looper looper) { super(looper); } @Override public void handleMessage(Message msg) { //onHandleIntent 方法在工作线程中执行，执行完调用 stopSelf() 结束服务。 onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); } } /** * Creates an IntentService. Invoked by your subclass&#39;s constructor. * * @param name Used to name the worker thread, important only for debugging. */ public IntentService(String name) { super(); mName = name; } /** * enabled == true 时，如果任务没有执行完，当前进程就死掉了，那么系统就会令当前进程重启。 * 任务会被重新执行。 */ public void setIntentRedelivery(boolean enabled) { mRedelivery = enabled; } @Override public void onCreate() { super.onCreate(); // 上面已经讲过，HandlerThread 对象 start 之后，会在工作线程里创建消息队列 和 Looper 对象。 HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); // 获得 Looper 对象初始化 Handler 对象。 mServiceHandler = new ServiceHandler(mServiceLooper); } @Override public void onStart(@Nullable Intent intent, int startId) { // IntentService 每次启动都会往工作线程消息队列中添加消息，不会创建新的线程。 Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); } // 官方建议 IntentService onStartCommand 方法不应该被重写，注意该方法会调用 onStart 。 @Override public int onStartCommand(@Nullable Intent intent, int flags, int startId) { onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY; } @Override public void onDestroy() { //服务停止会清除消息队列中的消息，除了当前执行的任务外，后续的任务不会被执行。 mServiceLooper.quit(); } /** * 不建议通过 bind 启动 IntentService ，如果通过 bind 启动 IntentService ，那么 onHandlerIntent 方法不会被回调。Activity 与 IntentService 之间的通信一般采用广播的方式。 */ @Override @Nullable public IBinder onBind(Intent intent) { return null; } /** * 子类必须要实现，执行具体的异步任务逻辑，由 IntentService 自动回调。 */ @WorkerThread protected abstract void onHandleIntent(@Nullable Intent intent); } IntentService 源码很容易理解，你也可以就自己的应用场景封装自己的 IntentService 。 场景 正常情况下，启动 IntentService ，任务完成，服务停止； 异步任务完成前，停止 IntentService ，服务停止，但任务还会执行完成，完成后，工作线程结束； 多次启动 IntentService ，任务会被一次串行执行，执行结束后，服务停止； 多次启动 IntentService ，在所有任务执行结束之前，停止 IntentService ，服务停止，除了当前执行的任务外，后续的任务不会被执行； ThreadPoolExcutor 图片来自 Jakob Jenkov 博客 ThreadPool用来管理一组工作线程，任务队列（ BlockingQueue ）中持有的任务等待着被线程池中的空闲线程执行。 常用构造方法：ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue ); corePoolSize 核心线程池容量，即线程池中所维持线程的最低数量。corePoolSize 初始值为 0 ，当有新任务加入到任务队列中，新的线程将被创建，这个时候即使线程池中存在空闲线程，只要当前线程数小于 corePoolSize ，那么新的线程依然被创建。 maximumPoolSize 线程池中所维持线程的最大数量。 keepAliveTime 空闲线程在没有新任务到来时的存活时间。 unit 参数 keepAliveTime 的时间单位。 workQueue 任务队列，必须是 BlockingQueue 。 简单使用创建 ThreadFactory ，当然也可以自定义。 private static final ThreadFactory sThreadFactory = new ThreadFactory() { private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) { return new Thread(r, &quot;AsyncTask #&quot; + mCount.getAndIncrement()); } }; 创建 ThreadPoolExecutor 。// 根据 CPU 核心数确定线程池容量。 public static final int NUMBER_OF_CORES = Runtime.getRuntime().availableProcessors(); mThreadPoolExecutor = new ThreadPoolExecutor( NUMBER_OF_CORES * 2, NUMBER_OF_CORES * 2 + 1, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), backgroundPriorityThreadFactory ); 执行mThreadPoolExecutor.execute(new Runnable() { @Override public void run() { //do something } }); Future future = mThreadPoolExecutor.submit(new Runnable() { @Override public void run() { //do something } }); //任务可取消 future.cancel(true); Future&lt;Integer&gt; futureInt = mThreadPoolExecutor.submit(new Callable&lt;Integer&gt;() { @override public Integer call() throws Exception { return 0; } }); //获取执行结果 futureInt.get(); FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;(){ @override public Integer call() throws Exception { return 0; } }); mThreadPoolExecutor.submit(task); task.get();","categories":[{"name":"Android","slug":"Android","permalink":"https://githubhaohao.github.io/categories/Android/"},{"name":"线程","slug":"Android/线程","permalink":"https://githubhaohao.github.io/categories/Android/线程/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://githubhaohao.github.io/tags/多线程/"}]},{"title":"Android Clean 架构浅析","slug":"Android-Clean-架构浅析","date":"2017-04-15T13:07:34.000Z","updated":"2017-05-13T08:10:52.547Z","comments":true,"path":"2017/04/15/Android-Clean-架构浅析/","link":"","permalink":"https://githubhaohao.github.io/2017/04/15/Android-Clean-架构浅析/","excerpt":"","text":"死磕 Android 架构也是一种娱乐 Android 常用的架构主要有 MVC，MVP，MVVM 以及 Clean 。以上架构设计模式没有绝对的优劣之分，关键要看具体的应用场景。更多关于 MVC，MVP 以及 MVVM 介绍可以参考MVC,MVP &amp; MVVM 什么是 Clean 架构？ Robert C. Martin (Uncle Bob) Clean 架构是由 Uncle Bob 在 2012 年发表的, 针对 Web App 的架构设计。 Bob大叔总结了各种系统架构的共通之处以及最终目标，并提出只需秉持分层与依赖规则的原则, 提出了 Clean 架构思想。 Clean 架构浅析单向依赖 图片来自 Robert C. Martin (Uncle Bob) Clean 架构各层之间的依赖是单向的，只能是外层依赖内层。 MVP VS Clean 图片来自 Google 从上图可以看到 Clean 架构的 Android 实现，实际上是对目前比较流行的 MVP 架构进行改造。 MVP 之 View 和 Presenter 层作为 Clean 架构的 Presentations Layer, 新增 Domain Layer 处理所有的业务逻辑。MVP 中的 Model 层功能被弱化，作为 Data Layer 对外只提供接口，不再有业务逻辑。 一般来说每一层都有独立的数据模型。 Clean 之 Presentation 层包含如下类： Presenter 和 View 层相关类，当然你也可以在 MVVP 架构基础之上进行改造。 Mapper 类，负责将 Domain 层的数据模型转换为 Presentation 的数据模型。 本层的异常封装类。 Clean 之 Domain 层Domain 层不依赖于 Android 类库和第三方库，可以独立做单元测试。 包含如下类： Use Cases (Interactor）类，负责完成对 Data 层的某一操作行为。（如获取 movie list ,获取某一 movie 的 detail info 可视为 2 个 Use Case 或 Interactor）。 Mapper 类，负责将 Data 层的数据模型转换为 Domain 层的数据模型。 本层的异常封装类。 Clean 之 Data 层 图片来自 Robert C. Martin (Uncle Bob) 这张图就足够说明一切了。 包含各种 API 接口，主要对应数据库操作，文件操作以及网络数据操作，一些异常封装类。Mapper 类，负责将网络数据模型转换为 Data 层的数据模型。 注意 Data 层只提供接口，没有业务逻辑。 更多 https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean/ https://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/","categories":[{"name":"Android","slug":"Android","permalink":"https://githubhaohao.github.io/categories/Android/"},{"name":"架构","slug":"Android/架构","permalink":"https://githubhaohao.github.io/categories/Android/架构/"}],"tags":[{"name":"Clean 架构","slug":"Clean-架构","permalink":"https://githubhaohao.github.io/tags/Clean-架构/"}]},{"title":"RecyclerView 加载与刷新功能实现","slug":"RecyclerView-加载与刷新功能实现","date":"2017-04-13T10:30:00.000Z","updated":"2017-05-13T08:13:56.687Z","comments":true,"path":"2017/04/13/RecyclerView-加载与刷新功能实现/","link":"","permalink":"https://githubhaohao.github.io/2017/04/13/RecyclerView-加载与刷新功能实现/","excerpt":"","text":"坚持就是进步 最近 Kotlin Android 开发貌似要火起来，Kotlin 具有脚本语言风格，能与 Java 无缝兼容，并且有 Google 有意栽培。 RecyclerView 加载与刷新功能实现RecyclerView 功能及灵活性强大到令人发指。在开发中，完全可以用它代替 ListView 和 GridView ，并且还具有瀑布流展示功能。 本文主要对 RecyclerView 进行简单的封装，来实现加载、刷新以及异常状态展示多种功能，实现及其简单，代码量很少。 效果展示 Demo 下载 源码地址: https://github.com/githubhaohao/JCRecyclerView 具体实现JCRecyclerView 继承 RecyclerView ，保留 RecyclerView 的所有特性。 内部类 JCAdapter 对外部的 RecyclerView Adapter 进行拦截改造，实现根据配置在 position = 0 的位置加载 Ad-Slot View （广告位），加载时在底部显示 Bottom View 表视加载正在进行。 private class JCAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private RecyclerView.Adapter adapter; private static final int TYPE_ADSLOT = 0x10; private static final int TYPE_NORMAL = 0x11; private static final int TYPE_BOTTOM = 0x12; public JCAdapter(RecyclerView.Adapter adapter) { this.adapter = adapter; } @Override public void onViewAttachedToWindow(ViewHolder holder) { super.onViewAttachedToWindow(holder); ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams(); if(layoutParams != null){ if(adSlotView != null) { if(layoutParams instanceof StaggeredGridLayoutManager.LayoutParams &amp;&amp; holder.getLayoutPosition() == 0){ StaggeredGridLayoutManager.LayoutParams p = (StaggeredGridLayoutManager.LayoutParams) layoutParams; p.setFullSpan(true); } } if (bottomView != null &amp;&amp; isLoading) { if(layoutParams instanceof StaggeredGridLayoutManager.LayoutParams &amp;&amp; holder.getLayoutPosition() == getItemCount() - 1){ StaggeredGridLayoutManager.LayoutParams p = (StaggeredGridLayoutManager.LayoutParams) layoutParams; p.setFullSpan(true); } } } if (layoutManager instanceof GridLayoutManager) { final GridLayoutManager gridManager = ((GridLayoutManager) layoutManager); gridManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() { @Override public int getSpanSize(int position) { boolean spanResult = false; if(adSlotView != null &amp;&amp; bottomView != null) { if (isLoading) { spanResult = (position == 0 || position == getItemCount() - 1); } else { spanResult = (position == 0); } } else if (adSlotView != null) { spanResult = (position==0); } else if (bottomView != null &amp;&amp; isLoading) { spanResult = (position == getItemCount() - 1); } return spanResult ? gridManager.getSpanCount():1; } }); } } @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == TYPE_ADSLOT) { return new JCViewHolder(adSlotView); } else if (viewType == TYPE_BOTTOM) { return new JCViewHolder(bottomView); } return adapter.onCreateViewHolder(parent,viewType); } @Override public void onBindViewHolder(ViewHolder holder, int position) { if (getItemViewType(0) == TYPE_ADSLOT) { if (position == 0) return; int newPosition = --position; if (adapter != null) { if (newPosition &lt; adapter.getItemCount()) { adapter.onBindViewHolder(holder, newPosition); } } return; } else if (getItemViewType(position) == TYPE_BOTTOM) { return; } adapter.onBindViewHolder(holder, position); } @Override public int getItemCount() { int count = adapter.getItemCount(); if (adSlotView != null) { count ++; } if (bottomView != null &amp;&amp; isLoading) { count ++; } return count; } @Override public int getItemViewType(int position) { if (position == 0) { return adSlotView == null ? TYPE_NORMAL : TYPE_ADSLOT; } else if (position == getItemCount() - 1 &amp;&amp; isLoading) { return bottomView == null ? TYPE_NORMAL : TYPE_BOTTOM; } else { return TYPE_NORMAL; } } } 向外暴露一个接口 OnLoadMoreListener ，完成加载时的回调。 public interface OnLoadMoreListener { void onLoadMore(); } 整体思路就是这些，完整代码： public class JCRecyclerView extends RecyclerView { private static final String TAG = JCRecyclerView.class.getSimpleName(); private LayoutManager layoutManager; private ViewGroup adSlotView; private ViewGroup stateView; private ViewGroup bottomView; private boolean isLoading = false; private JCAdapter jcAdapter; private OnLoadMoreListener onLoadMoreListener; public void addOnLoadMoreListener(OnLoadMoreListener listener) { this.onLoadMoreListener = listener; this.addOnScrollListener(new OnScrollListener() { @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) { if (recyclerView.getLayoutManager() instanceof StaggeredGridLayoutManager) { StaggeredGridLayoutManager layoutManager = (StaggeredGridLayoutManager) recyclerView.getLayoutManager(); int totalItemCount = recyclerView.getAdapter().getItemCount(); int[] lastVisibleItemPositions = new int[layoutManager.getSpanCount()]; layoutManager.findLastVisibleItemPositions(lastVisibleItemPositions); int visibleItemCount = recyclerView.getChildCount(); int lastVisibleItemPosition = findMaxPosition(lastVisibleItemPositions); if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; lastVisibleItemPosition == totalItemCount - 1 &amp;&amp; visibleItemCount &gt; 0) { if (bottomView == null || isLoading || stateView != null) return; isLoading = true; jcAdapter.notifyDataSetChanged(); onLoadMoreListener.onLoadMore(); scrollToPosition(jcAdapter.getItemCount() - 1); } } else { LinearLayoutManager lm = (LinearLayoutManager) recyclerView.getLayoutManager(); int totalItemCount = recyclerView.getAdapter().getItemCount(); int lastVisibleItemPosition = lm.findLastVisibleItemPosition(); int visibleItemCount = recyclerView.getChildCount(); if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; lastVisibleItemPosition == totalItemCount - 1 &amp;&amp; visibleItemCount &gt; 0) { if (bottomView == null || isLoading || stateView != null) return; isLoading = true; jcAdapter.notifyDataSetChanged(); onLoadMoreListener.onLoadMore(); scrollToPosition(jcAdapter.getItemCount() - 1); } } } }); } private int findMaxPosition(int[] positions) { int max = positions[0]; for (int index = 1; index &lt; positions.length; index++) { if (positions[index] &gt; max) { max = positions[index]; } } return max; } public void setBottomView(ViewGroup view) { if (bottomView == null) { this.bottomView = view; } } public void setLoading(boolean flag) { if (!flag) { isLoading = false; jcAdapter.notifyDataSetChanged(); scrollToPosition(jcAdapter.getItemCount() - 1); } } public void setAdSlotView(ViewGroup view) { if (adSlotView == null) { adSlotView = view; if (jcAdapter != null) { jcAdapter.notifyItemInserted(0); scrollToPosition(0); } } } public void setStateView(ViewGroup view) { if (stateView != null) return; if (view == null) return; if (adSlotView != null) { scrollToPosition(0); stateView = view; Rect rect = new Rect(); getGlobalVisibleRect(rect); LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, rect.bottom - rect.top - adSlotView.getHeight()); adSlotView.addView(stateView, layoutParams); } else { showToast(&quot;You should set the ad-slot view at first.&quot;); } } public void removeAdSlotView() { if (adSlotView != null &amp;&amp; jcAdapter != null) { adSlotView = null; jcAdapter.notifyItemRemoved(0); } } public void removeStateView() { if (adSlotView != null &amp;&amp; stateView != null &amp;&amp; jcAdapter != null) { adSlotView.removeView(stateView); stateView = null; } } @Override public void setAdapter(Adapter adapter) { this.jcAdapter = new JCAdapter(adapter); super.setAdapter(this.jcAdapter); } public JCRecyclerView(Context context, AttributeSet attrs) { super(context, attrs); } @Override public void setLayoutManager(LayoutManager layoutManager) { this.layoutManager = layoutManager; super.setLayoutManager(layoutManager); } private class JCAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private RecyclerView.Adapter adapter; private static final int TYPE_ADSLOT = 0x10; private static final int TYPE_NORMAL = 0x11; private static final int TYPE_BOTTOM = 0x12; public JCAdapter(RecyclerView.Adapter adapter) { this.adapter = adapter; } @Override public void onViewAttachedToWindow(ViewHolder holder) { super.onViewAttachedToWindow(holder); ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams(); if(layoutParams != null){ if(adSlotView != null) { if(layoutParams instanceof StaggeredGridLayoutManager.LayoutParams &amp;&amp; holder.getLayoutPosition() == 0){ StaggeredGridLayoutManager.LayoutParams p = (StaggeredGridLayoutManager.LayoutParams) layoutParams; p.setFullSpan(true); } } if (bottomView != null &amp;&amp; isLoading) { if(layoutParams instanceof StaggeredGridLayoutManager.LayoutParams &amp;&amp; holder.getLayoutPosition() == getItemCount() - 1){ StaggeredGridLayoutManager.LayoutParams p = (StaggeredGridLayoutManager.LayoutParams) layoutParams; p.setFullSpan(true); } } } if (layoutManager instanceof GridLayoutManager) { final GridLayoutManager gridManager = ((GridLayoutManager) layoutManager); gridManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() { @Override public int getSpanSize(int position) { boolean spanResult = false; if(adSlotView != null &amp;&amp; bottomView != null) { if (isLoading) { spanResult = (position == 0 || position == getItemCount() - 1); } else { spanResult = (position == 0); } } else if (adSlotView != null) { spanResult = (position==0); } else if (bottomView != null &amp;&amp; isLoading) { spanResult = (position == getItemCount() - 1); } return spanResult ? gridManager.getSpanCount():1; } }); } } @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if (viewType == TYPE_ADSLOT) { return new JCViewHolder(adSlotView); } else if (viewType == TYPE_BOTTOM) { return new JCViewHolder(bottomView); } return adapter.onCreateViewHolder(parent,viewType); } @Override public void onBindViewHolder(ViewHolder holder, int position) { if (getItemViewType(0) == TYPE_ADSLOT) { if (position == 0) return; int newPosition = --position; if (adapter != null) { if (newPosition &lt; adapter.getItemCount()) { adapter.onBindViewHolder(holder, newPosition); } } return; } else if (getItemViewType(position) == TYPE_BOTTOM) { return; } adapter.onBindViewHolder(holder, position); } @Override public int getItemCount() { int count = adapter.getItemCount(); if (adSlotView != null) { count ++; } if (bottomView != null &amp;&amp; isLoading) { count ++; } return count; } @Override public int getItemViewType(int position) { if (position == 0) { return adSlotView == null ? TYPE_NORMAL : TYPE_ADSLOT; } else if (position == getItemCount() - 1 &amp;&amp; isLoading) { return bottomView == null ? TYPE_NORMAL : TYPE_BOTTOM; } else { return TYPE_NORMAL; } } } private class JCViewHolder extends RecyclerView.ViewHolder { public JCViewHolder(View itemView) { super(itemView); } } private void showToast(String msg) { Toast.makeText(getContext(),msg,Toast.LENGTH_SHORT).show(); } public interface OnLoadMoreListener { void onLoadMore(); } } 200 多行代码，轻松实现 RecyclerView 刷新、加载以及异常状态的展示功能。","categories":[{"name":"Android","slug":"Android","permalink":"https://githubhaohao.github.io/categories/Android/"},{"name":"RecyclerView","slug":"Android/RecyclerView","permalink":"https://githubhaohao.github.io/categories/Android/RecyclerView/"}],"tags":[{"name":"RecyclerView 加载与刷新","slug":"RecyclerView-加载与刷新","permalink":"https://githubhaohao.github.io/tags/RecyclerView-加载与刷新/"}]},{"title":"Android jar 与 aar","slug":"Android-jar-与-aar","date":"2017-04-01T04:43:26.000Z","updated":"2017-05-13T08:10:16.571Z","comments":true,"path":"2017/04/01/Android-jar-与-aar/","link":"","permalink":"https://githubhaohao.github.io/2017/04/01/Android-jar-与-aar/","excerpt":"","text":"愚人节不愚人 最近开始搞机器学习，同时项目也不停的维护着！嘿嘿，明天就是小长假了。 Android jar 与 aarjar (Java Application Resource) 是一种归档文件，以 ZIP 格式构建，以 .jar 为文件扩展名。用户可以使用JDK自带的 jar 命令创建或提取 JAR 文件。jar 文件只包含 class 文件和 配置文件。 aar (Android Application Resource) 是 android 中特有的归档文件，既包含 class 文件也包含 android 的 res 资源文件。 Android Studio 生成 jar 和 aar 文件新建一个 ModuleAndroid studio 菜单 File -&gt; New -&gt; New Module -&gt; Android Module 。 创建名为 mylibrary 的 module。 在 mylibrary 下新建一个类 Person ,等会在 app module 下访问它。 生成 jar 和 aar 文件直接 Rebuild 或者运行 mylibrary task 如下图： Build Successful 之后可在下图的目录下找到 jar 和 arr 文件。 引入 jar 将 jar 文件拷贝到 app 的 lib 文件夹下； 右击 jar 文件，选择 Add As Library ，添加到 app module 下，然后 Android Studio 会自动编译。 引入 aar 将 aar 文件拷贝到 app 的 lib 文件夹下 (可以修改 aar 文件名字，本例中修改为 mylibrary )； 修改 build.gradle 配置文件：```gradleandroid {……repositories { flatDir { dirs &#39;libs&#39; }}} dependencies { …… compile(name: ‘mylibrary’, ext: ‘aar’) } ```Async Project 大工告成。 同样，你也可以在其他工程中引入 jar 或 aar 文件。","categories":[{"name":"Android","slug":"Android","permalink":"https://githubhaohao.github.io/categories/Android/"}],"tags":[{"name":"jar aar","slug":"jar-aar","permalink":"https://githubhaohao.github.io/tags/jar-aar/"}]},{"title":"Android 四大组件之 Activity","slug":"Android-四大组件之-Activity","date":"2017-03-01T06:36:14.000Z","updated":"2017-05-13T08:11:37.470Z","comments":true,"path":"2017/03/01/Android-四大组件之-Activity/","link":"","permalink":"https://githubhaohao.github.io/2017/03/01/Android-四大组件之-Activity/","excerpt":"","text":"唉！最近拖延症又犯了 最近真的是越来越懒了，总是找各种理由不写博客。虽然最近各种事，又搞论文，又搞项目的，再拖下去实在是对不住 “不忘初心” 这一句话。惭愧！虽然关于 Activity 已经被写烂了，但是从本篇文章里，你一定会发现不同的东西。 Activity 生命周期一般情况下 public class Activity extends ApplicationContext { protected void onCreate(Bundle savedInstanceState); protected void onStart(); protected void onResume(); protected void onPause(); protected void onStop(); protected void onDestroy(); } 异常情况下系统配置变化导致Activity销毁重建 旋转屏幕，Activity 销毁并重新创建，在异常情况下系统会在 onStop 之前调用 onSaveInstanceState 来保存状态。Activity 重新创建后，会在 onStart 之后调用 onRestoreInstanceState 恢复之前保存的数据。 系统只在 Activity 异常终止的时候才会调用 onSaveInstanceState 和 onRestoreInstanceState 方法。其他情况不会触发。 资源内存不足导致低优先级的 Activity 被回收 前台- 可见非前台（被对话框遮挡的 Activity ）-后台，这三种 Activity 优先级从高到低。 android:configChanges=&quot;orientation&quot; 在 manifest 中指定 configChanges 在系统配置变化后不重新创建 Activity，也不会执行onSaveInstanceState 和 onRestoreInstanceState 方法，而是调用 onConfigurationChnaged 方法。 configChanges 一般常用三个选项： locale 系统语言变化 keyborardHidden 键盘的可访问性发生了变化，比如用户调出了键盘 orientation 屏幕方向变化 场景首次启动 ActivityMainActivity onCreate MainActivity onStart MainActivity onResume 跳转到 SecondActivityMainActivity onPause SecondActivity onCreate SecondActivity onStart SecondActivity onResume MainActivity onStop Back 返回 MainActivitySecondActivity onPause MainActivity onRestart MainActivity onStart MainActivity onResume SecondActivity onStop SecondActivity onDestroy Home 回退桌面MainActivity onPause MainActivity onStop 桌面返回可见MainActivity onRestart MainActivity onStart MainActivity onResume 锁屏MainActivity onPause MainActivity onStop 解锁屏MainActivity onRestart MainActivity onStart MainActivity onResume 注意onStart 开始到 onStop 之前， Activity 可见。onResume 开始到 onPause 之前， Activity 可接受用户交互。在新Activity启动之前，栈顶的Activity需要先onPause后，新Activity才能启动。所以不能在onPause执行耗时操作。 Activity 数据传递Activity 传递数据一般有以下几种方式： Intent 传递数据MainActivity Intent intent=new Intent(); intent.setClass(MainActivity.this, OtherActivity.class); Bundle bundle = new Bundle(); bundle.putString(KEY, VALUE); intent.putExtras(bundle); startActivity（intent）; OtherActivity Intent intent = getIntent(); Bundle bundle = intent.getEtras(); String value = bundle.getString(KEY); 利用 Intent 对象在 Activity 之间传递数据是 Android 开发最常用的方式。利用 Intent 对象可以传递基本数据类型，以及一些可序列化的对象。 public 型的静态变量public 型的静态变量，在类被加载的时候，就被创建在静态存储区，不依赖于对象。 Application 对象在整个应用程序中就一个Application单例，它的生命周期贯穿整个程序，堆内存中只存在一个对象实例，所以程序内所有它的引用指向的是同一块堆内存，所以可以在不同activity对application实例变量进行值的存取。不推荐。 Clipboard 剪切板ClipboardManager：该类是系统剪切板服务的接口，用来放入或取出全局剪切板中的文本。 ClipboardManager clipboardManager = (ClipboardManager)getSystemService(Context.CLIPBOARD_SERVICE); clipboardManager.setText(DATA.toString()); } ClipboardManager clipboardManager = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE); String data = clipboardManager.getText().toString(); Clipboard 也可以传递可序列化对象。 文件传值通过向本地文件写入和读取来传递数据。常用的如 SharedPrefrences 对象等。 数据库你自己想吧！ Activity 启动模式启动模式,简单地说就是 Activity 启动时的策略，在AndroidManifest.xml 中的标签的 android:launchMode 属性设置； 启动模式有4种，分别为 standard、singleTop、singleTask、singleInstance； standard 模式每次 startActivity 时，都创建 Activity 实例，并放入任务栈，该任务栈中，可以有多个同类 Activity 的实例。 应用场景：Your idea。 singleTop 模式栈顶不是该类型的 Activity，则创建一个新的 Activity。否则，回调该 Activity 实例的 onNewIntent 方法。 应用场景：接收通知消息启动的页面。 例如，对于推送比较频繁的应用，如果收到多个推送，每次都打开一个页面显示内容是不妥的。 singleTask 模式任务栈中不存在启动 Activity 的实例，则创建 Activity 放入任务栈。否则，回调该 Activity 的 onNewIntent 方法，并将该 Activity 置于栈顶，其以上的 Activity 都被弹出 (pop)。[onNewIntent + clearTop] 应用场景：作为应用的入口点。 例如，对于浏览器的主界面，不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走 onNewIntent ，并且会清空主界面上面的其他页面。 singleInstance 模式回退栈中，只有这一个Activity，没有其他Activity。 应用场景：闹铃的响铃界面。正在进行 QQ 聊天室时，闹铃响了，弹出一个对话形式的（以 SingleInstance 加载模式打开的）AlarmActivity，按了返回键之后回到 QQ 聊天界面，这是因为 Alarm Activity 所在的任务栈只有它一个元素， 因此退出之后这个任务栈空了。如果是以 SingleTask 打开 AlarmActivity，那么当闹铃响了的时候，按返回键应该进入闹铃设置界面。","categories":[{"name":"Android","slug":"Android","permalink":"https://githubhaohao.github.io/categories/Android/"},{"name":"四大组件","slug":"Android/四大组件","permalink":"https://githubhaohao.github.io/categories/Android/四大组件/"}],"tags":[{"name":"Activity","slug":"Activity","permalink":"https://githubhaohao.github.io/tags/Activity/"}]},{"title":"Android 主题切换和多主题实现","slug":"Android主题切换和多主题实现","date":"2017-02-17T06:13:42.000Z","updated":"2017-05-13T08:19:35.108Z","comments":true,"path":"2017/02/17/Android主题切换和多主题实现/","link":"","permalink":"https://githubhaohao.github.io/2017/02/17/Android主题切换和多主题实现/","excerpt":"","text":"又是一个周末 白天和夜间模式Android官方在Support包从23.2版本开始提供支持白天夜间模式的主题 Theme.AppCompat.DayNight，也就是 DayNight Mode ，轻松实现主体无缝切换。 Theme.AppCompat.DayNight 可以根据系统时间切换 Theme.AppCompat (暗色) 和 Theme.AppCompat.Light ( 亮色 ) 两种主题。这将大大提高了阅读类应用的用户体验 同时还支持 Material Design。 需要注意的是，这个特性只支持 API v14 及以上的 Android 设备，在 API v14 以下的设备则会默认使用亮色的主题。 效果预览 具体过程1. 引入 support-v7:23.2+ 版本的依赖compile &#39;com.android.support:appcompat-v7:25.1.1&#39; 为保证主题风格的统一，所有的 Activity 类应继承 AppCompatActivity 。 2. 自定义实现 DayNight 主题 res 目录下新建 values-night 文件，拷贝修改 colors.xml 和 styles.xml 文件到 values-night，为 Night Model 下系统加载的 color资源，同样地也可以指定 Night Model 下加载的 drawable 资源在 drawable-night 文件夹中，同理 layout mipmap 资源加载也是如此。 &lt;style name=&quot;MyApp.DayNight.NoActionBar.Theme&quot; parent=&quot;Theme.AppCompat.DayNight.NoActionBar&quot;&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;item name=&quot;android:textColorPrimary&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; 具体位置颜色设置看图： 在 AndroidManifest.xml 中声明，单个 Activity 的主题。 &lt;application android:name=&quot;.MyApplication&quot; android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:supportsRtl=&quot;true&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot;@style/MyApp.DayNight.NoActionBar.Theme&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; 或者整个 App 的主题 &lt;application android:name=&quot;.MyApplication&quot; android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/MyApp.DayNight.NoActionBar.Theme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot; android:label=&quot;@string/app_name&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; 3 设置 DayNight 主题初始化主题: private void initAppTheme() { if (getThemeSharedPref().getBoolean(KEY_NIGHT_THEME, false)) { getDelegate().setLocalNightMode(AppCompatDelegate.MODE_NIGHT_YES); } else { getDelegate().setLocalNightMode(AppCompatDelegate.MODE_NIGHT_NO); } } private SharedPreferences getThemeSharedPref() { return getSharedPreferences(&quot;APP_THEME&quot;, Context.MODE_PRIVATE); } 初始化主题应该在 super.onCreate() 之前执行，不然 Activity 会启动 2 次,下图为证： 切换主题： if (id == R.id.set_day_theme) { getDelegate().setLocalNightMode(AppCompatDelegate.MODE_NIGHT_NO); getThemeSharedPref().edit().putBoolean(KEY_NIGHT_THEME,false).apply(); } else if (id == R.id.set_night_theme) { getDelegate().setLocalNightMode(AppCompatDelegate.MODE_NIGHT_YES); getThemeSharedPref().edit().putBoolean(KEY_NIGHT_THEME, true).apply(); } 切换主题会重启 Activity。 DayNight Theme 有 4 种 Model ，分别是： MODE_NIGHT_NO. 使用 Day 主题 MODE_NIGHT_YES. 使用暗色 Night 主题 MODE_NIGHT_AUTO. 根据系统时间自动切换 MODE_NIGHT_FOLLOW_SYSTEM(默认选项). 设置为跟随系统 多主题实现介绍几种换肤的第三方库。 MultipleTheme 真正的支持无缝换肤／夜间模式的Android框架，配合theme和换肤控件框架可以做到无缝切换换肤（无需重启应用和当前页面）。 该应用框架可以实现无缝换肤／切换夜间模式的需求，需要在换肤／切换夜间模式的界面只需要使用框架里的自封装控件，其他界面的控件使用原生android控件即可。 缺陷：各种控件都需要重定义。优势：扩展性强，无需重启 Activity。 Colorful [推荐] Colorful is a dynamic theme library allowing you to change your apps’ color schemes easily. 缺陷：主题颜色可定制性差，不支持 Material Design 风格。优势：使用方便。 Prism Prism 下含有三个库： prsim 库含有一些核心功能； prism-viewpager 库实现了核心库与 ViewPager 的对接； prism-palette 库实现了核心库与 Palette 的对接。 分成三个库是为了区分依赖条件：核心库不依赖外部条件，它能够很容易地添加到你的工程之中；但是 prism-viewpager 和 prism-palette 需要依赖相应的support库。所以当你的程序不使用这些依赖库时，你可以只使用 prism 库来省去不必要的依赖条件。不过当你的程序中使用了 ViewPager 时，即已经对相关的support库有了依赖，那么添加 prism-viewpager 库就不需要额外的依赖条件。 但是，作者已停止更新。 Android-Skin-Loader [推荐]看效果 项目目录： Android-Skin-Loader├── android-skin-loader-lib // 皮肤加载库├── android-skin-loader-sample // 皮肤库应用实例├── android-skin-loader-skin // 皮肤包生成demo└── skin-package // 皮肤包输出目录 可以将皮肤文件打包分离，支持在线换肤，皮肤共享，不会重启 Activity 或 Fragment 。皮肤包（ 后缀名为.skin ）的本质是一个apk文件，该apk文件不包含代码，只包含资源文件。 缺陷：每个换肤的 View 都要设置 skin:enable=&quot;true&quot; 繁琐 ( 反正我感觉挺烦的 )，不支持 Material Design 风格。 不过，还好 ThemeSkinning 进行了优化，支持 Material Design 和字体的切换。 示例：","categories":[{"name":"Android","slug":"Android","permalink":"https://githubhaohao.github.io/categories/Android/"},{"name":"主题","slug":"Android/主题","permalink":"https://githubhaohao.github.io/categories/Android/主题/"}],"tags":[{"name":"Android 主题切换","slug":"Android-主题切换","permalink":"https://githubhaohao.github.io/tags/Android-主题切换/"}]},{"title":"MVVM，RxJava 和 Retrofit 的一次实践","slug":"MVVM，RxJava和Retrofit的一次实践","date":"2017-02-12T06:21:25.000Z","updated":"2017-05-13T08:20:15.060Z","comments":true,"path":"2017/02/12/MVVM，RxJava和Retrofit的一次实践/","link":"","permalink":"https://githubhaohao.github.io/2017/02/12/MVVM，RxJava和Retrofit的一次实践/","excerpt":"","text":"春节后的第一篇博客 本文已授权微信公众号：鸿洋（hongyangAndroid）原创首发。原创文章，转载请注明出处:haohaochang.cn 效果预览 Demo 下载 准备知识MVC 视图层（View）：用户界面。 控制器层（Controller）：业务逻辑 模型层（Model）：数据保存 View 层传送指令到 Controller 层 Controller 层完成业务逻辑后，要求 Model 层改变状态 Model 层将新的数据发送到 View层，使用户得到反馈 缺陷:View 层和 Model 层是相互可知，耦合性大，像 Activity 或者 Fragment 既在 Controller 层，又在 View 层，造成工程的可扩展性可维护性非常差。 MVP 在 MVP 架构模式中，Controller 层变成了 Presenter 层。 MVP 模式各层之间的通信，都是双向的。 View 层与 Model 层不直接发生联系，都通过 Presenter 层进行间接通信。 Model 层与 Presenter 层，Presenter 层与 View 层之间通过接口建立联系。 采用 MVP 模式，Activity 与 Fragment 只位于 View 层。 MVP 的缺陷在于:由于我们使用了接口的方式去连接 View 层和 Presenter 层，这样就导致了特定场景下的一些问题，当你的页面逻辑很复杂的时候，你的 View 层实现的接口会有很多，如果你的 App 中有很多个这样复杂的页面，维护接口的成本就会变的非常的大。 MVVM MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。区别在于: View 层与 ViewModel 层通过 DataBinding 相互绑定，View 层的变动，自动反映在 ViewModel 层，反之亦然。 RxJava Rx 是微软 .Net 的一个响应式扩展，Rx 借助可观测的序列提供一种简单的方式来创建异步的，基于事件驱动的程序。2012 年 Netflix 为了应对不断增长的业务需求开始将 .NET Rx 迁移到 JVM 上面。并于 13 年二月份正式向外展示了 RxJava 。 从语义的角度来看， RxJava 就是 .NET Rx 。从语法的角度来看， Netflix 考虑到了对应每个 Rx 方法,保留了 Java 代码规范和基本的模式。 RxJava 在 GitHub 主页的介绍是： RxJava is a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences. 一个在 Java VM 上使用可观测的序列来组成异步的、基于事件程序的库。 RxJava 本质上是一个异步操作库，是一个能让你用极其简洁的逻辑去处理繁琐复杂任务的异步事件库。 简而言之，RxJava 可以用几个关键字概括：简洁，队列化，异步。 Retrofit 一个 Android 和 Java 上 HTTP 库（利用注解和 OKHttp 来实现和服务器的数据交互）。 Retrofit 基于 OKHttp 并引入注解，使用简单，易扩展，易维护。 Retrofit 官方文档:http://square.github.io/retrofit/ DataBinding 在Google IO 2015 中，Google 在 support-v7 中新增了 Data Binding，使用 Data Binding可以直接在布局的 xml 中绑定布局与数据，从而简化代码，Android Data Binding是Android 的 MVVM 框架。因为 Data Binding 是包含在 support-v7 包里面的，所以可以向下兼容到最低 Android 2.1 (API level 7+). 实践直接上代码。 依赖的第三方类库 compile &#39;io.reactivex:rxjava:1.1.0&#39; compile &#39;io.reactivex:rxandroid:1.1.0&#39; compile &#39;com.squareup.retrofit2:retrofit:2.0.0-beta4&#39; compile &#39;com.squareup.retrofit2:converter-gson:2.0.0-beta4&#39; compile &#39;com.squareup.retrofit2:adapter-rxjava:2.0.0-beta4&#39; compile &#39;com.github.bumptech.glide:glide:3.7.0&#39; API https://api.douban.com/v2/movie/top250?start=0&amp;count=20 引入DataBindingandroid { ...... dataBinding { enabled = true } } 工程目录结构 详细源码：https://github.com/githubhaohao/MVVMRxJavaRetrofitSample MVVM 之 ViewMainActivity.java getFragmentManager().beginTransaction().add(R.id.movie_fragment, MovieFragment.getInstance()).commit(); MovieFragment.java public class MovieFragment extends Fragment implements CompletedListener,SwipeRefreshLayout.OnRefreshListener{ private static String TAG = MovieFragment.class.getSimpleName(); private MainViewModel viewModel; private MovieFragmentBinding movieFragmentBinding; private MovieAdapter movieAdapter; public static MovieFragment getInstance() { return new MovieFragment(); } @Nullable @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View contentView = inflater.inflate(R.layout.movie_fragment, container, false); movieFragmentBinding = MovieFragmentBinding.bind(contentView); initData(); return contentView; } private void initData() { movieAdapter = new MovieAdapter(); movieFragmentBinding.recyclerView.setLayoutManager(new LinearLayoutManager(getActivity(), LinearLayoutManager.VERTICAL, false)); movieFragmentBinding.recyclerView.setItemAnimator(new DefaultItemAnimator()); movieFragmentBinding.recyclerView.setAdapter(movieAdapter); movieFragmentBinding.swipeRefreshLayout.setColorSchemeResources(R.color.colorAccent, R.color.colorPrimary, R.color.colorPrimaryDark); movieFragmentBinding.swipeRefreshLayout.setOnRefreshListener(this); viewModel = new MainViewModel(movieAdapter,this); movieFragmentBinding.setViewModel(viewModel); } @Override public void onRefresh() { movieAdapter.clearItems(); viewModel.refreshData(); } @Override public void onCompleted() { if (movieFragmentBinding.swipeRefreshLayout.isRefreshing()) { movieFragmentBinding.swipeRefreshLayout.setRefreshing(false); } } } activity_main.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; tools:context=&quot;.view.MainActivity&quot;&gt; &lt;!-- ... --&gt; &lt;FrameLayout android:layout_marginTop=&quot;?attr/actionBarSize&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/movie_fragment&quot;/&gt; &lt;!-- ... --&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt; movie_fragment.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;variable name=&quot;viewModel&quot; type=&quot;com.jc.mvvmrxjavaretrofitsample.viewModel.MainViewModel&quot;/&gt; &lt;/data&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.v4.widget.SwipeRefreshLayout android:visibility=&quot;@{viewModel.contentViewVisibility}&quot; android:id=&quot;@+id/swipe_refresh_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recycler_view&quot; android:background=&quot;#ddd&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:padding=&quot;8dp&quot;&gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;/android.support.v4.widget.SwipeRefreshLayout&gt; &lt;ProgressBar style=&quot;?android:attr/progressBarStyleLarge&quot; android:id=&quot;@+id/progress_bar&quot; android:visibility=&quot;@{viewModel.progressBarVisibility}&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot;/&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:id=&quot;@+id/error_info_layout&quot; android:visibility=&quot;@{viewModel.errorInfoLayoutVisibility}&quot; android:orientation=&quot;vertical&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_gravity=&quot;center&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@{viewModel.exception}&quot;/&gt; &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt; &lt;/layout&gt; movie_item.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/tools&quot;&gt; &lt;data&gt; &lt;variable name=&quot;viewModel&quot; type=&quot;com.jc.mvvmrxjavaretrofitsample.viewModel.MovieViewModel&quot;/&gt; &lt;/data&gt; &lt;android.support.v7.widget.CardView xmlns:card_view=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/card_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; card_view:cardCornerRadius=&quot;4dp&quot; card_view:cardBackgroundColor=&quot;@color/background&quot; card_view:cardUseCompatPadding=&quot;true&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;ImageView android:layout_margin=&quot;8dp&quot; android:layout_width=&quot;60dp&quot; android:layout_height=&quot;100dp&quot; android:src=&quot;@drawable/cover&quot; app:imageUrl=&quot;@{viewModel.imageUrl}&quot; android:id=&quot;@+id/cover&quot;/&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:layout_margin=&quot;8dp&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:textColor=&quot;@android:color/black&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@{viewModel.title}&quot; android:textSize=&quot;12sp&quot;/&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;4dp&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;android.support.v7.widget.AppCompatRatingBar android:id=&quot;@+id/ratingBar&quot; style=&quot;?android:attr/ratingBarStyleSmall&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:isIndicator=&quot;true&quot; android:max=&quot;10&quot; android:numStars=&quot;5&quot; android:rating=&quot;@{viewModel.rating}&quot; /&gt; &lt;TextView android:id=&quot;@+id/rating_text&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;6dp&quot; android:text=&quot;@{viewModel.ratingText}&quot; android:textColor=&quot;?android:attr/textColorSecondary&quot; android:textSize=&quot;10sp&quot; /&gt; &lt;/LinearLayout&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;?android:attr/textColorSecondary&quot; android:textSize=&quot;10sp&quot; android:text=&quot;@{viewModel.movieType}&quot; android:id=&quot;@+id/movie_type_text&quot; android:layout_marginTop=&quot;6dp&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;?android:attr/textColorSecondary&quot; android:textSize=&quot;10sp&quot; android:text=&quot;@{viewModel.year}&quot; android:id=&quot;@+id/year_text&quot; android:layout_marginTop=&quot;6dp&quot; /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/android.support.v7.widget.CardView&gt; &lt;/layout&gt; MovieAdapter.java public class MovieAdapter extends RecyclerView.Adapter&lt;MovieAdapter.BindingHolder&gt; { private List&lt;Movie&gt; movies; public MovieAdapter() { movies = new ArrayList&lt;&gt;(); } @Override public BindingHolder onCreateViewHolder(ViewGroup parent, int viewType) { MovieItemBinding itemBinding = DataBindingUtil.inflate(LayoutInflater.from(parent.getContext()), R.layout.movie_item, parent, false); return new BindingHolder(itemBinding); } @Override public void onBindViewHolder(BindingHolder holder, int position) { MovieViewModel movieViewModel = new MovieViewModel(movies.get(position)); holder.itemBinding.setViewModel(movieViewModel); } @Override public int getItemCount() { return movies.size(); } public void addItem(Movie movie) { movies.add(movie); notifyItemInserted(movies.size() - 1); } public void clearItems() { movies.clear(); notifyDataSetChanged(); } public static class BindingHolder extends RecyclerView.ViewHolder { private MovieItemBinding itemBinding; public BindingHolder(MovieItemBinding itemBinding) { super(itemBinding.cardView); this.itemBinding = itemBinding; } } } 回调接口 CompletedListener.java public interface CompletedListener { void onCompleted(); } MVVM 之 ViewModelMainViewModel.java public class MainViewModel { public ObservableField&lt;Integer&gt; contentViewVisibility; public ObservableField&lt;Integer&gt; progressBarVisibility; public ObservableField&lt;Integer&gt; errorInfoLayoutVisibility; public ObservableField&lt;String&gt; exception; private Subscriber&lt;Movie&gt; subscriber; private MovieAdapter movieAdapter; private CompletedListener completedListener; public MainViewModel(MovieAdapter movieAdapter,CompletedListener completedListener) { this.movieAdapter = movieAdapter; this.completedListener = completedListener; initData(); getMovies(); } private void getMovies() { subscriber = new Subscriber&lt;Movie&gt;() { @Override public void onCompleted() { Log.d(&quot;[MainViewModel]&quot;, &quot;onCompleted&quot;); hideAll(); contentViewVisibility.set(View.VISIBLE); completedListener.onCompleted(); } @Override public void onError(Throwable e) { hideAll(); errorInfoLayoutVisibility.set(View.VISIBLE); exception.set(e.getMessage()); } @Override public void onNext(Movie movie) { movieAdapter.addItem(movie); } }; RetrofitHelper.getInstance().getMovies(subscriber, 0, 20); } public void refreshData() { getMovies(); } private void initData() { contentViewVisibility = new ObservableField&lt;&gt;(); progressBarVisibility = new ObservableField&lt;&gt;(); errorInfoLayoutVisibility = new ObservableField&lt;&gt;(); exception = new ObservableField&lt;&gt;(); contentViewVisibility.set(View.GONE); errorInfoLayoutVisibility.set(View.GONE); progressBarVisibility.set(View.VISIBLE); } private void hideAll(){ contentViewVisibility.set(View.GONE); errorInfoLayoutVisibility.set(View.GONE); progressBarVisibility.set(View.GONE); } } MovieViewModel.java public class MovieViewModel extends BaseObservable { private Movie movie; public MovieViewModel(Movie movie) { this.movie = movie; } public String getCoverUrl() { return movie.getImages().getSmall(); } public String getTitle() { return movie.getTitle(); } public float getRating() { return movie.getRating().getAverage(); } public String getRatingText(){ return String.valueOf(movie.getRating().getAverage()); } public String getYear() { return movie.getYear(); } public String getMovieType() { StringBuilder builder = new StringBuilder(); for (String s : movie.getGenres()) { builder.append(s + &quot; &quot;); } return builder.toString(); } public String getImageUrl() { return movie.getImages().getSmall(); } @BindingAdapter({&quot;app:imageUrl&quot;}) public static void loadImage(ImageView imageView,String url) { Glide.with(imageView.getContext()) .load(url) .placeholder(R.drawable.cover) .error(R.drawable.cover) .into(imageView); } } MVVM 之 ModelDouBanMovieService.java public interface DouBanMovieService { String BASE_URL = &quot;https://api.douban.com/v2/movie/&quot;; @GET(&quot;top250&quot;) Observable&lt;Response&lt;List&lt;Movie&gt;&gt;&gt; getMovies(@Query(&quot;start&quot;) int start, @Query(&quot;count&quot;) int count); } RetrofitHelper.java public class RetrofitHelper { private static final int DEFAULT_TIMEOUT = 10; private Retrofit retrofit; private DouBanMovieService movieService; OkHttpClient.Builder builder; /** * 获取RetrofitHelper对象的单例 * */ private static class Singleton { private static final RetrofitHelper INSTANCE = new RetrofitHelper(); } public static RetrofitHelper getInstance() { return Singleton.INSTANCE; } public RetrofitHelper() { builder = new OkHttpClient.Builder(); builder.connectTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS); retrofit = new Retrofit.Builder() .client(builder.build()) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .baseUrl(DouBanMovieService.BASE_URL) .build(); movieService = retrofit.create(DouBanMovieService.class); } public void getMovies(Subscriber&lt;Movie&gt; subscriber, int start, int count) { movieService.getMovies(start, count) .map(new Func1&lt;Response&lt;List&lt;Movie&gt;&gt;, List&lt;Movie&gt;&gt;() { @Override public List&lt;Movie&gt; call(Response&lt;List&lt;Movie&gt;&gt; listResponse) { return listResponse.getSubjects(); } }) .flatMap(new Func1&lt;List&lt;Movie&gt;, Observable&lt;Movie&gt;&gt;() { @Override public Observable&lt;Movie&gt; call(List&lt;Movie&gt; movies) { return Observable.from(movies); } }) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(subscriber); } } 还有 entity 类，这里就不贴出来了。 详细源码：https://github.com/githubhaohao/MVVMRxJavaRetrofitSample","categories":[{"name":"Android","slug":"Android","permalink":"https://githubhaohao.github.io/categories/Android/"}],"tags":[{"name":"MVVM","slug":"MVVM","permalink":"https://githubhaohao.github.io/tags/MVVM/"},{"name":"MVP","slug":"MVP","permalink":"https://githubhaohao.github.io/tags/MVP/"},{"name":"MVC","slug":"MVC","permalink":"https://githubhaohao.github.io/tags/MVC/"},{"name":"RxJava","slug":"RxJava","permalink":"https://githubhaohao.github.io/tags/RxJava/"},{"name":"Retrofit","slug":"Retrofit","permalink":"https://githubhaohao.github.io/tags/Retrofit/"}]},{"title":"ES6入门: 需要掌握的基本语法","slug":"ES6入门-需要掌握的基本语法","date":"2017-01-25T14:26:31.000Z","updated":"2017-05-13T08:14:36.658Z","comments":true,"path":"2017/01/25/ES6入门-需要掌握的基本语法/","link":"","permalink":"https://githubhaohao.github.io/2017/01/25/ES6入门-需要掌握的基本语法/","excerpt":"","text":"ES6是什么1. ES (ECMAScript) 和JavaScript的关系 ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现（另外的ECMAScript方言还有Jscript和ActionScript）。日常场合，这两个词是可以互换的。 2. ES6和ECMAScript 2015的关系ES6，一般是指ECMAScript 2015标准，但有时也表示一种泛指，是指JavaScript语言的下一代标准。涵盖了ECMAScript 2015，2016，2017等版本，而ECMAScript 2015则是正式名称，特指该年发布的正式版本的语言标准。 Babel转码器 Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。去官网选择自己习惯的工具来使用使用Babel吧！ let和const命令let和const与var类似都是用来声明变量的，但又有各自不同的用途。let与var对比，看代码： var name = &#39;haohao&#39;; if(true){ var name = &#39;jack&#39;; console.log(name) //jack } console.log(name) //jack ES5只有全局作用域和块级作用域，导致内层变量覆盖外层变量，使得两次输出的都是jack。而let为JS新增了块级作用域，因此它声明的变量只在let命令所在的代码块有效，具体看代码： let name = &#39;haohao&#39;; if(true){ let name = &#39;jack&#39;; console.log(name) //jack } console.log(name) //haohao const用来声明常量，一旦声明就不能改变。当我们尝试改变const声明的常量时，浏览器就会报错。 const PI = Math.PI PI = 23 //Module build failed: SyntaxError: /es6/app.js: &quot;PI&quot; is read-only 引用其他Module中声明的变量，用const来声明可以避免对其重命名而导致出现BUG。 const {width, height} = window.get(&#39;Dimension&#39;); 解构 (Destructuring)解构 (Destructuring) 是指按照某种模式，从对象或数组中提取值对指定的变量进行赋值。 ES6之前为变量赋值： let name = &#39;jack&#39;; let addr = &#39;cn&#39;; let sex = &#39;male&#39;; ES6可以这样： let [name,addr,sex] = [&#39;jack&#39;,&#39;cn&#39;,&#39;male&#39;]; name //jack addr //cn sex //male 默认值: let [name,addr,sex = &#39;male&#39;] = [&#39;jack&#39;,&#39;cn&#39;]; name //jack addr //cn sex //male 关于对象以前这样： let name = &#39;jack&#39;; let addr = &#39;cn&#39;; let sex = &#39;male&#39;; let student = { name:name, addr:addr, sex:sex } console.log(student); //Object { name:&#39;jack&#39;, addr:&#39;cn&#39;, sex:&#39;male&#39; } ES6可以这样： let name = &#39;jack&#39;; let addr = &#39;cn&#39;; let sex = &#39;male&#39;; let student = { name, addr, sex } console.log(student); //Object { name:&#39;jack&#39;, addr:&#39;cn&#39;, sex:&#39;male&#39; } 还有这样: let student = { name:&#39;kene&#39;, addr:&#39;us&#39;, sex:&#39;male&#39; } let { name, sex } = student; let { addr } = student; console.log(name, addr, sex); //kene us male 模板字符串 (template string)传统模板字符串： $(&#39;#showId&#39;).append( &quot;Hello，everyone!&quot; + &quot;I am Jack.&quot;+ &quot;I like eat &quot; + fruits + &quot;!&quot; ); ES6模板字符串： $(&#39;#showId&#39;).append(` Hello，everyone! I am Jack. I like eat ${fruits}! `); 反引号标识起始，${}引入变量，所有的空格缩进保存输出。 箭头函数 (arrow functions)ES6允许使用“箭头”（=&gt;）定义函数。 var func = i =&gt; i + 1; var func = (a, b) =&gt; {a++; b++; return a + b;} 上面的箭头函数等同于： var func = function(i) { return i + 1; }; var func = function(a, b) { a++; b++; return a + b; } 当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。有一种使用场景： class Person { constructor(){ this.name = &#39;person&#39;; } sayHello(){ setTimeout(function(){ console.log(this.name + &#39;says hello.&#39;); }); } } let p = new Person(); p.sayHello(); //undefined says hello. 运行上面的代码会报错，这是因为setTimeout中的this指向的是全局对象。有了箭头函数上述问题便可迎刃而解： class Person { constructor(){ this.name = &#39;person&#39;; } sayHello(){ setTimeout(() =&gt; { console.log(this.name + &#39;says hello.&#39;); }); } } let p = new Person(); p.sayHello(); //person says hello. 类 (Class)ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。 class Person { constructor(){ this.name = &#39;person&#39;; } sayHello(){ setTimeout(() =&gt; { console.log(this.name + &#39;says hello.&#39;); }); } } let p = new Person(); p.sayHello(); //person says hello. 上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。 ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 class Student extends Person { constructor(){ super(); this.name = &#39;student&#39;; } } let s = new Student(); s.sayHello(); //student says hello. 上面定义了一个Student类，该类通过extends关键字，继承了Person类的所有属性和方法。 子类Student必须在constructor方法中调用super方法，否则新建实例时会报错,子类就得不到this对象。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。 export和importES6的模块化功能。以前这样写： //content.js module.exports = &#39;apple&#39;; //index.js var fruits = require(&#39;./content.js&#39;); console.log(fruits); //apple ES6这样： //content.js export default &#39;apple&#39;; //index.js import fruits from &#39;./content.js&#39;; console.log(fruits); //apple 深入点，看代码： //content.js export const KIND = &#39;Thailand Apple&#39;; export default &#39;apple&#39;; export function say(){ return &#39;I like apple!&#39;; } //index.js import fruits, { say, KIND } from &#39;./content.js&#39;; //如果只导入say //import { say } from &#39;./content.js&#39;; console.log(fruits); console.log(KIND); say(); //apple //Thailand Apple //I like apple! 修改变量名。 //content.js export const KIND = &#39;Thailand Apple&#39;; export default &#39;apple&#39;; export function say(){ return &#39;I like apple!&#39;; } //index.js import fruits, { say, KIND as type } from &#39;./content.js&#39;; console.log(fruits); console.log(type); say(); //apple //Thailand Apple //I like apple! 整体加载,*为指定的一个对象。 //content.js export const KIND = &#39;Thailand Apple&#39;; export default &#39;apple&#39;; export function say(){ return &#39;I like apple!&#39;; } //index.js import fruits, * as content from &#39;./content.js&#39;; console.log(fruits); console.log(content.type); content.say(); //apple //Thailand Apple //I like apple!","categories":[{"name":"ES6","slug":"ES6","permalink":"https://githubhaohao.github.io/categories/ES6/"}],"tags":[{"name":"ES6入门","slug":"ES6入门","permalink":"https://githubhaohao.github.io/tags/ES6入门/"}]},{"title":"分分钟接入Tinker","slug":"分分钟接入Tinker","date":"2017-01-18T01:23:38.000Z","updated":"2017-05-13T08:13:43.771Z","comments":true,"path":"2017/01/18/分分钟接入Tinker/","link":"","permalink":"https://githubhaohao.github.io/2017/01/18/分分钟接入Tinker/","excerpt":"","text":"Tinker是什么 Tinker是微信官方的Android热补丁解决方案，它支持动态下发代码、So库以及资源，让应用能够在不需要重新安装的情况下实现更新。当然，你也可以使用Tinker来更新你的插件。它主要包括以下几个部分： 1.gradle编译插件: tinker-patch-gradle-plugin 2.核心sdk库: tinker-android-lib 3.非gradle编译用户的命令行版本: tinker-patch-cli.jar 引入依赖和插件在你项目根目录下的 build.gradle 文件中添加: buildscript { dependencies { classpath (&#39;com.tencent.tinker:tinker-patch-gradle-plugin:1.7.6&#39;) } } 在 app/build.gradle 文件中添加依赖和插件： dependencies { //optional, help to generate the final application provided(&#39;com.tencent.tinker:tinker-android-anno:1.7.6&#39;) //tinker&#39;s main Android lib compile(&#39;com.tencent.tinker:tinker-android-lib:1.7.6&#39;) compile &quot;com.android.support:multidex:1.0.1&quot; } ... ... apply plugin: &#39;com.tencent.tinker.patch&#39; 添加task添加task tinkerPatch 在 app/build.gradle 文件中,其中 oldApk 路径为出现BUG的APK路径（自定义），添加完之后Async Project。 tinkerPatch { oldApk = &quot;J://tinkerSample/app-debug.apk&quot; ignoreWarning = true useSign = true buildConfig { applyMapping = null applyResourceMapping = null tinkerId = &quot;tinkerId&quot; } dex { dexMode = &quot;jar&quot; usePreGeneratedPatchDex = false pattern = [&quot;classes*.dex&quot;, &quot;assets/secondary-dex-?.jar&quot;] loader = [&quot;com.tencent.tinker.loader.*&quot;, &quot;com.jc.tinkersample.SimpleApp&quot;, &quot;com.jc.tinkersample.BaseBuildInfo&quot; ] } lib { pattern = [&quot;lib/armeabi/*.so&quot;] } res { pattern = [&quot;res/*&quot;, &quot;assets/*&quot;, &quot;resources.arsc&quot;, &quot;AndroidManifest.xml&quot;] ignoreChange = [&quot;assets/sample_meta.txt&quot;] largeModSize = 100 } packageConfig { configField(&quot;patchMessage&quot;, &quot;tinker is sample to use&quot;) configField(&quot;platform&quot;, &quot;all&quot;) configField(&quot;patchVersion&quot;, &quot;1.0&quot;) } sevenZip { zipArtifact = &quot;com.tencent.mm:SevenZip:1.1.10&quot; } } 接入Tinker自定义Application继承 DefaultApplicationLike 类，也可以自定义扩展。 @DefaultLifeCycle( application = &quot;com.jc.tinkersample.SimpleApp&quot;, flags = ShareConstants.TINKER_ENABLE_ALL, loadVerifyFlag = false ) public class SimpleAppLike extends DefaultApplicationLike { public SimpleAppLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag, long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent, Resources[] resources, ClassLoader[] classLoader, AssetManager[] assetManager) { super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent, resources, classLoader, assetManager); } @Override public void onBaseContextAttached(Context base) { super.onBaseContextAttached(base); MultiDex.install(base); TinkerInstaller.install(this); } @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) public void registerActivityLifecycleCallbacks(Application.ActivityLifecycleCallbacks callback) { getApplication().registerActivityLifecycleCallbacks(callback); } } 运行安装到你的手机里，然后把 app-debug.apk 放到 oldApk 对应的路径下，用于生成 patch.apk。 然后，修复你项目的bug（这里只是象征性地修改了一下Text），打开Android Studio 右侧的gradle project 运行 tinkerPatchDebug task生成patch.apk。 找到patch_signed_7zip.apk 文件。 复制 patch_signed_7zip.apk 文件把它放到手机外部存储目录下 （这里为根目录）。 String path = Environment.getExternalStorageDirectory().getAbsolutePath() + &quot;/patch_signed_7zip.apk&quot;; File file = new File(path); if (file.exists()){ Toast.makeText(this, &quot;patch.apk is existing.&quot;, Toast.LENGTH_SHORT).show(); TinkerInstaller.onReceiveUpgradePatch(getApplicationContext(), path); }else{ Toast.makeText(this,&quot;patch.apk is inexistent.&quot;, Toast.LENGTH_SHORT).show(); } 调用Tinker API TinkerInstaller.onReceiveUpgradePatch(getApplicationContext(), path); 进行热修复，重启app热修复完成。 详细代码https://github.com/githubhaohao/TinkerSample 更多 微信Android热补丁实践演进之路 Android N混合编译与对热补丁影响深度解析 微信Tinker的一切都在这里，包括源码","categories":[{"name":"Android","slug":"Android","permalink":"https://githubhaohao.github.io/categories/Android/"}],"tags":[{"name":"Tinker","slug":"Tinker","permalink":"https://githubhaohao.github.io/tags/Tinker/"}]},{"title":"Hello World","slug":"cover","date":"2017-01-12T08:31:23.971Z","updated":"2017-05-13T08:12:39.171Z","comments":true,"path":"2017/01/12/cover/","link":"","permalink":"https://githubhaohao.github.io/2017/01/12/cover/","excerpt":"","text":"合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。 不忘初心，不惧未来。haohao2017/01/14","categories":[],"tags":[]}]}