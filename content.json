{"meta":{"title":"haohao","subtitle":"不忘初心","description":"不忘初心","author":"haohao","url":"https://githubhaohao.github.io"},"pages":[{"title":"","date":"2017-01-14T01:08:49.684Z","updated":"2017-01-14T01:08:49.684Z","comments":true,"path":"404.html","permalink":"https://githubhaohao.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2017-01-20T03:02:23.125Z","updated":"2017-01-20T03:02:12.387Z","comments":true,"path":"baidu_verify_mlJIN34eq8.html","permalink":"https://githubhaohao.github.io/baidu_verify_mlJIN34eq8.html","excerpt":"","text":"mlJIN34eq8"},{"title":"","date":"2017-01-20T02:12:03.265Z","updated":"2017-01-20T02:11:46.875Z","comments":true,"path":"googlea9fee49d9b41dd58.html","permalink":"https://githubhaohao.github.io/googlea9fee49d9b41dd58.html","excerpt":"","text":"google-site-verification: googlea9fee49d9b41dd58.html"},{"title":"About","date":"2017-01-13T08:40:55.000Z","updated":"2017-01-14T02:04:19.512Z","comments":false,"path":"about/index.html","permalink":"https://githubhaohao.github.io/about/index.html","excerpt":"","text":"阳光温热，岁月静好。 haohao 不忘初心，不惧未来。"},{"title":"categories","date":"2017-01-13T09:50:33.000Z","updated":"2017-01-14T01:18:01.407Z","comments":false,"path":"categories/index.html","permalink":"https://githubhaohao.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-01-13T09:53:21.000Z","updated":"2017-01-14T01:53:27.154Z","comments":false,"path":"tags/index.html","permalink":"https://githubhaohao.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2017-04-21T00:56:48.078Z","updated":"2014-08-26T09:04:48.000Z","comments":true,"path":"custom/css/style.css","permalink":"https://githubhaohao.github.io/custom/css/style.css","excerpt":"","text":"/* Project: Hello World Personal Page Project URI: http://timpotter.github.io Author: Tim Potter Author URI: http://littlethunder.co */ /* Reset Browser Defaults*/ * { padding:0; margin: 0; } *, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; } /* Typography */ body { font-family: 'Roboto Slab', serif; font-weight: 300; color: #444; -webkit-font-smoothing: antialiased; } header { text-align: center; text-transform: uppercase; } header p { letter-spacing: 2px; font-weight: 300; } h1 { font-weight: 100; font-size: 3em; /* 48/16 */ margin-bottom: 40px; line-height: 1em; } p { line-height: 1.75em; } .about p:nth-of-type(1) { font-size: 1.5em; /* 24/16 */ line-height: 1.5em; } .about p { padding-bottom: 20px; text-align: justify; } footer p { text-align: center; font-size: 0.625em; /* 10/16 */ } small { text-align: center; } strong { font-weight: 400; } a { text-decoration: none; font-weight: 400; color: #333; } a:hover { text-decoration: underline; color: #666; } .social a { opacity: 0.3; transition: opacity .25s ease-in-out; -moz-transition: opacity .25s ease-in-out; -webkit-transition: opacity .25s ease-in-out; } .social a:hover { opacity: 0.8; } .social li { display: inline; margin: 5px; color: #444; } /* Images */ .background { /* Delete background class from for a vanilla style */ background: url(../images/background.jpg) top center no-repeat; } img.avatar { margin-bottom: 30px; border-radius: 50%; width: 125px; height: 125px; margin-top: -30px; } .social li img { width: 50px; } /* Layout */ .container { width: 600px; margin: 100px auto 25px; background-color: rgba(255, 255, 255, 0.5); padding: 0 60px 30px; border-radius: 6px; } .social { margin-top: 60px; text-align: center; } footer { margin-top: 30px; } /* Responsive Styles */ @media only screen and (min-width: 1920px) { .background { background-size: 100%; } } @media only screen and (max-width: 600px) { .container { width: 90%; margin-top: 50px; padding: 0 30px 30px; } h1 { font-size: 2.25em; /* 36/16 */ margin-bottom: 20px; } .social { margin-top: 20px; } .about p { text-align: left; padding-bottom: 15px; } .about p:nth-of-type(1) { font-size: 1.25em; /* 20/16 */ text-align: center; } }"}],"posts":[{"title":"Android 进程间通信方式","slug":"Android-进程间通信方式","date":"2017-04-27T11:05:29.000Z","updated":"2017-04-27T11:24:53.418Z","comments":true,"path":"2017/04/27/Android-进程间通信方式/","link":"","permalink":"https://githubhaohao.github.io/2017/04/27/Android-进程间通信方式/","excerpt":"","text":"做好眼前的事，保持专注 我们的大脑是串行结构，而非并行结构，你永远无法真正将自己的注意力同时放在两个任务之中。 Android 中的 IPC 方式使用 Intent Activity，Service，Receiver 都支持在 Intent 中传递 Bundle 数据，而 Bundle 实现了 Parcelable 接口，可以在不同的进程间进行传输。 在一个进程中启动了另一个进程的 Acyivity，Service 和 Receiver ，可以在 Bundle 中附加要传递的数据通过 Intent 发送出去。 使用文件共享 Windows 上，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读和写；而 Android 系统基于 Linux ，使得其并发读取文件没有限制地进行，甚至允许两个线程同时对一个文件进行读写操作，尽管这样可能会出问题。 可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（注意：并不是同一个对象，只是内容相同。）。 SharedPreferences 是个特例，系统对它的读 / 写有一定的缓存策略，即内存中会有一份 ShardPreferences 文件的缓存，系统对他的读 / 写就变得不可靠，当面对高并发的读写访问，SharedPreferences 有很多大的几率丢失数据。因此，IPC 不建议采用 SharedPreferences。 使用 MessengerMessenger 是一种轻量级的 IPC 方案，它的底层实现是 AIDL ，可以在不同进程中传递 Message 对象，它一次只处理一个请求，在服务端不需要考虑线程同步的问题，服务端不存在并发执行的情形。 服务端进程：服务端创建一个 Service 来处理客户端请求，同时通过一个 Handler 对象来实例化一个 Messenger 对象，然后在 Service 的 onBind 中返回这个 Messenger 对象底层的 Binder 即可。 123456789101112131415161718192021222324252627282930313233343536373839404142public class MessengerService extends Service &#123; private static final String TAG = MessengerService.class.getSimpleName(); private class MessengerHandler extends Handler &#123; /** * @param msg */ @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case Constants.MSG_FROM_CLIENT: Log.d(TAG, \"receive msg from client: msg = [\" + msg.getData().getString(Constants.MSG_KEY) + \"]\"); Toast.makeText(MessengerService.this, \"receive msg from client: msg = [\" + msg.getData().getString(Constants.MSG_KEY) + \"]\", Toast.LENGTH_SHORT).show(); Messenger client = msg.replyTo; Message replyMsg = Message.obtain(null, Constants.MSG_FROM_SERVICE); Bundle bundle = new Bundle(); bundle.putString(Constants.MSG_KEY, \"我已经收到你的消息，稍后回复你！\"); replyMsg.setData(bundle); try &#123; client.send(replyMsg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; break; default: super.handleMessage(msg); &#125; &#125; &#125; private Messenger mMessenger = new Messenger(new MessengerHandler()); @Nullable @Override public IBinder onBind(Intent intent) &#123; return mMessenger.getBinder(); &#125;&#125; 客户端进程：首先绑定服务端 Service ，绑定成功之后用服务端的 IBinder 对象创建一个 Messenger ，通过这个 Messenger 就可以向服务端发送消息了，消息类型是 Message 。如果需要服务端响应，则需要创建一个 Handler 并通过它来创建一个 Messenger（和服务端一样），并通过 Message 的 replyTo 参数传递给服务端。服务端通过 Message 的 replyTo 参数就可以回应客户端了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class MainActivity extends AppCompatActivity &#123; private static final String TAG = MainActivity.class.getSimpleName(); private Messenger mGetReplyMessenger = new Messenger(new MessageHandler()); private Messenger mService; private class MessageHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case Constants.MSG_FROM_SERVICE: Log.d(TAG, \"received msg form service: msg = [\" + msg.getData().getString(Constants.MSG_KEY) + \"]\"); Toast.makeText(MainActivity.this, \"received msg form service: msg = [\" + msg.getData().getString(Constants.MSG_KEY) + \"]\", Toast.LENGTH_SHORT).show(); break; default: super.handleMessage(msg); &#125; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void bindService(View v) &#123; Intent mIntent = new Intent(this, MessengerService.class); bindService(mIntent, mServiceConnection, Context.BIND_AUTO_CREATE); &#125; public void sendMessage(View v) &#123; Message msg = Message.obtain(null,Constants.MSG_FROM_CLIENT); Bundle data = new Bundle(); data.putString(Constants.MSG_KEY, \"Hello! This is client.\"); msg.setData(data); msg.replyTo = mGetReplyMessenger; try &#123; mService.send(msg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void onDestroy() &#123; unbindService(mServiceConnection); super.onDestroy(); &#125; private ServiceConnection mServiceConnection = new ServiceConnection() &#123; /** * @param name * @param service */ @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mService = new Messenger(service); Message msg = Message.obtain(null,Constants.MSG_FROM_CLIENT); Bundle data = new Bundle(); data.putString(Constants.MSG_KEY, \"Hello! This is client.\"); msg.setData(data); // msg.replyTo = mGetReplyMessenger; try &#123; mService.send(msg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; /** * @param name */ @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;;&#125; 注意：客户端和服务端是通过拿到对方的 Messenger 来发送 Message 的。只不过客户端通过 bindService onServiceConnected 而服务端通过 message.replyTo 来获得对方的 Messenger 。Messenger 中有一个 Hanlder 以串行的方式处理队列中的消息。不存在并发执行，因此我们不用考虑线程同步的问题。 图片来自《Android 开发艺术探索》 使用 AIDLMessenger 是以串行的方式处理客户端发来的消息，如果大量消息同时发送到服务端，服务端只能一个一个处理，所以大量并发请求就不适合用 Messenger ，而且 Messenger 只适合传递消息，不能跨进程调用服务端的方法。AIDL 可以解决并发和跨进程调用方法的问题，要知道 Messenger 本质上也是 AIDL ，只不过系统做了封装方便上层的调用而已。 AIDL 文件支持的数据类型 基本数据类型； String 和 CharSequence ArrayList ，里面的元素必须能够被 AIDL 支持； HashMap ，里面的元素必须能够被 AIDL 支持； Parcelable ，实现 Parcelable 接口的对象；注意：如果 AIDL 文件中用到了自定义的 Parcelable 对象，必须新建一个和它同名的 AIDL 文件。 AIDL ，AIDL 接口本身也可以在 AIDL 文件中使用。 服务端服务端创建一个 Service 用来监听客户端的连接请求，然后创建一个 AIDL 文件，将暴露给客户端的接口在这个 AIDL 文件中声明，最后在 Service 中实现这个 AIDL 接口即可。 客户端绑定服务端的 Service ，绑定成功后，将服务端返回的 Binder 对象转成 AIDL 接口所属的类型，然后就可以调用 AIDL 中的方法了。客户端调用远程服务的方法，被调用的方法运行在服务端的 Binder 线程池中，同时客户端的线程会被挂起，如果服务端方法执行比较耗时，就会导致客户端线程长时间阻塞，导致 ANR 。客户端的 onServiceConnected 和 onServiceDisconnected 方法都在 UI 线程中。 服务端访问权限管理 使用 Permission 验证，在 manifest 中声明 123&lt;permission android:name=\"com.jc.ipc.ACCESS_BOOK_SERVICE\" android:protectionLevel=\"normal\"/&gt;&lt;uses-permission android:name=\"com.jc.ipc.ACCESS_BOOK_SERVICE\"/&gt; 服务端 onBinder 方法中 123456789public IBinder onBind(Intent intent) &#123; //Permission 权限验证 int check = checkCallingOrSelfPermission(\"com.jc.ipc.ACCESS_BOOK_SERVICE\"); if (check == PackageManager.PERMISSION_DENIED) &#123; return null; &#125; return mBinder;&#125; Pid Uid 验证 详细代码：1234// Book.aidlpackage com.jc.ipc.aidl;parcelable Book; 123456789101112131415161718192021// IBookManager.aidlpackage com.jc.ipc.aidl;import com.jc.ipc.aidl.Book;import com.jc.ipc.aidl.INewBookArrivedListener;// AIDL 接口中只支持方法，不支持静态常量，区别于传统的接口interface IBookManager &#123; List&lt;Book&gt; getBookList(); // AIDL 中除了基本数据类型，其他数据类型必须标上方向,in,out 或者 inout // in 表示输入型参数 // out 表示输出型参数 // inout 表示输入输出型参数 void addBook(in Book book); void registerListener(INewBookArrivedListener listener); void unregisterListener(INewBookArrivedListener listener);&#125; 123456789// INewBookArrivedListener.aidlpackage com.jc.ipc.aidl;import com.jc.ipc.aidl.Book;// 提醒客户端新书到来interface INewBookArrivedListener &#123; void onNewBookArrived(in Book newBook);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class BookManagerActivity extends AppCompatActivity &#123; private static final String TAG = BookManagerActivity.class.getSimpleName(); private static final int MSG_NEW_BOOK_ARRIVED = 0x10; private Button getBookListBtn,addBookBtn; private TextView displayTextView; private IBookManager bookManager; private Handler mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_NEW_BOOK_ARRIVED: Log.d(TAG, \"handleMessage: new book arrived \" + msg.obj); Toast.makeText(BookManagerActivity.this, \"new book arrived \" + msg.obj, Toast.LENGTH_SHORT).show(); break; default: super.handleMessage(msg); &#125; &#125; &#125;; private ServiceConnection mServiceConn = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; bookManager = IBookManager.Stub.asInterface(service); try &#123; bookManager.registerListener(listener); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; private INewBookArrivedListener listener = new INewBookArrivedListener.Stub() &#123; @Override public void onNewBookArrived(Book newBook) throws RemoteException &#123; mHandler.obtainMessage(MSG_NEW_BOOK_ARRIVED, newBook).sendToTarget(); &#125; &#125;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.book_manager); displayTextView = (TextView) findViewById(R.id.displayTextView); Intent intent = new Intent(this, BookManagerService.class); bindService(intent, mServiceConn, BIND_AUTO_CREATE); &#125; public void getBookList(View view) &#123; try &#123; List&lt;Book&gt; list = bookManager.getBookList(); Log.d(TAG, \"getBookList: \" + list.toString()); displayTextView.setText(list.toString()); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; public void addBook(View view) &#123; try &#123; bookManager.addBook(new Book(3, \"天龙八部\")); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void onDestroy() &#123; if (bookManager != null &amp;&amp; bookManager.asBinder().isBinderAlive()) &#123; Log.d(TAG, \"unregister listener \" + listener); try &#123; bookManager.unregisterListener(listener); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; unbindService(mServiceConn); super.onDestroy(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public class BookManagerService extends Service &#123; private static final String TAG = BookManagerService.class.getSimpleName(); // CopyOnWriteArrayList 支持并发读写，实现自动线程同步，他不是继承自 ArrayList private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;Book&gt;(); //对象是不能跨进程传输的，对象的跨进程传输本质都是反序列化的过程，Binder 会把客户端传递过来的对象重新转化生成一个新的对象 //RemoteCallbackList 是系统专门提供的用于删除系统跨进程 listener 的接口，利用底层的 Binder 对象是同一个 //RemoteCallbackList 会在客户端进程终止后，自动溢出客户端注册的 listener ，内部自动实现了线程同步功能。 private RemoteCallbackList&lt;INewBookArrivedListener&gt; mListeners = new RemoteCallbackList&lt;&gt;(); private AtomicBoolean isServiceDestroied = new AtomicBoolean(false); private Binder mBinder = new IBookManager.Stub() &#123; @Override public List&lt;Book&gt; getBookList() throws RemoteException &#123; return mBookList; &#125; @Override public void addBook(Book book) throws RemoteException &#123; Log.d(TAG, \"addBook: \" + book.toString()); mBookList.add(book); &#125; @Override public void registerListener(INewBookArrivedListener listener) throws RemoteException &#123; mListeners.register(listener); &#125; @Override public void unregisterListener(INewBookArrivedListener listener) throws RemoteException &#123; mListeners.unregister(listener); &#125; &#125;; @Override public void onCreate() &#123; super.onCreate(); mBookList.add(new Book(1, \"老人与海\")); mBookList.add(new Book(2, \"哈姆雷特\")); new Thread(new ServiceWorker()).start(); &#125; private void onNewBookArrived(Book book) throws RemoteException &#123; mBookList.add(book); int count = mListeners.beginBroadcast(); for (int i = 0; i &lt; count; i++) &#123; INewBookArrivedListener listener = mListeners.getBroadcastItem(i); if (listener != null) &#123; listener.onNewBookArrived(book); &#125; &#125; mListeners.finishBroadcast(); &#125; private class ServiceWorker implements Runnable &#123; @Override public void run() &#123; while (!isServiceDestroied.get()) &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; int bookId = mBookList.size() +1; Book newBook = new Book(bookId, \"new book # \" + bookId); try &#123; onNewBookArrived(newBook); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; //Permission 权限验证 int check = checkCallingOrSelfPermission(\"com.jc.ipc.ACCESS_BOOK_SERVICE\"); if (check == PackageManager.PERMISSION_DENIED) &#123; return null; &#125; return mBinder; &#125; @Override public void onDestroy() &#123; isServiceDestroied.set(true); super.onDestroy(); &#125;&#125; 使用 ContentProvider用于不同应用间数据共享，和 Messenger 底层实现同样是 Binder 和 AIDL，系统做了封装，使用简单。系统预置了许多 ContentProvider ，如通讯录、日程表，需要跨进程访问。使用方法：继承 ContentProvider 类实现 6 个抽象方法，这六个方法均运行在 ContentProvider 进程中，除 onCreate 运行在主线程里，其他五个方法均由外界回调运行在 Binder 线程池中。 ContentProvider 的底层数据，可以是 SQLite 数据库，可以是文件，也可以是内存中的数据。 详见代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119public class BookProvider extends ContentProvider &#123; private static final String TAG = \"BookProvider\"; public static final String AUTHORITY = \"com.jc.ipc.Book.Provider\"; public static final Uri BOOK_CONTENT_URI = Uri.parse(\"content://\" + AUTHORITY + \"/book\"); public static final Uri USER_CONTENT_URI = Uri.parse(\"content://\" + AUTHORITY + \"/user\"); public static final int BOOK_URI_CODE = 0; public static final int USER_URI_CODE = 1; private static final UriMatcher sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH); static &#123; sUriMatcher.addURI(AUTHORITY, \"book\", BOOK_URI_CODE); sUriMatcher.addURI(AUTHORITY, \"user\", USER_URI_CODE); &#125; private Context mContext; private SQLiteDatabase mDB; @Override public boolean onCreate() &#123; mContext = getContext(); initProviderData(); return true; &#125; private void initProviderData() &#123; //不建议在 UI 线程中执行耗时操作 mDB = new DBOpenHelper(mContext).getWritableDatabase(); mDB.execSQL(\"delete from \" + DBOpenHelper.BOOK_TABLE_NAME); mDB.execSQL(\"delete from \" + DBOpenHelper.USER_TABLE_NAME); mDB.execSQL(\"insert into book values(3,'Android');\"); mDB.execSQL(\"insert into book values(4,'iOS');\"); mDB.execSQL(\"insert into book values(5,'Html5');\"); mDB.execSQL(\"insert into user values(1,'haohao',1);\"); mDB.execSQL(\"insert into user values(2,'nannan',0);\"); &#125; @Nullable @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; Log.d(TAG, \"query, current thread\"+ Thread.currentThread()); String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException(\"Unsupported URI\" + uri); &#125; return mDB.query(table, projection, selection, selectionArgs, null, null, sortOrder, null); &#125; @Nullable @Override public String getType(Uri uri) &#123; Log.d(TAG, \"getType\"); return null; &#125; @Nullable @Override public Uri insert(Uri uri, ContentValues values) &#123; Log.d(TAG, \"insert\"); String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException(\"Unsupported URI\" + uri); &#125; mDB.insert(table, null, values); // 通知外界 ContentProvider 中的数据发生变化 mContext.getContentResolver().notifyChange(uri, null); return uri; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; Log.d(TAG, \"delete\"); String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException(\"Unsupported URI\" + uri); &#125; int count = mDB.delete(table, selection, selectionArgs); if (count &gt; 0) &#123; mContext.getContentResolver().notifyChange(uri, null); &#125; return count; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; Log.d(TAG, \"update\"); String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException(\"Unsupported URI\" + uri); &#125; int row = mDB.update(table, values, selection, selectionArgs); if (row &gt; 0) &#123; getContext().getContentResolver().notifyChange(uri, null); &#125; return row; &#125; private String getTableName(Uri uri) &#123; String tableName = null; switch (sUriMatcher.match(uri)) &#123; case BOOK_URI_CODE: tableName = DBOpenHelper.BOOK_TABLE_NAME; break; case USER_URI_CODE: tableName = DBOpenHelper.USER_TABLE_NAME; break; default: break; &#125; return tableName; &#125;&#125; 123456789101112131415161718192021222324252627282930313233public class DBOpenHelper extends SQLiteOpenHelper &#123; private static final String DB_NAME = \"book_provider.db\"; public static final String BOOK_TABLE_NAME = \"book\"; public static final String USER_TABLE_NAME = \"user\"; private static final int DB_VERSION = 1; private String CREATE_BOOK_TABLE = \"CREATE TABLE IF NOT EXISTS \" + BOOK_TABLE_NAME + \"(_id INTEGER PRIMARY KEY,\" + \"name TEXT)\"; private String CREATE_USER_TABLE = \"CREATE TABLE IF NOT EXISTS \" + USER_TABLE_NAME + \"(_id INTEGER PRIMARY KEY,\" + \"name TEXT,\" + \"sex INT)\"; public DBOpenHelper(Context context) &#123; super(context, DB_NAME, null, DB_VERSION); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL(CREATE_BOOK_TABLE); db.execSQL(CREATE_USER_TABLE); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class ProviderActivity extends AppCompatActivity &#123; private static final String TAG = ProviderActivity.class.getSimpleName(); private TextView displayTextView; private Handler mHandler; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_provider); displayTextView = (TextView) findViewById(R.id.displayTextView); mHandler = new Handler(); getContentResolver().registerContentObserver(BookProvider.BOOK_CONTENT_URI, true, new ContentObserver(mHandler) &#123; @Override public boolean deliverSelfNotifications() &#123; return super.deliverSelfNotifications(); &#125; @Override public void onChange(boolean selfChange) &#123; super.onChange(selfChange); &#125; @Override public void onChange(boolean selfChange, Uri uri) &#123; Toast.makeText(ProviderActivity.this, uri.toString(), Toast.LENGTH_SHORT).show(); super.onChange(selfChange, uri); &#125; &#125;); &#125; public void insert(View v) &#123; ContentValues values = new ContentValues(); values.put(\"_id\",1123); values.put(\"name\", \"三国演义\"); getContentResolver().insert(BookProvider.BOOK_CONTENT_URI, values); &#125; public void delete(View v) &#123; getContentResolver().delete(BookProvider.BOOK_CONTENT_URI, \"_id = 4\", null); &#125; public void update(View v) &#123; ContentValues values = new ContentValues(); values.put(\"_id\",1123); values.put(\"name\", \"三国演义新版\"); getContentResolver().update(BookProvider.BOOK_CONTENT_URI, values , \"_id = 1123\", null); &#125; public void query(View v) &#123; Cursor bookCursor = getContentResolver().query(BookProvider.BOOK_CONTENT_URI, new String[]&#123;\"_id\", \"name\"&#125;, null, null, null); StringBuilder sb = new StringBuilder(); while (bookCursor.moveToNext()) &#123; Book book = new Book(bookCursor.getInt(0),bookCursor.getString(1)); sb.append(book.toString()).append(\"\\n\"); &#125; sb.append(\"--------------------------------\").append(\"\\n\"); bookCursor.close(); Cursor userCursor = getContentResolver().query(BookProvider.USER_CONTENT_URI, new String[]&#123;\"_id\", \"name\", \"sex\"&#125;, null, null, null); while (userCursor.moveToNext()) &#123; sb.append(userCursor.getInt(0)) .append(userCursor.getString(1)).append(\" ,\") .append(userCursor.getInt(2)).append(\" ,\") .append(\"\\n\"); &#125; sb.append(\"--------------------------------\"); userCursor.close(); displayTextView.setText(sb.toString()); &#125;&#125; 使用 Socket Socket起源于 Unix，而 Unix 基本哲学之一就是“一切皆文件”，都可以用“打开 open –读写 write/read –关闭 close ”模式来操作。Socket 就是该模式的一个实现，网络的 Socket 数据传输是一种特殊的 I/O，Socket 也是一种文件描述符。Socket 也具有一个类似于打开文件的函数调用： Socket()，该函数返回一个整型的Socket 描述符，随后的连接建立、数据传输等操作都是通过该 Socket 实现的。 常用的 Socket 类型有两种：流式 Socket（SOCK_STREAM）和数据报式 Socket（SOCK_DGRAM）。流式是一种面向连接的 Socket，针对于面向连接的 TCP 服务应用；数据报式 Socket 是一种无连接的 Socket ，对应于无连接的 UDP 服务应用。 Socket 本身可以传输任意字节流。 谈到Socket，就必须要说一说五层网络模型： 应用层：规定应用程序的数据格式，主要的协议 HTTP，FTP，WebSocket； 传输层：建立“端口到端口” 的通信，主要的协议：TCP，UDP； 网络层：建立”主机到主机”的通信，主要的协议：IP，ARP 。IP 协议的主要作用：一个是为每一台计算机分配 IP 地址，另一个是确定哪些地址在同一个子网络； 数据链路层：确定电信号的分组方式，主要的协议：以太网协议； 物理层：负责电信号的传输。 Socket 是连接应用层与传输层之间接口（API）。 图片来自网络 只实现 TCP Socket 。Client 端代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122public class TCPClientActivity extends AppCompatActivity implements View.OnClickListener&#123; private static final String TAG = \"TCPClientActivity\"; public static final int MSG_RECEIVED = 0x10; public static final int MSG_READY = 0x11; private EditText editText; private TextView textView; private PrintWriter mPrintWriter; private Socket mClientSocket; private Button sendBtn; private StringBuilder stringBuilder; private Handler mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_READY: sendBtn.setEnabled(true); break; case MSG_RECEIVED: stringBuilder.append(msg.obj).append(\"\\n\"); textView.setText(stringBuilder.toString()); break; default: super.handleMessage(msg); &#125; &#125; &#125;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.tcp_client_activity); editText = (EditText) findViewById(R.id.editText); textView = (TextView) findViewById(R.id.displayTextView); sendBtn = (Button) findViewById(R.id.sendBtn); sendBtn.setOnClickListener(this); sendBtn.setEnabled(false); stringBuilder = new StringBuilder(); Intent intent = new Intent(TCPClientActivity.this, TCPServerService.class); startService(intent); new Thread()&#123; @Override public void run() &#123; connectTcpServer(); &#125; &#125;.start(); &#125; private String formatDateTime(long time) &#123; return new SimpleDateFormat(\"(HH:mm:ss)\").format(new Date(time)); &#125; private void connectTcpServer() &#123; Socket socket = null; while (socket == null) &#123; try &#123; socket = new Socket(\"localhost\", 8888); mClientSocket = socket; mPrintWriter = new PrintWriter(new BufferedWriter( new OutputStreamWriter(socket.getOutputStream()) ), true); mHandler.sendEmptyMessage(MSG_READY); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // receive message BufferedReader bufferedReader = null; try &#123; bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; while (!isFinishing()) &#123; try &#123; String msg = bufferedReader.readLine(); if (msg != null) &#123; String time = formatDateTime(System.currentTimeMillis()); String showedMsg = \"server \" + time + \":\" + msg + \"\\n\"; mHandler.obtainMessage(MSG_RECEIVED, showedMsg).sendToTarget(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void onClick(View v) &#123; if (mPrintWriter != null) &#123; String msg = editText.getText().toString(); mPrintWriter.println(msg); editText.setText(\"\"); String time = formatDateTime(System.currentTimeMillis()); String showedMsg = \"self \" + time + \":\" + msg + \"\\n\"; stringBuilder.append(showedMsg); &#125; &#125; @Override protected void onDestroy() &#123; if (mClientSocket != null) &#123; try &#123; mClientSocket.shutdownInput(); mClientSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; super.onDestroy(); &#125;&#125; Server 端代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class TCPServerService extends Service &#123; private static final String TAG = \"TCPServerService\"; private boolean isServiceDestroyed = false; private String[] mMessages = new String[]&#123; \"Hello! Body!\", \"用户不在线！请稍后再联系！\", \"请问你叫什么名字呀？\", \"厉害了，我的哥！\", \"Google 不需要科学上网是真的吗？\", \"扎心了，老铁！！！\" &#125;; @Override public void onCreate() &#123; new Thread(new TCPServer()).start(); super.onCreate(); &#125; @Override public void onDestroy() &#123; isServiceDestroyed = true; super.onDestroy(); &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125; private class TCPServer implements Runnable &#123; @Override public void run() &#123; ServerSocket serverSocket = null; try &#123; serverSocket = new ServerSocket(8888); &#125; catch (IOException e) &#123; e.printStackTrace(); return; &#125; while (!isServiceDestroyed) &#123; // receive request from client try &#123; final Socket client = serverSocket.accept(); Log.d(TAG, \"=============== accept ==================\"); new Thread()&#123; @Override public void run() &#123; try &#123; responseClient(client); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;.start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; private void responseClient(Socket client) throws IOException &#123; //receive message BufferedReader in = new BufferedReader( new InputStreamReader(client.getInputStream())); //send message PrintWriter out = new PrintWriter( new BufferedWriter( new OutputStreamWriter( client.getOutputStream())),true); out.println(\"欢迎来到聊天室！\"); while (!isServiceDestroyed) &#123; String str = in.readLine(); Log.d(TAG, \"message from client: \" + str); if (str == null) &#123; return; &#125; Random random = new Random(); int index = random.nextInt(mMessages.length); String msg = mMessages[index]; out.println(msg); Log.d(TAG, \"send Message: \" + msg); &#125; out.close(); in.close(); client.close(); &#125;&#125; 演示： UDP Socket 可以自己尝试着实现。","categories":[{"name":"Android","slug":"Android","permalink":"https://githubhaohao.github.io/categories/Android/"}],"tags":[{"name":"IPC","slug":"IPC","permalink":"https://githubhaohao.github.io/tags/IPC/"}]},{"title":"Android 多线程实现方式","slug":"Android-多线程实现方式","date":"2017-04-22T08:04:55.000Z","updated":"2017-04-26T01:12:07.417Z","comments":true,"path":"2017/04/22/Android-多线程实现方式/","link":"","permalink":"https://githubhaohao.github.io/2017/04/22/Android-多线程实现方式/","excerpt":"","text":"只为初心 一个优秀的程序员，必须具备两种能力： 学习能力 时间管理能力 Android 多线程实现方式通常来说，一个应用至少有一个进程，而一个进程至少有一个线程。线程是 CPU 调度的基本单位，进程是系统资源分配的基本单位。进程独享内存资源，一个进程可以看作一个 JVM ，一个进程崩溃后，在保护模式下一般不会对其它进程产生影响。同一个进程中的线程共享内存资源，一个线程死掉就导致整个进程死掉。行了，进程和线程就扯嫩忙多。Android 提供了四种常用的多线程实现方式： AsyncTask 异步消息处理机制 IntentService ThreadPoolExcutor AsyncTask我们的老朋友 AsyncTask 类，它是封装好的线程池，操作 UI 线程极其方便。 瞅一眼，AsyncTask 的三个泛型参数： public abstract class AsyncTask&lt;Params, Progress, Result&gt; params ，传入参数类型，即 doInBackground() 方法中的参数类型; Progress ，异步任务执行过程中返回的任务执行进度类型，即 publishProgress() 和onProgressUpdate() 方法中传入的参数类型； Result ，异步任务执行完返回的结果类型，即 doInBackground() 方法中返回值的类型。 四个回调方法： onPreExecute()，在主线程执行，做一些准备工作。 doInBackground()，在线程池中执行，该方法是抽象方法，在此方法中可以调用 publishProgress() 更新任务进度。 onProgressUpdate()，在主线程中执行，在 publishProgress() 调用之后被回调，展示任务进度。 onPostExecute()，在主线程中执行，异步任务结束后，回调此方法，处理返回结果。 注意： 当 AsyncTask 任务被取消时，回调 onCanceled() ，此时 onPostExecute()，不会被调用，AsyncTask 中的 cancel() 方法并不是真正去取消任务，只是设置这个任务为取消状态，需要在 doInBackground() 中通过 isCancelled() 判断终止任务。 AsyncTask 必须在主线程中创建实例，execute() 方法也必须在主线程中调用。 每个 AsyncTask 实例只能执行一次 execute() ，多次执行会报错，如需执行多次，则需创建多个实例。 AsyncTask 用的是线程池机制，容量是 128 ，全局线程池只有 5 个工作线程，如果运用 AsyncTask 对象来执行多个异步任务，那么同一时间最多只能有 5 个线程同时运行，其他线程将被阻塞。 异步消息处理机制异步消息处理机制的三大主角： Handler ，Message 和 Looper 。Looper 负责创建 MessageQueue 消息对列，然后进入一个无限 for 循环中，不断地从消息队列中取消息，如果消息队列为空，当前线程阻塞，Handler 负责向消息队列中发送消息。 LooperLooper 有两个重要的方法： prepare() 和 loop()。 prepare() ， Looper 与当前线程绑定，一个线程只能有一个 Looper 实例和一个 MessageQueue 实例。 12345678910111213public static final void prepare() &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(true));&#125;//Looper 的构造方法private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mRun = true; mThread = Thread.currentThread();&#125; loop ，进入一个无限 for 循环体中，不断地从消息队列中取消息，然后交给消息的 target 属性的 dispatchMessage 方法去处理。 12345678910111213141516171819202122232425public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; msg.target.dispatchMessage(msg); msg.recycle(); &#125;&#125; HandlerHandler 负责向消息队列中发送消息。在 Activity 中我们直接可以 new Handler ，那是因为在 Activity 的启动代码中，已经在当前 UI 线程中调用了 Looper.prepare() 和 Looper.loop() 方法。 在子线程中 new Handler 必须要在当前线程中创建好 Looper对象 和消息队列，代码如下 1234567891011121314&#123; //在子线程中 Looper.prepare(); handler = new Handler() &#123; public void handleMessage(Message msg) &#123; //处理消息 &#125;; &#125;; Looper.loop(); &#125; HandlerThreadHandlerThread 可以看作在子线程中创建一个异步消息处理机制的简化版，HandlerThread 对象自动帮我们创建 Looper 对象和消息队列。 12345678910mHandlerThread = new HandlerThread(\"MyHandlerThread\");mHandlerThread.start();mHandler = new Handler(mHandlerThread.getLooper())&#123; @Override public void handleMessage(Message msg) &#123; //处理消息 &#125;&#125;; 看一下代码片段：1234567891011121314151617181920212223242526272829303132333435363738394041424344public class HandlerThread extends Thread &#123; int mPriority; int mTid = -1; Looper mLooper; public HandlerThread(String name) &#123; super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT; &#125; protected void onLooperPrepared() &#123; &#125; @Override public void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; &#125; public Looper getLooper() &#123; if (!isAlive()) &#123; return null; &#125; // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper; &#125;&#125; 注意：handler 在 UI 线程中初始化的，looper 在一个子线程中执行，我们必须等 mLooper 创建完成之后，才能调用 getLooper ，源码中是通过 wait 和 notify 解决两个线程的同步问题。 IntentService","categories":[{"name":"Android","slug":"Android","permalink":"https://githubhaohao.github.io/categories/Android/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://githubhaohao.github.io/tags/多线程/"}]},{"title":"Android Clean 架构浅析","slug":"Android-Clean-架构浅析","date":"2017-04-15T13:07:34.000Z","updated":"2017-04-20T13:58:54.717Z","comments":true,"path":"2017/04/15/Android-Clean-架构浅析/","link":"","permalink":"https://githubhaohao.github.io/2017/04/15/Android-Clean-架构浅析/","excerpt":"","text":"死磕 Android 架构也是一种娱乐 Android 常用的架构主要有 MVC，MVP，MVVM 以及 Clean 。以上架构设计模式没有绝对的优劣之分，关键要看具体的应用场景。更多关于 MVC，MVP 以及 MVVM 介绍可以参考MVC,MVP &amp; MVVM 什么是 Clean 架构？ Robert C. Martin (Uncle Bob) Clean 架构是由 Uncle Bob 在 2012 年发表的, 针对 Web App 的架构设计。 Bob大叔总结了各种系统架构的共通之处以及最终目标，并提出只需秉持分层与依赖规则的原则, 提出了 Clean 架构思想。 Clean 架构浅析单向依赖 图片来自 Robert C. Martin (Uncle Bob) Clean 架构各层之间的依赖是单向的，只能是外层依赖内层。 MVP VS Clean 图片来自 Google 从上图可以看到 Clean 架构的 Android 实现，实际上是对目前比较流行的 MVP 架构进行改造。 MVP 之 View 和 Presenter 层作为 Clean 架构的 Presentations Layer, 新增 Domain Layer 处理所有的业务逻辑。MVP 中的 Model 层功能被弱化，作为 Data Layer 对外只提供接口，不再有业务逻辑。 一般来说每一层都有独立的数据模型。 Clean 之 Presentation 层包含如下类： Presenter 和 View 层相关类，当然你也可以在 MVVP 架构基础之上进行改造。 Mapper 类，负责将 Domain 层的数据模型转换为 Presentation 的数据模型。 本层的异常封装类。 Clean 之 Domain 层Domain 层不依赖于 Android 类库和第三方库，可以独立做单元测试。 包含如下类： Use Cases (Interactor）类，负责完成对 Data 层的某一操作行为。（如获取 movie list ,获取某一 movie 的 detail info 可视为 2 个 Use Case 或 Interactor）。 Mapper 类，负责将 Data 层的数据模型转换为 Domain 层的数据模型。 本层的异常封装类。 Clean 之 Data 层 图片来自 Robert C. Martin (Uncle Bob) 这张图就足够说明一切了。 包含各种 API 接口，主要对应数据库操作，文件操作以及网络数据操作，一些异常封装类。Mapper 类，负责将网络数据模型转换为 Data 层的数据模型。 注意 Data 层只提供接口，没有业务逻辑。 更多 https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean/ https://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/","categories":[{"name":"Android","slug":"Android","permalink":"https://githubhaohao.github.io/categories/Android/"}],"tags":[{"name":"Clean 架构","slug":"Clean-架构","permalink":"https://githubhaohao.github.io/tags/Clean-架构/"}]},{"title":"RecyclerView 加载与刷新功能实现","slug":"RecyclerView-加载与刷新功能实现","date":"2017-04-13T10:30:00.000Z","updated":"2017-04-20T14:02:06.756Z","comments":true,"path":"2017/04/13/RecyclerView-加载与刷新功能实现/","link":"","permalink":"https://githubhaohao.github.io/2017/04/13/RecyclerView-加载与刷新功能实现/","excerpt":"","text":"坚持就是进步 最近 Kotlin Android 开发貌似要火起来，Kotlin 具有脚本语言风格，能与 Java 无缝兼容，并且有 Google 有意栽培。 RecyclerView 加载与刷新功能实现RecyclerView 功能及灵活性强大到令人发指。在开发中，完全可以用它代替 ListView 和 GridView ，并且还具有瀑布流展示功能。 本文主要对 RecyclerView 进行简单的封装，来实现加载、刷新以及异常状态展示多种功能，实现及其简单，代码量很少。 效果展示 Demo 下载 源码地址: https://github.com/githubhaohao/JCRecyclerView 具体实现JCRecyclerView 继承 RecyclerView ，保留 RecyclerView 的所有特性。 内部类 JCAdapter 对外部的 RecyclerView Adapter 进行拦截改造，实现根据配置在 position = 0 的位置加载 Ad-Slot View （广告位），加载时在底部显示 Bottom View 表视加载正在进行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112private class JCAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; &#123; private RecyclerView.Adapter adapter; private static final int TYPE_ADSLOT = 0x10; private static final int TYPE_NORMAL = 0x11; private static final int TYPE_BOTTOM = 0x12; public JCAdapter(RecyclerView.Adapter adapter) &#123; this.adapter = adapter; &#125; @Override public void onViewAttachedToWindow(ViewHolder holder) &#123; super.onViewAttachedToWindow(holder); ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams(); if(layoutParams != null)&#123; if(adSlotView != null) &#123; if(layoutParams instanceof StaggeredGridLayoutManager.LayoutParams &amp;&amp; holder.getLayoutPosition() == 0)&#123; StaggeredGridLayoutManager.LayoutParams p = (StaggeredGridLayoutManager.LayoutParams) layoutParams; p.setFullSpan(true); &#125; &#125; if (bottomView != null &amp;&amp; isLoading) &#123; if(layoutParams instanceof StaggeredGridLayoutManager.LayoutParams &amp;&amp; holder.getLayoutPosition() == getItemCount() - 1)&#123; StaggeredGridLayoutManager.LayoutParams p = (StaggeredGridLayoutManager.LayoutParams) layoutParams; p.setFullSpan(true); &#125; &#125; &#125; if (layoutManager instanceof GridLayoutManager) &#123; final GridLayoutManager gridManager = ((GridLayoutManager) layoutManager); gridManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() &#123; @Override public int getSpanSize(int position) &#123; boolean spanResult = false; if(adSlotView != null &amp;&amp; bottomView != null) &#123; if (isLoading) &#123; spanResult = (position == 0 || position == getItemCount() - 1); &#125; else &#123; spanResult = (position == 0); &#125; &#125; else if (adSlotView != null) &#123; spanResult = (position==0); &#125; else if (bottomView != null &amp;&amp; isLoading) &#123; spanResult = (position == getItemCount() - 1); &#125; return spanResult ? gridManager.getSpanCount():1; &#125; &#125;); &#125; &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; if (viewType == TYPE_ADSLOT) &#123; return new JCViewHolder(adSlotView); &#125; else if (viewType == TYPE_BOTTOM) &#123; return new JCViewHolder(bottomView); &#125; return adapter.onCreateViewHolder(parent,viewType); &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; if (getItemViewType(0) == TYPE_ADSLOT) &#123; if (position == 0) return; int newPosition = --position; if (adapter != null) &#123; if (newPosition &lt; adapter.getItemCount()) &#123; adapter.onBindViewHolder(holder, newPosition); &#125; &#125; return; &#125; else if (getItemViewType(position) == TYPE_BOTTOM) &#123; return; &#125; adapter.onBindViewHolder(holder, position); &#125; @Override public int getItemCount() &#123; int count = adapter.getItemCount(); if (adSlotView != null) &#123; count ++; &#125; if (bottomView != null &amp;&amp; isLoading) &#123; count ++; &#125; return count; &#125; @Override public int getItemViewType(int position) &#123; if (position == 0) &#123; return adSlotView == null ? TYPE_NORMAL : TYPE_ADSLOT; &#125; else if (position == getItemCount() - 1 &amp;&amp; isLoading) &#123; return bottomView == null ? TYPE_NORMAL : TYPE_BOTTOM; &#125; else &#123; return TYPE_NORMAL; &#125; &#125;&#125; 向外暴露一个接口 OnLoadMoreListener ，完成加载时的回调。123public interface OnLoadMoreListener &#123; void onLoadMore();&#125; 整体思路就是这些，完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268public class JCRecyclerView extends RecyclerView &#123; private static final String TAG = JCRecyclerView.class.getSimpleName(); private LayoutManager layoutManager; private ViewGroup adSlotView; private ViewGroup stateView; private ViewGroup bottomView; private boolean isLoading = false; private JCAdapter jcAdapter; private OnLoadMoreListener onLoadMoreListener; public void addOnLoadMoreListener(OnLoadMoreListener listener) &#123; this.onLoadMoreListener = listener; this.addOnScrollListener(new OnScrollListener() &#123; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; if (recyclerView.getLayoutManager() instanceof StaggeredGridLayoutManager) &#123; StaggeredGridLayoutManager layoutManager = (StaggeredGridLayoutManager) recyclerView.getLayoutManager(); int totalItemCount = recyclerView.getAdapter().getItemCount(); int[] lastVisibleItemPositions = new int[layoutManager.getSpanCount()]; layoutManager.findLastVisibleItemPositions(lastVisibleItemPositions); int visibleItemCount = recyclerView.getChildCount(); int lastVisibleItemPosition = findMaxPosition(lastVisibleItemPositions); if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; lastVisibleItemPosition == totalItemCount - 1 &amp;&amp; visibleItemCount &gt; 0) &#123; if (bottomView == null || isLoading || stateView != null) return; isLoading = true; jcAdapter.notifyDataSetChanged(); onLoadMoreListener.onLoadMore(); scrollToPosition(jcAdapter.getItemCount() - 1); &#125; &#125; else &#123; LinearLayoutManager lm = (LinearLayoutManager) recyclerView.getLayoutManager(); int totalItemCount = recyclerView.getAdapter().getItemCount(); int lastVisibleItemPosition = lm.findLastVisibleItemPosition(); int visibleItemCount = recyclerView.getChildCount(); if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; lastVisibleItemPosition == totalItemCount - 1 &amp;&amp; visibleItemCount &gt; 0) &#123; if (bottomView == null || isLoading || stateView != null) return; isLoading = true; jcAdapter.notifyDataSetChanged(); onLoadMoreListener.onLoadMore(); scrollToPosition(jcAdapter.getItemCount() - 1); &#125; &#125; &#125; &#125;); &#125; private int findMaxPosition(int[] positions) &#123; int max = positions[0]; for (int index = 1; index &lt; positions.length; index++) &#123; if (positions[index] &gt; max) &#123; max = positions[index]; &#125; &#125; return max; &#125; public void setBottomView(ViewGroup view) &#123; if (bottomView == null) &#123; this.bottomView = view; &#125; &#125; public void setLoading(boolean flag) &#123; if (!flag) &#123; isLoading = false; jcAdapter.notifyDataSetChanged(); scrollToPosition(jcAdapter.getItemCount() - 1); &#125; &#125; public void setAdSlotView(ViewGroup view) &#123; if (adSlotView == null) &#123; adSlotView = view; if (jcAdapter != null) &#123; jcAdapter.notifyItemInserted(0); scrollToPosition(0); &#125; &#125; &#125; public void setStateView(ViewGroup view) &#123; if (stateView != null) return; if (view == null) return; if (adSlotView != null) &#123; scrollToPosition(0); stateView = view; Rect rect = new Rect(); getGlobalVisibleRect(rect); LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, rect.bottom - rect.top - adSlotView.getHeight()); adSlotView.addView(stateView, layoutParams); &#125; else &#123; showToast(\"You should set the ad-slot view at first.\"); &#125; &#125; public void removeAdSlotView() &#123; if (adSlotView != null &amp;&amp; jcAdapter != null) &#123; adSlotView = null; jcAdapter.notifyItemRemoved(0); &#125; &#125; public void removeStateView() &#123; if (adSlotView != null &amp;&amp; stateView != null &amp;&amp; jcAdapter != null) &#123; adSlotView.removeView(stateView); stateView = null; &#125; &#125; @Override public void setAdapter(Adapter adapter) &#123; this.jcAdapter = new JCAdapter(adapter); super.setAdapter(this.jcAdapter); &#125; public JCRecyclerView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public void setLayoutManager(LayoutManager layoutManager) &#123; this.layoutManager = layoutManager; super.setLayoutManager(layoutManager); &#125; private class JCAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; &#123; private RecyclerView.Adapter adapter; private static final int TYPE_ADSLOT = 0x10; private static final int TYPE_NORMAL = 0x11; private static final int TYPE_BOTTOM = 0x12; public JCAdapter(RecyclerView.Adapter adapter) &#123; this.adapter = adapter; &#125; @Override public void onViewAttachedToWindow(ViewHolder holder) &#123; super.onViewAttachedToWindow(holder); ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams(); if(layoutParams != null)&#123; if(adSlotView != null) &#123; if(layoutParams instanceof StaggeredGridLayoutManager.LayoutParams &amp;&amp; holder.getLayoutPosition() == 0)&#123; StaggeredGridLayoutManager.LayoutParams p = (StaggeredGridLayoutManager.LayoutParams) layoutParams; p.setFullSpan(true); &#125; &#125; if (bottomView != null &amp;&amp; isLoading) &#123; if(layoutParams instanceof StaggeredGridLayoutManager.LayoutParams &amp;&amp; holder.getLayoutPosition() == getItemCount() - 1)&#123; StaggeredGridLayoutManager.LayoutParams p = (StaggeredGridLayoutManager.LayoutParams) layoutParams; p.setFullSpan(true); &#125; &#125; &#125; if (layoutManager instanceof GridLayoutManager) &#123; final GridLayoutManager gridManager = ((GridLayoutManager) layoutManager); gridManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() &#123; @Override public int getSpanSize(int position) &#123; boolean spanResult = false; if(adSlotView != null &amp;&amp; bottomView != null) &#123; if (isLoading) &#123; spanResult = (position == 0 || position == getItemCount() - 1); &#125; else &#123; spanResult = (position == 0); &#125; &#125; else if (adSlotView != null) &#123; spanResult = (position==0); &#125; else if (bottomView != null &amp;&amp; isLoading) &#123; spanResult = (position == getItemCount() - 1); &#125; return spanResult ? gridManager.getSpanCount():1; &#125; &#125;); &#125; &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; if (viewType == TYPE_ADSLOT) &#123; return new JCViewHolder(adSlotView); &#125; else if (viewType == TYPE_BOTTOM) &#123; return new JCViewHolder(bottomView); &#125; return adapter.onCreateViewHolder(parent,viewType); &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; if (getItemViewType(0) == TYPE_ADSLOT) &#123; if (position == 0) return; int newPosition = --position; if (adapter != null) &#123; if (newPosition &lt; adapter.getItemCount()) &#123; adapter.onBindViewHolder(holder, newPosition); &#125; &#125; return; &#125; else if (getItemViewType(position) == TYPE_BOTTOM) &#123; return; &#125; adapter.onBindViewHolder(holder, position); &#125; @Override public int getItemCount() &#123; int count = adapter.getItemCount(); if (adSlotView != null) &#123; count ++; &#125; if (bottomView != null &amp;&amp; isLoading) &#123; count ++; &#125; return count; &#125; @Override public int getItemViewType(int position) &#123; if (position == 0) &#123; return adSlotView == null ? TYPE_NORMAL : TYPE_ADSLOT; &#125; else if (position == getItemCount() - 1 &amp;&amp; isLoading) &#123; return bottomView == null ? TYPE_NORMAL : TYPE_BOTTOM; &#125; else &#123; return TYPE_NORMAL; &#125; &#125; &#125; private class JCViewHolder extends RecyclerView.ViewHolder &#123; public JCViewHolder(View itemView) &#123; super(itemView); &#125; &#125; private void showToast(String msg) &#123; Toast.makeText(getContext(),msg,Toast.LENGTH_SHORT).show(); &#125; public interface OnLoadMoreListener &#123; void onLoadMore(); &#125;&#125; 200 多行代码，轻松实现 RecyclerView 刷新、加载以及异常状态的展示功能。","categories":[{"name":"Android","slug":"Android","permalink":"https://githubhaohao.github.io/categories/Android/"}],"tags":[{"name":"RecyclerView 加载与刷新","slug":"RecyclerView-加载与刷新","permalink":"https://githubhaohao.github.io/tags/RecyclerView-加载与刷新/"}]},{"title":"Android jar 与 aar","slug":"Android-jar-与-aar","date":"2017-04-01T04:43:26.000Z","updated":"2017-04-20T14:00:14.883Z","comments":true,"path":"2017/04/01/Android-jar-与-aar/","link":"","permalink":"https://githubhaohao.github.io/2017/04/01/Android-jar-与-aar/","excerpt":"","text":"愚人节不愚人 最近开始搞机器学习，同时项目也不停的维护着！嘿嘿，明天就是小长假了。 Android jar 与 aarjar (Java Application Resource) 是一种归档文件，以 ZIP 格式构建，以 .jar 为文件扩展名。用户可以使用JDK自带的 jar 命令创建或提取 JAR 文件。jar 文件只包含 class 文件和 配置文件。 aar (Android Application Resource) 是 android 中特有的归档文件，既包含 class 文件也包含 android 的 res 资源文件。 Android Studio 生成 jar 和 aar 文件新建一个 ModuleAndroid studio 菜单 File -&gt; New -&gt; New Module -&gt; Android Module 。 创建名为 mylibrary 的 module。 在 mylibrary 下新建一个类 Person ,等会在 app module 下访问它。 生成 jar 和 aar 文件直接 Rebuild 或者运行 mylibrary task 如下图： Build Successful 之后可在下图的目录下找到 jar 和 arr 文件。 引入 jar 将 jar 文件拷贝到 app 的 lib 文件夹下； 右击 jar 文件，选择 Add As Library ，添加到 app module 下，然后 Android Studio 会自动编译。 引入 aar 将 aar 文件拷贝到 app 的 lib 文件夹下 (可以修改 aar 文件名字，本例中修改为 mylibrary )； 修改 build.gradle 配置文件：12345678910111213android &#123; ...... repositories &#123; flatDir &#123; dirs 'libs' &#125; &#125;&#125;dependencies &#123; ...... compile(name: 'mylibrary', ext: 'aar') &#125; Async Project 大工告成。 同样，你也可以在其他工程中引入 jar 或 aar 文件。","categories":[{"name":"Android","slug":"Android","permalink":"https://githubhaohao.github.io/categories/Android/"}],"tags":[{"name":"jar aar","slug":"jar-aar","permalink":"https://githubhaohao.github.io/tags/jar-aar/"}]},{"title":"Android 四大组件之 Activity","slug":"Android-四大组件之-Activity","date":"2017-03-01T06:36:14.000Z","updated":"2017-04-20T14:01:46.646Z","comments":true,"path":"2017/03/01/Android-四大组件之-Activity/","link":"","permalink":"https://githubhaohao.github.io/2017/03/01/Android-四大组件之-Activity/","excerpt":"","text":"唉！最近拖延症又犯了 最近真的是越来越懒了，总是找各种理由不写博客。虽然最近各种事，又搞论文，又搞项目的，再拖下去实在是对不住 “不忘初心” 这一句话。惭愧！虽然关于 Activity 已经被写烂了，但是从本篇文章里，你一定会发现不同的东西。 Activity 生命周期一般情况下 12345678910111213public class Activity extends ApplicationContext &#123; protected void onCreate(Bundle savedInstanceState); protected void onStart(); protected void onResume(); protected void onPause(); protected void onStop(); protected void onDestroy();&#125; 异常情况下系统配置变化导致Activity销毁重建 旋转屏幕，Activity 销毁并重新创建，在异常情况下系统会在 onStop 之前调用 onSaveInstanceState 来保存状态。Activity 重新创建后，会在 onStart 之后调用 onRestoreInstanceState 恢复之前保存的数据。 系统只在 Activity 异常终止的时候才会调用 onSaveInstanceState 和 onRestoreInstanceState 方法。其他情况不会触发。 资源内存不足导致低优先级的 Activity 被回收 前台- 可见非前台（被对话框遮挡的 Activity ）-后台，这三种 Activity 优先级从高到低。 android:configChanges=&quot;orientation&quot; 在 manifest 中指定 configChanges 在系统配置变化后不重新创建 Activity，也不会执行onSaveInstanceState 和 onRestoreInstanceState 方法，而是调用 onConfigurationChnaged 方法。 configChanges 一般常用三个选项： locale 系统语言变化 keyborardHidden 键盘的可访问性发生了变化，比如用户调出了键盘 orientation 屏幕方向变化 场景首次启动 Activity123MainActivity onCreateMainActivity onStartMainActivity onResume 跳转到 SecondActivity12345MainActivity onPauseSecondActivity onCreateSecondActivity onStartSecondActivity onResumeMainActivity onStop Back 返回 MainActivity123456SecondActivity onPauseMainActivity onRestartMainActivity onStartMainActivity onResumeSecondActivity onStopSecondActivity onDestroy Home 回退桌面12MainActivity onPauseMainActivity onStop 桌面返回可见123MainActivity onRestartMainActivity onStartMainActivity onResume 锁屏12MainActivity onPauseMainActivity onStop 解锁屏123MainActivity onRestartMainActivity onStartMainActivity onResume 注意onStart 开始到 onStop 之前， Activity 可见。onResume 开始到 onPause 之前， Activity 可接受用户交互。在新Activity启动之前，栈顶的Activity需要先onPause后，新Activity才能启动。所以不能在onPause执行耗时操作。 Activity 数据传递Activity 传递数据一般有以下几种方式： Intent 传递数据MainActivity 123456Intent intent=new Intent(); intent.setClass(MainActivity.this, OtherActivity.class); Bundle bundle = new Bundle(); bundle.putString(KEY, VALUE);intent.putExtras(bundle); startActivity（intent）; OtherActivity 123Intent intent = getIntent(); Bundle bundle = intent.getEtras(); String value = bundle.getString(KEY); 利用 Intent 对象在 Activity 之间传递数据是 Android 开发最常用的方式。利用 Intent 对象可以传递基本数据类型，以及一些可序列化的对象。 public 型的静态变量public 型的静态变量，在类被加载的时候，就被创建在静态存储区，不依赖于对象。 Application 对象在整个应用程序中就一个Application单例，它的生命周期贯穿整个程序，堆内存中只存在一个对象实例，所以程序内所有它的引用指向的是同一块堆内存，所以可以在不同activity对application实例变量进行值的存取。不推荐。 Clipboard 剪切板ClipboardManager：该类是系统剪切板服务的接口，用来放入或取出全局剪切板中的文本。 1234ClipboardManager clipboardManager = (ClipboardManager)getSystemService(Context.CLIPBOARD_SERVICE);clipboardManager.setText(DATA.toString());&#125; 12ClipboardManager clipboardManager = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE); String data = clipboardManager.getText().toString(); Clipboard 也可以传递可序列化对象。 文件传值通过向本地文件写入和读取来传递数据。常用的如 SharedPrefrences 对象等。 数据库你自己想吧！ Activity 启动模式启动模式,简单地说就是 Activity 启动时的策略，在AndroidManifest.xml 中的标签的 android:launchMode 属性设置； 启动模式有4种，分别为 standard、singleTop、singleTask、singleInstance； standard 模式每次 startActivity 时，都创建 Activity 实例，并放入任务栈，该任务栈中，可以有多个同类 Activity 的实例。 应用场景：Your idea。 singleTop 模式栈顶不是该类型的 Activity，则创建一个新的 Activity。否则，回调该 Activity 实例的 onNewIntent 方法。 应用场景：接收通知消息启动的页面。 例如，对于推送比较频繁的应用，如果收到多个推送，每次都打开一个页面显示内容是不妥的。 singleTask 模式任务栈中不存在启动 Activity 的实例，则创建 Activity 放入任务栈。否则，回调该 Activity 的 onNewIntent 方法，并将该 Activity 置于栈顶，其以上的 Activity 都被弹出 (pop)。[onNewIntent + clearTop] 应用场景：作为应用的入口点。 例如，对于浏览器的主界面，不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走 onNewIntent ，并且会清空主界面上面的其他页面。 singleInstance 模式回退栈中，只有这一个Activity，没有其他Activity。 应用场景：闹铃的响铃界面。正在进行 QQ 聊天室时，闹铃响了，弹出一个对话形式的（以 SingleInstance 加载模式打开的）AlarmActivity，按了返回键之后回到 QQ 聊天界面，这是因为 Alarm Activity 所在的任务栈只有它一个元素， 因此退出之后这个任务栈空了。如果是以 SingleTask 打开 AlarmActivity，那么当闹铃响了的时候，按返回键应该进入闹铃设置界面。","categories":[{"name":"Android","slug":"Android","permalink":"https://githubhaohao.github.io/categories/Android/"}],"tags":[{"name":"Activity","slug":"Activity","permalink":"https://githubhaohao.github.io/tags/Activity/"}]},{"title":"Android主题切换和多主题实现","slug":"Android主题切换和多主题实现","date":"2017-02-17T06:13:42.000Z","updated":"2017-02-17T13:48:53.485Z","comments":true,"path":"2017/02/17/Android主题切换和多主题实现/","link":"","permalink":"https://githubhaohao.github.io/2017/02/17/Android主题切换和多主题实现/","excerpt":"","text":"又是一个周末 白天和夜间模式Android官方在Support包从23.2版本开始提供支持白天夜间模式的主题 Theme.AppCompat.DayNight，也就是 DayNight Mode ，轻松实现主体无缝切换。 Theme.AppCompat.DayNight 可以根据系统时间切换 Theme.AppCompat (暗色) 和 Theme.AppCompat.Light ( 亮色 ) 两种主题。这将大大提高了阅读类应用的用户体验 同时还支持 Material Design。 需要注意的是，这个特性只支持 API v14 及以上的 Android 设备，在 API v14 以下的设备则会默认使用亮色的主题。 效果预览 具体过程1. 引入 support-v7:23.2+ 版本的依赖1compile 'com.android.support:appcompat-v7:25.1.1' 为保证主题风格的统一，所有的 Activity 类应继承 AppCompatActivity 。 2. 自定义实现 DayNight 主题 res 目录下新建 values-night 文件，拷贝修改 colors.xml 和 styles.xml 文件到 values-night，为 Night Model 下系统加载的 color资源，同样地也可以指定 Night Model 下加载的 drawable 资源在 drawable-night 文件夹中，同理 layout mipmap 资源加载也是如此。 123456&lt;style name=\"MyApp.DayNight.NoActionBar.Theme\" parent=\"Theme.AppCompat.DayNight.NoActionBar\"&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; &lt;item name=\"android:textColorPrimary\"&gt;@color/colorAccent&lt;/item&gt;&lt;/style&gt; 具体位置颜色设置看图： 在 AndroidManifest.xml 中声明，单个 Activity 的主题。 1234567891011121314151617&lt;application android:name=\".MyApplication\" android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:supportsRtl=\"true\"&gt; &lt;activity android:name=\".MainActivity\" android:label=\"@string/app_name\" android:theme=\"@style/MyApp.DayNight.NoActionBar.Theme\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt;&lt;/application&gt; 或者整个 App 的主题 12345678910111213141516171819&lt;application android:name=\".MyApplication\" android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:supportsRtl=\"true\" android:theme=\"@style/MyApp.DayNight.NoActionBar.Theme\"&gt; &lt;activity android:name=\".MainActivity\" android:label=\"@string/app_name\" &gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt;&lt;/application&gt; 3 设置 DayNight 主题初始化主题: 1234567891011private void initAppTheme() &#123; if (getThemeSharedPref().getBoolean(KEY_NIGHT_THEME, false)) &#123; getDelegate().setLocalNightMode(AppCompatDelegate.MODE_NIGHT_YES); &#125; else &#123; getDelegate().setLocalNightMode(AppCompatDelegate.MODE_NIGHT_NO); &#125;&#125;private SharedPreferences getThemeSharedPref() &#123; return getSharedPreferences(\"APP_THEME\", Context.MODE_PRIVATE);&#125; 初始化主题应该在 super.onCreate() 之前执行，不然 Activity 会启动 2 次,下图为证： 切换主题： 1234567if (id == R.id.set_day_theme) &#123; getDelegate().setLocalNightMode(AppCompatDelegate.MODE_NIGHT_NO); getThemeSharedPref().edit().putBoolean(KEY_NIGHT_THEME,false).apply();&#125; else if (id == R.id.set_night_theme) &#123; getDelegate().setLocalNightMode(AppCompatDelegate.MODE_NIGHT_YES); getThemeSharedPref().edit().putBoolean(KEY_NIGHT_THEME, true).apply();&#125; 切换主题会重启 Activity。 DayNight Theme 有 4 种 Model ，分别是： MODE_NIGHT_NO. 使用 Day 主题 MODE_NIGHT_YES. 使用暗色 Night 主题 MODE_NIGHT_AUTO. 根据系统时间自动切换 MODE_NIGHT_FOLLOW_SYSTEM(默认选项). 设置为跟随系统 多主题实现介绍几种换肤的第三方库。 MultipleTheme真正的支持无缝换肤／夜间模式的Android框架，配合theme和换肤控件框架可以做到无缝切换换肤（无需重启应用和当前页面）。 该应用框架可以实现无缝换肤／切换夜间模式的需求，需要在换肤／切换夜间模式的界面只需要使用框架里的自封装控件，其他界面的控件使用原生android控件即可。 MultipleTheme 缺陷：各种控件都需要重定义。优势：扩展性强，无需重启 Activity。 Colorful [推荐]Colorful is a dynamic theme library allowing you to change your apps’ color schemes easily. MultipleTheme 缺陷：主题颜色可定制性差，不支持 Material Design 风格。优势：使用方便。 Prism Prism 下含有三个库： prsim 库含有一些核心功能； prism-viewpager 库实现了核心库与 ViewPager 的对接； prism-palette 库实现了核心库与 Palette 的对接。 分成三个库是为了区分依赖条件：核心库不依赖外部条件，它能够很容易地添加到你的工程之中；但是 prism-viewpager 和 prism-palette 需要依赖相应的support库。所以当你的程序不使用这些依赖库时，你可以只使用 prism 库来省去不必要的依赖条件。不过当你的程序中使用了 ViewPager 时，即已经对相关的support库有了依赖，那么添加 prism-viewpager 库就不需要额外的依赖条件。 但是，作者已停止更新。 Android-Skin-Loader [推荐]看效果 项目目录： Android-Skin-Loader├── android-skin-loader-lib // 皮肤加载库├── android-skin-loader-sample // 皮肤库应用实例├── android-skin-loader-skin // 皮肤包生成demo└── skin-package // 皮肤包输出目录 可以将皮肤文件打包分离，支持在线换肤，皮肤共享，不会重启 Activity 或 Fragment 。皮肤包（ 后缀名为.skin ）的本质是一个apk文件，该apk文件不包含代码，只包含资源文件。 缺陷：每个换肤的 View 都要设置 skin:enable=&quot;true&quot; 繁琐 ( 反正我感觉挺烦的 )，不支持 Material Design 风格。 不过，还好 ThemeSkinning 进行了优化，支持 Material Design 和字体的切换。 示例：","categories":[{"name":"Android","slug":"Android","permalink":"https://githubhaohao.github.io/categories/Android/"}],"tags":[{"name":"Android主题切换","slug":"Android主题切换","permalink":"https://githubhaohao.github.io/tags/Android主题切换/"}]},{"title":"MVVM，RxJava 和 Retrofit 的一次实践","slug":"MVVM，RxJava和Retrofit的一次实践","date":"2017-02-12T06:21:25.000Z","updated":"2017-04-28T00:57:50.740Z","comments":true,"path":"2017/02/12/MVVM，RxJava和Retrofit的一次实践/","link":"","permalink":"https://githubhaohao.github.io/2017/02/12/MVVM，RxJava和Retrofit的一次实践/","excerpt":"","text":"春节后的第一篇博客 一次简单的实践作为对 MVVM 架构模式认识的总结。原创文章，转载请注明出处:haohaochang.cn 效果预览 准备知识MVC 视图层（View）：用户界面。 控制器层（Controller）：业务逻辑 模型层（Model）：数据保存 View 层传送指令到 Controller 层 Controller 层完成业务逻辑后，要求 Model 层改变状态 Model 层将新的数据发送到 View层，使用户得到反馈 缺陷:View 层和 Model 层是相互可知，耦合性大，像 Activity 或者 Fragment 既在 Controller 层，又在 View 层，造成工程的可扩展性可维护性非常差。 MVP 在 MVP 架构模式中，Controller 层变成了 Presenter 层。 MVP 模式各层之间的通信，都是双向的。 View 层与 Model 层不直接发生联系，都通过 Presenter 层进行间接通信。 Model 层与 Presenter 层，Presenter 层与 View 层之间通过接口建立联系。 采用 MVP 模式，Activity 与 Fragment 只位于 View 层。 MVP 的缺陷在于:由于我们使用了接口的方式去连接 View 层和 Presenter 层，这样就导致了特定场景下的一些问题，当你的页面逻辑很复杂的时候，你的 View 层实现的接口会有很多，如果你的 App 中有很多个这样复杂的页面，维护接口的成本就会变的非常的大。 MVVM MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。区别在于: View 层与 ViewModel 层通过 DataBinding 相互绑定，View 层的变动，自动反映在 ViewModel 层，反之亦然。 RxJava Rx 是微软 .Net 的一个响应式扩展，Rx 借助可观测的序列提供一种简单的方式来创建异步的，基于事件驱动的程序。2012 年 Netflix 为了应对不断增长的业务需求开始将 .NET Rx 迁移到 JVM 上面。并于 13 年二月份正式向外展示了 RxJava 。 从语义的角度来看， RxJava 就是 .NET Rx 。从语法的角度来看， Netflix 考虑到了对应每个 Rx 方法,保留了 Java 代码规范和基本的模式。 RxJava 在 GitHub 主页的介绍是： RxJava is a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences. RxJava 一个在 Java VM 上使用可观测的序列来组成异步的、基于事件程序的库。 RxJava 本质上是一个异步操作库，是一个能让你用极其简洁的逻辑去处理繁琐复杂任务的异步事件库。 简而言之，RxJava 可以用几个关键字概括：简洁，队列化，异步。 Retrofit 一个 Android 和 Java 上 HTTP 库（利用注解和 OKHttp 来实现和服务器的数据交互）。 Retrofit 基于 OKHttp 并引入注解，使用简单，易扩展，易维护。 Retrofit 官方文档:http://square.github.io/retrofit/ DataBinding 在Google IO 2015 中，Google 在 support-v7 中新增了 Data Binding，使用 Data Binding可以直接在布局的 xml 中绑定布局与数据，从而简化代码，Android Data Binding是Android 的 MVVM 框架。因为 Data Binding 是包含在 support-v7 包里面的，所以可以向下兼容到最低 Android 2.1 (API level 7+). 实践直接上代码。 依赖的第三方类库123456compile 'io.reactivex:rxjava:1.1.0'compile 'io.reactivex:rxandroid:1.1.0'compile 'com.squareup.retrofit2:retrofit:2.0.0-beta4'compile 'com.squareup.retrofit2:converter-gson:2.0.0-beta4'compile 'com.squareup.retrofit2:adapter-rxjava:2.0.0-beta4'compile 'com.github.bumptech.glide:glide:3.7.0' APIhttps://api.douban.com/v2/movie/top250?start=0&amp;count=20 引入DataBinding1234567android &#123; ...... dataBinding &#123; enabled = true &#125;&#125; 工程目录结构 MVVM 之 ViewMainActivity.java 1getFragmentManager().beginTransaction().add(R.id.movie_fragment, MovieFragment.getInstance()).commit(); MovieFragment.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MovieFragment extends Fragment implements CompletedListener,SwipeRefreshLayout.OnRefreshListener&#123; private static String TAG = MovieFragment.class.getSimpleName(); private MainViewModel viewModel; private MovieFragmentBinding movieFragmentBinding; private MovieAdapter movieAdapter; public static MovieFragment getInstance() &#123; return new MovieFragment(); &#125; @Nullable @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View contentView = inflater.inflate(R.layout.movie_fragment, container, false); movieFragmentBinding = MovieFragmentBinding.bind(contentView); initData(); return contentView; &#125; private void initData() &#123; movieAdapter = new MovieAdapter(); movieFragmentBinding.recyclerView.setLayoutManager(new LinearLayoutManager(getActivity(), LinearLayoutManager.VERTICAL, false)); movieFragmentBinding.recyclerView.setItemAnimator(new DefaultItemAnimator()); movieFragmentBinding.recyclerView.setAdapter(movieAdapter); movieFragmentBinding.swipeRefreshLayout.setColorSchemeResources(R.color.colorAccent, R.color.colorPrimary, R.color.colorPrimaryDark); movieFragmentBinding.swipeRefreshLayout.setOnRefreshListener(this); viewModel = new MainViewModel(movieAdapter,this); movieFragmentBinding.setViewModel(viewModel); &#125; @Override public void onRefresh() &#123; movieAdapter.clearItems(); viewModel.refreshData(); &#125; @Override public void onCompleted() &#123; if (movieFragmentBinding.swipeRefreshLayout.isRefreshing()) &#123; movieFragmentBinding.swipeRefreshLayout.setRefreshing(false); &#125; &#125;&#125; activity_main.xml 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" tools:context=\".view.MainActivity\"&gt; &lt;!-- ... --&gt; &lt;FrameLayout android:layout_marginTop=\"?attr/actionBarSize\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/movie_fragment\"/&gt; &lt;!-- ... --&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; movie_fragment.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;data&gt; &lt;variable name=\"viewModel\" type=\"com.jc.mvvmrxjavaretrofitsample.viewModel.MainViewModel\"/&gt; &lt;/data&gt; &lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v4.widget.SwipeRefreshLayout android:visibility=\"@&#123;viewModel.contentViewVisibility&#125;\" android:id=\"@+id/swipe_refresh_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recycler_view\" android:background=\"#ddd\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:padding=\"8dp\"&gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;/android.support.v4.widget.SwipeRefreshLayout&gt; &lt;ProgressBar style=\"?android:attr/progressBarStyleLarge\" android:id=\"@+id/progress_bar\" android:visibility=\"@&#123;viewModel.progressBarVisibility&#125;\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerInParent=\"true\"/&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:id=\"@+id/error_info_layout\" android:visibility=\"@&#123;viewModel.errorInfoLayoutVisibility&#125;\" android:orientation=\"vertical\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_gravity=\"center\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;viewModel.exception&#125;\"/&gt; &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt;&lt;/layout&gt; movie_item.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/tools\"&gt; &lt;data&gt; &lt;variable name=\"viewModel\" type=\"com.jc.mvvmrxjavaretrofitsample.viewModel.MovieViewModel\"/&gt; &lt;/data&gt; &lt;android.support.v7.widget.CardView xmlns:card_view=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/card_view\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" card_view:cardCornerRadius=\"4dp\" card_view:cardBackgroundColor=\"@color/background\" card_view:cardUseCompatPadding=\"true\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\"&gt; &lt;ImageView android:layout_margin=\"8dp\" android:layout_width=\"60dp\" android:layout_height=\"100dp\" android:src=\"@drawable/cover\" app:imageUrl=\"@&#123;viewModel.imageUrl&#125;\" android:id=\"@+id/cover\"/&gt; &lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:layout_margin=\"8dp\" android:orientation=\"vertical\"&gt; &lt;TextView android:textColor=\"@android:color/black\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;viewModel.title&#125;\" android:textSize=\"12sp\"/&gt; &lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"4dp\" android:orientation=\"horizontal\"&gt; &lt;android.support.v7.widget.AppCompatRatingBar android:id=\"@+id/ratingBar\" style=\"?android:attr/ratingBarStyleSmall\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_vertical\" android:isIndicator=\"true\" android:max=\"10\" android:numStars=\"5\" android:rating=\"@&#123;viewModel.rating&#125;\" /&gt; &lt;TextView android:id=\"@+id/rating_text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_vertical\" android:layout_marginLeft=\"6dp\" android:text=\"@&#123;viewModel.ratingText&#125;\" android:textColor=\"?android:attr/textColorSecondary\" android:textSize=\"10sp\" /&gt; &lt;/LinearLayout&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textColor=\"?android:attr/textColorSecondary\" android:textSize=\"10sp\" android:text=\"@&#123;viewModel.movieType&#125;\" android:id=\"@+id/movie_type_text\" android:layout_marginTop=\"6dp\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textColor=\"?android:attr/textColorSecondary\" android:textSize=\"10sp\" android:text=\"@&#123;viewModel.year&#125;\" android:id=\"@+id/year_text\" android:layout_marginTop=\"6dp\" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/android.support.v7.widget.CardView&gt;&lt;/layout&gt; MovieAdapter.java 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MovieAdapter extends RecyclerView.Adapter&lt;MovieAdapter.BindingHolder&gt; &#123; private List&lt;Movie&gt; movies; public MovieAdapter() &#123; movies = new ArrayList&lt;&gt;(); &#125; @Override public BindingHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; MovieItemBinding itemBinding = DataBindingUtil.inflate(LayoutInflater.from(parent.getContext()), R.layout.movie_item, parent, false); return new BindingHolder(itemBinding); &#125; @Override public void onBindViewHolder(BindingHolder holder, int position) &#123; MovieViewModel movieViewModel = new MovieViewModel(movies.get(position)); holder.itemBinding.setViewModel(movieViewModel); &#125; @Override public int getItemCount() &#123; return movies.size(); &#125; public void addItem(Movie movie) &#123; movies.add(movie); notifyItemInserted(movies.size() - 1); &#125; public void clearItems() &#123; movies.clear(); notifyDataSetChanged(); &#125; public static class BindingHolder extends RecyclerView.ViewHolder &#123; private MovieItemBinding itemBinding; public BindingHolder(MovieItemBinding itemBinding) &#123; super(itemBinding.cardView); this.itemBinding = itemBinding; &#125; &#125;&#125; 回调接口 CompletedListener.java 123public interface CompletedListener &#123; void onCompleted();&#125; MVVM 之 ViewModelMainViewModel.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class MainViewModel &#123; public ObservableField&lt;Integer&gt; contentViewVisibility; public ObservableField&lt;Integer&gt; progressBarVisibility; public ObservableField&lt;Integer&gt; errorInfoLayoutVisibility; public ObservableField&lt;String&gt; exception; private Subscriber&lt;Movie&gt; subscriber; private MovieAdapter movieAdapter; private CompletedListener completedListener; public MainViewModel(MovieAdapter movieAdapter,CompletedListener completedListener) &#123; this.movieAdapter = movieAdapter; this.completedListener = completedListener; initData(); getMovies(); &#125; private void getMovies() &#123; subscriber = new Subscriber&lt;Movie&gt;() &#123; @Override public void onCompleted() &#123; Log.d(\"[MainViewModel]\", \"onCompleted\"); hideAll(); contentViewVisibility.set(View.VISIBLE); completedListener.onCompleted(); &#125; @Override public void onError(Throwable e) &#123; hideAll(); errorInfoLayoutVisibility.set(View.VISIBLE); exception.set(e.getMessage()); &#125; @Override public void onNext(Movie movie) &#123; movieAdapter.addItem(movie); &#125; &#125;; RetrofitHelper.getInstance().getMovies(subscriber, 0, 20); &#125; public void refreshData() &#123; getMovies(); &#125; private void initData() &#123; contentViewVisibility = new ObservableField&lt;&gt;(); progressBarVisibility = new ObservableField&lt;&gt;(); errorInfoLayoutVisibility = new ObservableField&lt;&gt;(); exception = new ObservableField&lt;&gt;(); contentViewVisibility.set(View.GONE); errorInfoLayoutVisibility.set(View.GONE); progressBarVisibility.set(View.VISIBLE); &#125; private void hideAll()&#123; contentViewVisibility.set(View.GONE); errorInfoLayoutVisibility.set(View.GONE); progressBarVisibility.set(View.GONE); &#125;&#125; MovieViewModel.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MovieViewModel extends BaseObservable &#123; private Movie movie; public MovieViewModel(Movie movie) &#123; this.movie = movie; &#125; public String getCoverUrl() &#123; return movie.getImages().getSmall(); &#125; public String getTitle() &#123; return movie.getTitle(); &#125; public float getRating() &#123; return movie.getRating().getAverage(); &#125; public String getRatingText()&#123; return String.valueOf(movie.getRating().getAverage()); &#125; public String getYear() &#123; return movie.getYear(); &#125; public String getMovieType() &#123; StringBuilder builder = new StringBuilder(); for (String s : movie.getGenres()) &#123; builder.append(s + \" \"); &#125; return builder.toString(); &#125; public String getImageUrl() &#123; return movie.getImages().getSmall(); &#125; @BindingAdapter(&#123;\"app:imageUrl\"&#125;) public static void loadImage(ImageView imageView,String url) &#123; Glide.with(imageView.getContext()) .load(url) .placeholder(R.drawable.cover) .error(R.drawable.cover) .into(imageView); &#125;&#125; MVVM 之 ModelDouBanMovieService.java 123456public interface DouBanMovieService &#123; String BASE_URL = \"https://api.douban.com/v2/movie/\"; @GET(\"top250\") Observable&lt;Response&lt;List&lt;Movie&gt;&gt;&gt; getMovies(@Query(\"start\") int start, @Query(\"count\") int count);&#125; RetrofitHelper.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class RetrofitHelper &#123; private static final int DEFAULT_TIMEOUT = 10; private Retrofit retrofit; private DouBanMovieService movieService; OkHttpClient.Builder builder; /** * 获取RetrofitHelper对象的单例 * */ private static class Singleton &#123; private static final RetrofitHelper INSTANCE = new RetrofitHelper(); &#125; public static RetrofitHelper getInstance() &#123; return Singleton.INSTANCE; &#125; public RetrofitHelper() &#123; builder = new OkHttpClient.Builder(); builder.connectTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS); retrofit = new Retrofit.Builder() .client(builder.build()) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .baseUrl(DouBanMovieService.BASE_URL) .build(); movieService = retrofit.create(DouBanMovieService.class); &#125; public void getMovies(Subscriber&lt;Movie&gt; subscriber, int start, int count) &#123; movieService.getMovies(start, count) .map(new Func1&lt;Response&lt;List&lt;Movie&gt;&gt;, List&lt;Movie&gt;&gt;() &#123; @Override public List&lt;Movie&gt; call(Response&lt;List&lt;Movie&gt;&gt; listResponse) &#123; return listResponse.getSubjects(); &#125; &#125;) .flatMap(new Func1&lt;List&lt;Movie&gt;, Observable&lt;Movie&gt;&gt;() &#123; @Override public Observable&lt;Movie&gt; call(List&lt;Movie&gt; movies) &#123; return Observable.from(movies); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(subscriber); &#125;&#125; 还有 entity 类，这里就不贴出来了。 详细源码：https://github.com/githubhaohao/MVVMRxJavaRetrofitSample","categories":[{"name":"Android","slug":"Android","permalink":"https://githubhaohao.github.io/categories/Android/"}],"tags":[{"name":"MVVM","slug":"MVVM","permalink":"https://githubhaohao.github.io/tags/MVVM/"}]},{"title":"ES6入门: 需要掌握的基本语法","slug":"ES6入门-需要掌握的基本语法","date":"2017-01-25T14:26:31.000Z","updated":"2017-04-21T02:07:00.879Z","comments":true,"path":"2017/01/25/ES6入门-需要掌握的基本语法/","link":"","permalink":"https://githubhaohao.github.io/2017/01/25/ES6入门-需要掌握的基本语法/","excerpt":"","text":"ES6是什么1. ES (ECMAScript) 和JavaScript的关系ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现（另外的ECMAScript方言还有Jscript和ActionScript）。日常场合，这两个词是可以互换的。 阮一峰ECMAScript 2. ES6和ECMAScript 2015的关系ES6，一般是指ECMAScript 2015标准，但有时也表示一种泛指，是指JavaScript语言的下一代标准。涵盖了ECMAScript 2015，2016，2017等版本，而ECMAScript 2015则是正式名称，特指该年发布的正式版本的语言标准。 Babel转码器 Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。去官网选择自己习惯的工具来使用使用Babel吧！ let和const命令let和const与var类似都是用来声明变量的，但又有各自不同的用途。let与var对比，看代码： 12345678var name = 'haohao';if(true)&#123; var name = 'jack'; console.log(name) //jack&#125; console.log(name) //jack ES5只有全局作用域和块级作用域，导致内层变量覆盖外层变量，使得两次输出的都是jack。而let为JS新增了块级作用域，因此它声明的变量只在let命令所在的代码块有效，具体看代码： 12345678let name = 'haohao';if(true)&#123; let name = 'jack'; console.log(name) //jack&#125; console.log(name) //haohao const用来声明常量，一旦声明就不能改变。当我们尝试改变const声明的常量时，浏览器就会报错。 123const PI = Math.PI PI = 23 //Module build failed: SyntaxError: /es6/app.js: \"PI\" is read-only 引用其他Module中声明的变量，用const来声明可以避免对其重命名而导致出现BUG。 1const &#123;width, height&#125; = window.get('Dimension'); 解构 (Destructuring)解构 (Destructuring) 是指按照某种模式，从对象或数组中提取值对指定的变量进行赋值。 ES6之前为变量赋值： 123let name = 'jack';let addr = 'cn';let sex = 'male'; ES6可以这样： 12345let [name,addr,sex] = ['jack','cn','male'];name //jackaddr //cnsex //male 默认值: 12345let [name,addr,sex = 'male'] = ['jack','cn'];name //jackaddr //cnsex //male 关于对象以前这样： 1234567let name = 'jack';let addr = 'cn';let sex = 'male';let student = &#123; name:name, addr:addr, sex:sex &#125;console.log(student);//Object &#123; name:'jack', addr:'cn', sex:'male' &#125; ES6可以这样： 1234567let name = 'jack';let addr = 'cn';let sex = 'male';let student = &#123; name, addr, sex &#125;console.log(student);//Object &#123; name:'jack', addr:'cn', sex:'male' &#125; 还有这样: 123456let student = &#123; name:'kene', addr:'us', sex:'male' &#125;let &#123; name, sex &#125; = student;let &#123; addr &#125; = student;console.log(name, addr, sex);//kene us male 模板字符串 (template string)传统模板字符串： 12345$('#showId').append( \"Hello，everyone!\" + \"I am Jack.\"+ \"I like eat \" + fruits + \"!\" ); ES6模板字符串： 12345$('#showId').append(` Hello，everyone! I am Jack. I like eat $&#123;fruits&#125;! `); 反引号标识起始，${}引入变量，所有的空格缩进保存输出。 箭头函数 (arrow functions)ES6允许使用“箭头”（=&gt;）定义函数。 12var func = i =&gt; i + 1;var func = (a, b) =&gt; &#123;a++; b++; return a + b;&#125; 上面的箭头函数等同于： 123456789var func = function(i) &#123; return i + 1;&#125;;var func = function(a, b) &#123; a++; b++; return a + b;&#125; 当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。有一种使用场景： 123456789101112131415class Person &#123; constructor()&#123; this.name = 'person'; &#125; sayHello()&#123; setTimeout(function()&#123; console.log(this.name + 'says hello.'); &#125;); &#125;&#125;let p = new Person();p.sayHello();//undefined says hello. 运行上面的代码会报错，这是因为setTimeout中的this指向的是全局对象。有了箭头函数上述问题便可迎刃而解： 123456789101112131415class Person &#123; constructor()&#123; this.name = 'person'; &#125; sayHello()&#123; setTimeout(() =&gt; &#123; console.log(this.name + 'says hello.'); &#125;); &#125;&#125;let p = new Person();p.sayHello();//person says hello. 类 (Class)ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。 123456789101112131415class Person &#123; constructor()&#123; this.name = 'person'; &#125; sayHello()&#123; setTimeout(() =&gt; &#123; console.log(this.name + 'says hello.'); &#125;); &#125;&#125;let p = new Person();p.sayHello();//person says hello. 上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。 ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 1234567891011class Student extends Person &#123; constructor()&#123; super(); this.name = 'student'; &#125;&#125;let s = new Student();s.sayHello();//student says hello. 上面定义了一个Student类，该类通过extends关键字，继承了Person类的所有属性和方法。 子类Student必须在constructor方法中调用super方法，否则新建实例时会报错,子类就得不到this对象。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。 export和importES6的模块化功能。以前这样写： 12345678//content.jsmodule.exports = 'apple';//index.jsvar fruits = require('./content.js');console.log(fruits);//apple ES6这样： 12345678//content.jsexport default 'apple';//index.jsimport fruits from './content.js';console.log(fruits);//apple 深入点，看代码： 12345678910111213141516171819//content.jsexport const KIND = 'Thailand Apple';export default 'apple';export function say()&#123; return 'I like apple!';&#125; //index.jsimport fruits, &#123; say, KIND &#125; from './content.js';//如果只导入say //import &#123; say &#125; from './content.js';console.log(fruits);console.log(KIND);say();//apple //Thailand Apple//I like apple! 修改变量名。 123456789101112131415161718//content.jsexport const KIND = 'Thailand Apple';export default 'apple';export function say()&#123; return 'I like apple!';&#125; //index.jsimport fruits, &#123; say, KIND as type &#125; from './content.js';console.log(fruits);console.log(type);say();//apple //Thailand Apple//I like apple! 整体加载,*为指定的一个对象。 123456789101112131415161718//content.jsexport const KIND = 'Thailand Apple';export default 'apple';export function say()&#123; return 'I like apple!';&#125; //index.jsimport fruits, * as content from './content.js';console.log(fruits);console.log(content.type);content.say();//apple //Thailand Apple//I like apple!","categories":[{"name":"ES6","slug":"ES6","permalink":"https://githubhaohao.github.io/categories/ES6/"}],"tags":[{"name":"ES6入门","slug":"ES6入门","permalink":"https://githubhaohao.github.io/tags/ES6入门/"}]},{"title":"分分钟接入Tinker","slug":"分分钟接入Tinker","date":"2017-01-18T01:23:38.000Z","updated":"2017-01-18T02:51:40.837Z","comments":true,"path":"2017/01/18/分分钟接入Tinker/","link":"","permalink":"https://githubhaohao.github.io/2017/01/18/分分钟接入Tinker/","excerpt":"","text":"Tinker是什么Tinker是微信官方的Android热补丁解决方案，它支持动态下发代码、So库以及资源，让应用能够在不需要重新安装的情况下实现更新。当然，你也可以使用Tinker来更新你的插件。它主要包括以下几个部分： 1.gradle编译插件: tinker-patch-gradle-plugin 2.核心sdk库: tinker-android-lib 3.非gradle编译用户的命令行版本: tinker-patch-cli.jar Tencenttinker 引入依赖和插件在你项目根目录下的 build.gradle 文件中添加: 12345buildscript &#123; dependencies &#123; classpath ('com.tencent.tinker:tinker-patch-gradle-plugin:1.7.6') &#125;&#125; 在 app/build.gradle 文件中添加依赖和插件： 1234567891011dependencies &#123; //optional, help to generate the final application provided('com.tencent.tinker:tinker-android-anno:1.7.6') //tinker's main Android lib compile('com.tencent.tinker:tinker-android-lib:1.7.6') compile \"com.android.support:multidex:1.0.1\"&#125;......apply plugin: 'com.tencent.tinker.patch' 添加task添加task tinkerPatch 在 app/build.gradle 文件中,其中 oldApk 路径为出现BUG的APK路径（自定义），添加完之后Async Project。 123456789101112131415161718192021222324252627282930313233343536373839404142tinkerPatch &#123; oldApk = \"J://tinkerSample/app-debug.apk\" ignoreWarning = true useSign = true buildConfig &#123; applyMapping = null applyResourceMapping = null tinkerId = \"tinkerId\" &#125; dex &#123; dexMode = \"jar\" usePreGeneratedPatchDex = false pattern = [\"classes*.dex\", \"assets/secondary-dex-?.jar\"] loader = [\"com.tencent.tinker.loader.*\", \"com.jc.tinkersample.SimpleApp\", \"com.jc.tinkersample.BaseBuildInfo\" ] &#125; lib &#123; pattern = [\"lib/armeabi/*.so\"] &#125; res &#123; pattern = [\"res/*\", \"assets/*\", \"resources.arsc\", \"AndroidManifest.xml\"] ignoreChange = [\"assets/sample_meta.txt\"] largeModSize = 100 &#125; packageConfig &#123; configField(\"patchMessage\", \"tinker is sample to use\") configField(\"platform\", \"all\") configField(\"patchVersion\", \"1.0\") &#125; sevenZip &#123; zipArtifact = \"com.tencent.mm:SevenZip:1.1.10\" &#125;&#125; 接入Tinker自定义Application继承 DefaultApplicationLike 类，也可以自定义扩展。 12345678910111213141516171819202122@DefaultLifeCycle( application = \"com.jc.tinkersample.SimpleApp\", flags = ShareConstants.TINKER_ENABLE_ALL, loadVerifyFlag = false)public class SimpleAppLike extends DefaultApplicationLike &#123; public SimpleAppLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag, long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent, Resources[] resources, ClassLoader[] classLoader, AssetManager[] assetManager) &#123; super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent, resources, classLoader, assetManager); &#125; @Override public void onBaseContextAttached(Context base) &#123; super.onBaseContextAttached(base); MultiDex.install(base); TinkerInstaller.install(this); &#125; @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) public void registerActivityLifecycleCallbacks(Application.ActivityLifecycleCallbacks callback) &#123; getApplication().registerActivityLifecycleCallbacks(callback); &#125;&#125; 运行安装到你的手机里，然后把 app-debug.apk 放到 oldApk 对应的路径下，用于生成 patch.apk。 然后，修复你项目的bug（这里只是象征性地修改了一下Text），打开Android Studio 右侧的gradle project 运行 tinkerPatchDebug task生成patch.apk。 找到patch_signed_7zip.apk 文件。 复制 patch_signed_7zip.apk 文件把它放到手机外部存储目录下 （这里为根目录）。 12345678String path = Environment.getExternalStorageDirectory().getAbsolutePath() + \"/patch_signed_7zip.apk\";File file = new File(path);if (file.exists())&#123; Toast.makeText(this, \"patch.apk is existing.\", Toast.LENGTH_SHORT).show(); TinkerInstaller.onReceiveUpgradePatch(getApplicationContext(), path);&#125;else&#123; Toast.makeText(this,\"patch.apk is inexistent.\", Toast.LENGTH_SHORT).show();&#125; 调用Tinker API TinkerInstaller.onReceiveUpgradePatch(getApplicationContext(), path); 进行热修复，重启app热修复完成。 详细代码https://github.com/githubhaohao/TinkerSample 更多 微信Android热补丁实践演进之路 Android N混合编译与对热补丁影响深度解析 微信Tinker的一切都在这里，包括源码","categories":[{"name":"Android","slug":"Android","permalink":"https://githubhaohao.github.io/categories/Android/"}],"tags":[{"name":"Tinker","slug":"Tinker","permalink":"https://githubhaohao.github.io/tags/Tinker/"}]},{"title":"Hello World","slug":"cover","date":"2017-01-12T08:31:23.971Z","updated":"2017-01-18T01:30:29.106Z","comments":true,"path":"2017/01/12/cover/","link":"","permalink":"https://githubhaohao.github.io/2017/01/12/cover/","excerpt":"","text":"合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。 老子 不忘初心，不惧未来。haohao2017/01/14","categories":[],"tags":[{"name":"hello world","slug":"hello-world","permalink":"https://githubhaohao.github.io/tags/hello-world/"}]}]}